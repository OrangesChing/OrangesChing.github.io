<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>五、Nginx原理</title>
      <link href="/2021/06/10/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E4%B8%8E%E7%AE%A1%E7%90%86/Nginx/%E4%BA%94%E3%80%81Nginx%E5%8E%9F%E7%90%86/"/>
      <url>/2021/06/10/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E4%B8%8E%E7%AE%A1%E7%90%86/Nginx/%E4%BA%94%E3%80%81Nginx%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h1><p>Nginx由<u>内核</u>和<u>模块</u>组成</p><p>当它接到一个HTTP请求时，Nginx本身做的工作实际很少，它仅仅是通过查找配置文件将此次请求映射到一个<code>Server块</code>中的<code>Location块</code>，而此<code>Location块</code>中所配置的各个指令则会启动不同的模块去完成工作，因此<strong>模块</strong>可以看做Nginx真正的劳动工作者</p><p>通常一个<code>Location块</code>中的指令会涉及一个<code>handler模块</code>和多个<code>filter模块</code>。<code>handler模块</code>负责处理请求，完成响应内容的生成，而<code>filter模块</code>对响应内容进行处理</p><p><img alt="img" data-src="//orangesching.github.io/2021/06/10/服务器配置与管理/Nginx/五、Nginx原理/1183448-20180210145015185-1393050434.png" class="lazyload"></p><blockquote><p><strong>Nginx的模块<u>从结构上</u>分为：</strong></p><ul><li>核心模块：HTTP模块、EVENT模块和MAIL模块</li><li>基础模块：HTTP Access模块、HTTP FastCGI模块、HTTP Proxy模块和HTTP Rewrite模块</li><li>第三方模块：HTTP Upstream Request Hash模块、Notice模块和HTTP Access Key模块</li></ul><p><strong>用户根据自己的需要开发的模块都属于第三方模块。正是有了这么多模块的支撑，Nginx的功能才会如此强大</strong></p><p><strong>Nginx的模块<u>从功能上</u>分为：</strong></p><ul><li>Handlers（处理器模块）：此类模块直接处理请求，并进行输出内容和修改headers信息等操作。Handlers处理器模块一般只能有一个</li><li>Filters （过滤器模块）：此类模块主要对其他处理器模块输出的内容进行修改操作，最后由Nginx输出</li><li>Proxies （代理类模块）：此类模块是Nginx的HTTP Upstream之类的模块，这些模块主要与后端一些服务比如FastCGI等进行交互，实现服务代理和负载均衡等功能</li></ul></blockquote><h1 id="进程模型"><a href="#进程模型" class="headerlink" title="进程模型"></a>进程模型</h1><p><img alt="img" data-src="//orangesching.github.io/2021/06/10/服务器配置与管理/Nginx/五、Nginx原理/2281730-8ad56b939b4146f1.jpg" class="lazyload"></p><p>Nginx默认采用多进程工作方式，Nginx启动后，会运行一个<code>master进程</code>和多个<code>worker进程</code>：</p><ul><li><code>master进程</code>：充当整个进程组与用户的交互接口，同时对进程进行监护，管理worker进程来实现重启服务、平滑升级、更换日志文件、配置文件实时生效等功能</li><li><code>worker进程</code>：用来处理基本的网络事件，worker之间是平等的，他们共同<strong>竞争</strong>来处理来自客户端的请求</li></ul><p>这个进程模型使得Nginx可热部署</p><h1 id="处理流程及细节"><a href="#处理流程及细节" class="headerlink" title="处理流程及细节"></a>处理流程及细节</h1><p>Nginx支持多种连接处理方式，具体使用哪一种由当前平台决定，一般为Epoll方式，说原理的时候一般分析Epoll方式。Nginx的Epoll工作流程如下：</p><ol><li><code>master 进程</code>接受到信号（如nginx -s reload）后启动，读取配置文件，建好需要监听的<code>socket</code>后，然后再<code>fork</code>出多个<code>woker进程</code>，这样每个<code>work进程</code>都可以去<code>accept</code>这个<code>socket</code></li><li>当一个<code>client连接</code>到来时，所有<code>accept</code>的<code>work进程</code>都会受到通知，但只有一个进程可以accept成功，其它的则会accept失败（防止惊群现象）</li><li>当一个<code>worker进程</code> <code>accept</code>这个连接后，就开始读取请求，解析请求，处理请求，产生数据后，再返回给客户端，最后才断开连接，这样一个完成的请求就结束了（异步非阻塞方式）</li></ol><h2 id="连接处理方式"><a href="#连接处理方式" class="headerlink" title="连接处理方式"></a>连接处理方式</h2><p>nginx支持多种连接处理方式，具体使用哪一种由当前平台决定。如果当前平台支持多种方式，<u>nginx会自动选择最佳的方式</u>。在有需要的情况下，可以通过<code>use命令</code>来指定连接处理方式</p><ul><li>select方式：一种标准方式。当不存更为高效的方式时会使用<code>select-module</code>进行编译构建。使用<code>–with-select_module 和 --without-select_module</code>可以显式使用/禁止使用模块</li><li>poll方式：一种标准方式。当不存更为高效的方式时会使用<code>poll-module</code>进行编译构建。使用<code>–with-poll_module 和 --without-poll_module</code>可以显式使用/禁止使用模块</li><li>kqueue方式：一种高效方式。应用于FreeBSD 4.1+, OpenBSD 2.9+, NetBSD 2.0, and macOS</li><li><strong>epoll方式</strong>：一种高效方式。应用于Linux 2.6+</li><li>/dev/poll方式：一种高效方式。应用于Solaris 7 11/99+, HP/UX 11.22+ (eventport), IRIX 6.5.15+, and Tru64 UNIX 5.1A+</li><li>eventport方式：基于事件端口的一种方式，应用于Solaris 10+（由于一些明显缺陷，推荐使用/dev/poll替代）</li></ul><blockquote><p>apache 采用的select模型；nginx采用epoll模型</p><p>nginx 处理请求是异步非阻塞的，而apache则是阻塞型的，在高并发下nginx 能保持低资源低消耗高性能</p></blockquote><h3 id="Epoll方式：异步-非阻塞-事件驱动"><a href="#Epoll方式：异步-非阻塞-事件驱动" class="headerlink" title="Epoll方式：异步/非阻塞/事件驱动"></a>Epoll方式：异步/非阻塞/事件驱动</h3><p><strong>场景</strong>：大量请求来了，大多需要读写数据发生IO请求或需要等待结果，此时程序会发生中断，这个时候这个进程怎么办</p><ul><li>阻塞方案：这个进程啥也不干了，坐等IO请求完</li><li>非阻塞方案：这个进程先干别的，时不时看看IO请求完了没，请求完再回来处理这个请求</li></ul><p><strong>Nginx解决</strong>：利用Linux的Epoll模型异步非阻塞方式处理请求</p><p>每个worker里面只有一个主线程，但一个worker可以同时处理多个请求。每个请求进来，worker线程将其注册处理转发给下游服务后，并不是挂起等待，而是切换处理别的请求。采用这种轮询的方式来并发处理大量请求</p><p>比如：同时有多个http request的时候，worker主线程与第一条request建议连接将其处理转发给下游tomcat服务器后，并不会挂起等待，而是立马处理下一条，可以理解轮询处理。与多线程相比，这种事件处理方式是有很大的优势的，不需要创建线程，每个请求占用的内存也很少，没有上下文切换，事件处理非常的轻量级。并发数再多也不会导致无谓的资源浪费（上下文切换），更多的并发数，只是会占用更多的内存而已。因此nginx 是非常适合处理高并发请求的</p><p><strong>优点：</strong>只要设置好Worker进程个数与CPU的亲缘性绑定，那么就能减少CPU在进程间切换所花费的时间以及切换带来的进程的保存/恢复现场，同时，由于Nginx中一个worker里面只有一个线程，也避免了线程的上下文切换</p><p><strong>PS：</strong><u>worker进程数目建议设为与cpu核数相同</u>，这样每个worker进程都绑定特定的CPU核心，进程间切换的代价是最小的。因为一是Nginx一般做的是高并发代理，基本没有IO操作，大多数都是CPU密集型操作，很少出现IO阻塞等情况。二是进程与CPU调度的关系，单个核心处理多个进程的时候，是排队处理的，如果设置多个进程的时候，是排队处理的，如果设置多个进程时，会带来进程间切换的开销</p><blockquote><p>EPOLL模型，提供一种事件驱动机制，它可以监控多个事件是否准备好了，如果准备好了，那么就放入EPOLL队列中。这种机制是异步的。通过这样，WORKER进程只需要循环处理EPOLL队列中的请求，我们只需要在请求间不断切换，而这种切换是不需要付出什么代价的，通过这种循环处理已经准备好的请求，从而Nginx可以高效的处理高并发的问题</p></blockquote><h2 id="惊群现象处理"><a href="#惊群现象处理" class="headerlink" title="惊群现象处理"></a>惊群现象处理</h2><p><strong>惊群现象</strong>：在创建<code>master进</code>程时，先建立需要监听的<code>socket(listenfd)</code>，然后从<code>master进程</code>中<code>fork()</code>出多个<code>worker进程</code>，如此一来每个<code>worker进程</code>都可以监听用户请求的<code>socket</code>。一般来说，当一个连接进来后，所有在Worker都会收到通知，但是只有一个进程可以接受这个连接请求，其它的都失败</p><p><strong>Ngnix的解决</strong>：nginx提供了一个<code>accept_mutex(互斥锁)</code>，有了这把锁之后，同一时刻，就只会有一个进程在<code>accpet连接</code></p><blockquote><p>惊群效应：当你往一群鸽子中间扔一块食物，虽然最终只有一个鸽子抢到食物，但所有鸽子都会被惊动来争夺，没有抢到食物的鸽子只好回去继续睡觉， 等待下一块食物到来。这样，每扔一块食物，都会惊动所有的鸽子</p><p>惊群资料：<a href="https://blog.csdn.net/second60/article/details/81252106" target="_blank" rel="noopener">https://blog.csdn.net/second60/article/details/81252106</a></p></blockquote><h2 id="连接控制"><a href="#连接控制" class="headerlink" title="连接控制"></a>连接控制</h2><p><strong>进程之间的数量平衡控制：</strong>保证不会一个进程累死，其他进程在歇着</p><p>nginx使用一个叫<code>ngx_accept_disabled</code>的变量来控制是否去竞争<code>accept_mutex锁````ngx_accept_disabled = nginx单进程的所有连接总数 / 8 -空闲连接数量</code></p><p>当<code>ngx_accept_disabled &gt; 0</code>时，不会去尝试获取<code>accept_mutex锁</code>，<code>ngx_accept_disable</code>越大，于是让出的机会就越多，这样其它进程获取锁的机会也就越大。不去accept，每个worker进程的连接数就控制下来了，其它进程的连接池就会得到利用，这样，nginx就控制了多进程间连接的平衡</p><p><strong>一个进程的数量控制：</strong>每个worker进程都有一个独立的连接池，连接池的大小是<code>worker_connections</code></p><p>这里的连接池里面保存的其实不是真实的连接，它只是一个<code>worker_connections</code>大小的一个<code>ngx_connection_t结构的数组</code>。并且，nginx会通过一个链表<code>free_connections</code>来保存所有的空闲<code>ngx_connection_t</code>，每次获取一个连接时，就从空闲连接链表中获取一个，用完后，再放回空闲连接链表里面。</p><p>一个nginx能建立的最大连接数，应该是<code>worker_connections * worker_processes</code>。当然，这里说的是最大连接数：</p><ul><li>对于HTTP请求本地资源来说，能够支持的最大并发数量是<code>worker_connections * worker_processes</code></li><li>对于HTTP作为反向代理来说，最大并发数量应该是worker_connections * worker_processes/2。因为作为反向代理服务器，每个并发会建立与客户端的连接和与后端服务的连接，会占用两个连接</li></ul><p>参考：</p><p><a href="https://www.cnblogs.com/xiangsikai/p/8438772.html" target="_blank" rel="noopener">https://www.cnblogs.com/xiangsikai/p/8438772.html</a></p><p><a href="https://www.jianshu.com/p/c1c62e1af266" target="_blank" rel="noopener">https://www.jianshu.com/p/c1c62e1af266</a></p><p><a href="https://zhuanlan.zhihu.com/p/167949133" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/167949133</a></p>]]></content>
      
      
      <categories>
          
          <category> 服务器配置与管理 </category>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原理篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tomcat安装</title>
      <link href="/2021/05/27/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E4%B8%8E%E7%AE%A1%E7%90%86/Tomcat/Tomcat%E5%AE%89%E8%A3%85/"/>
      <url>/2021/05/27/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E4%B8%8E%E7%AE%A1%E7%90%86/Tomcat/Tomcat%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h1 id="CentOS安装"><a href="#CentOS安装" class="headerlink" title="CentOS安装"></a>CentOS安装</h1><h2 id="下载Tomcat"><a href="#下载Tomcat" class="headerlink" title="下载Tomcat"></a>下载Tomcat</h2><p>访问Tomcat下载地址：<a href="https://tomcat.apache.org/download-90.cgi" target="_blank" rel="noopener">https://tomcat.apache.org/download-90.cgi</a></p><p>按下图所示，获取下载链接；或下载后上传至服务器安装</p><p><img alt="image-20210527153622261" data-src="//orangesching.github.io/2021/05/27/服务器配置与管理/Tomcat/Tomcat安装/image-20210527153622261.png" class="lazyload"></p><h2 id="解压压缩包"><a href="#解压压缩包" class="headerlink" title="解压压缩包"></a>解压压缩包</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 解压缩</span><br><span class="line">tar -zxv -f apache-tomcat-9.0.46.tar.gz</span><br><span class="line"></span><br><span class="line"># 重命名文件夹</span><br><span class="line">mv apache-tomcat-9.0.46 tomcat</span><br><span class="line"></span><br><span class="line"># 删除压缩包</span><br><span class="line">rm apache-tomcat-9.0.46.tar.gz</span><br></pre></td></tr></table></figure><h2 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#启动tomcat</span><br><span class="line">/usr/local/soft/tomcat/bin/startup.sh</span><br></pre></td></tr></table></figure><p>访问服务器：<code>IP:8080</code>（8080为默认端口）</p><p>此处注意端口权限开通（云服务器安全组、防火墙等）</p><p><img alt="image-20210527155401964" data-src="//orangesching.github.io/2021/05/27/服务器配置与管理/Tomcat/Tomcat安装/image-20210527155401964.png" class="lazyload"></p><h2 id="设置管理员账号密码（选做）"><a href="#设置管理员账号密码（选做）" class="headerlink" title="设置管理员账号密码（选做）"></a>设置管理员账号密码（选做）</h2><p>当需要使用界面的APP管理功能时，需设置管理员账号密码。默认是没有设置的</p><p><img alt="image-20210527160330053" data-src="//orangesching.github.io/2021/05/27/服务器配置与管理/Tomcat/Tomcat安装/OrangeBlog\source\_posts\服务器配置与管理\Tomcat\Tomcat安装\image-20210527160330053.png" class="lazyload"></p><ol><li><p>打开tomcat目录下的管理用户的文件 <code>tomcat根目录/conf/tomcat-users.xml</code>，添加如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;role rolename=&quot;admin-gui&quot;/&gt;  </span><br><span class="line">&lt;role rolename=&quot;manager-gui&quot;/&gt;</span><br><span class="line">&lt;user username=&quot;tomcat&quot; password=&quot;admin&quot; roles=&quot;manager-gui,admin-gui&quot;/&gt;</span><br></pre></td></tr></table></figure></li><li><p>重启tomcat</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 关闭服务</span><br><span class="line">bin/shutdown.sh</span><br><span class="line"># 开启服务</span><br><span class="line">bin/startup.sh</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 服务器配置与管理 </category>
          
          <category> Tomcat </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境安装 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>四、Nginx配置实例</title>
      <link href="/2021/05/27/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E4%B8%8E%E7%AE%A1%E7%90%86/Nginx/%E5%9B%9B%E3%80%81Nginx%E9%85%8D%E7%BD%AE%E5%AE%9E%E4%BE%8B/"/>
      <url>/2021/05/27/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E4%B8%8E%E7%AE%A1%E7%90%86/Nginx/%E5%9B%9B%E3%80%81Nginx%E9%85%8D%E7%BD%AE%E5%AE%9E%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="实现注意点"><a href="#实现注意点" class="headerlink" title="实现注意点"></a>实现注意点</h1><ol><li><p>以下实例配置后，需检查配置文件，再重启<code>nginx服务</code>，指令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检查nginx配置文件是否正确</span></span><br><span class="line">nginx -t</span><br><span class="line"></span><br><span class="line"><span class="comment"># 平滑重启nginx服务</span></span><br><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure></li></ol><ol><li><p>当无法实现效果时，不要慌张，可打开<code>nginx</code>服务日志（路径为<code>nginx根目录/logs</code>）查看报错信息</p></li><li><p>注意配置的虚拟服务器端口是否开通访问权限（云服务器安全组、防火墙等）</p></li><li><p>以下例子nginx服务器和tomcat服务器为同一台机器，所以写地址都写了127.0.0.1，请灵活参考</p></li></ol><h1 id="简单文件服务器配置"><a href="#简单文件服务器配置" class="headerlink" title="简单文件服务器配置"></a>简单文件服务器配置</h1><h2 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h2><p>将服务器<code>/home/nginx/share/public/</code>目录下的文件通过<code>nginx</code>提供给外部访问</p><p><img alt="简单文件服务器" data-src="//orangesching.github.io/2021/05/27/服务器配置与管理/Nginx/四、Nginx配置实例/image-20210527141733833.png" class="lazyload"></p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>创建共享目录，并授权</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir /home/nginx/share/public/</span><br><span class="line">chmod <span class="number">777</span> -R /home/nginx/share/public/</span><br></pre></td></tr></table></figure><h2 id="配置nginx"><a href="#配置nginx" class="headerlink" title="配置nginx"></a>配置nginx</h2><p>打开<code>nginx.conf</code>配置<code>server</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    # 监听 8000 端口</span><br><span class="line">    listen <span class="number">8000</span>;</span><br><span class="line">    server_name localhost;</span><br><span class="line">    location / &#123;</span><br><span class="line">        # 打开自动列表功能、显示文件大小、创建时间，通常关闭</span><br><span class="line">        autoindex on;</span><br><span class="line">        autoindex_exact_size on;</span><br><span class="line">        autoindex_localtime on;</span><br><span class="line">        # 将 / 路径映射至 /home/nginx/share/public/</span><br><span class="line">        alias /home/nginx/share/public/;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意此处权限问题：</p><ol><li><p>8000端口权限：防火墙、云服务器安全组是否开启8000端口权限</p></li><li><p><code>nginx</code>进程是否有访问共享目录<code>/home/nginx/share/public/</code>的权限</p><p><code>nginx</code>进程权限取决于运行nginx用户的权限，即全局块配置的<code>user 用户名</code>配置，未配置事使用<code>nobody</code>，可配置为<code>root</code>或为<code>nginx</code>专门创建的用户（我使用了专门创建的用户，用户名为<code>nginx</code>）</p></li></ol></blockquote><h1 id="Nginx正向代理"><a href="#Nginx正向代理" class="headerlink" title="Nginx正向代理"></a>Nginx正向代理</h1><h2 id="准备工作-1"><a href="#准备工作-1" class="headerlink" title="准备工作"></a>准备工作</h2><p>在http客户端配置代理服务器为Nginx服务器地址</p><p>linux</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">export http_proxy=Nginx服务器地址</span><br><span class="line">export https_proxy=Nginx服务器地址</span><br><span class="line"></span><br><span class="line"># 取消该设置</span><br><span class="line">unset http_proxy</span><br><span class="line">unset https_proxy</span><br></pre></td></tr></table></figure><p>windows</p><p>浏览器配置HTTP代理</p><h2 id="配置nginx-1"><a href="#配置nginx-1" class="headerlink" title="配置nginx"></a>配置nginx</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    # DNS解析服务器IP地址，外网写8.8.8.8</span><br><span class="line">    resolver 114.114.114.114;</span><br><span class="line">    resolver_timeout 5s;</span><br><span class="line">    listen 0.0.0.0:8080</span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://$http_host$request_uri;</span><br><span class="line">        proxy_set_header Host $http_host;</span><br><span class="line">        proxy_buffers 256 4k;</span><br><span class="line">        proxy_max_temp_file_size 0;</span><br><span class="line">        proxy_connect_timeout 30;</span><br><span class="line">        proxy_cache_valid 200 302 10m;</span><br><span class="line">        proxy_cache_valid 301 1h;</span><br><span class="line">        proxy_cache_valid any 1m;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="Nginx反向代理"><a href="#Nginx反向代理" class="headerlink" title="Nginx反向代理"></a>Nginx反向代理</h1><h2 id="根据访问端口跳转"><a href="#根据访问端口跳转" class="headerlink" title="根据访问端口跳转"></a>根据访问端口跳转</h2><h3 id="实现效果-1"><a href="#实现效果-1" class="headerlink" title="实现效果"></a>实现效果</h3><p>使用 nginx 反向代理，根据访问的端口跳转到服务器的<code>tomcat</code>主页面中（Nginx默认安装完跳转到了Nginx Html文件）</p><p>效果如下：其实访问的是47.98.151.160:80，默认安装时以这个地址访问将展示Nginx欢迎页面，现展示为Tomcat欢迎页面</p><p><img alt="image-20210527161613812" data-src="//orangesching.github.io/2021/05/27/服务器配置与管理/Nginx/四、Nginx配置实例/image-20210527161613812.png" class="lazyload"></p><h3 id="准备工作-2"><a href="#准备工作-2" class="headerlink" title="准备工作"></a>准备工作</h3><p>准备一个tomcat，可通过8080访问</p><p><img alt="image-20210527160735454" data-src="//orangesching.github.io/2021/05/27/服务器配置与管理/Nginx/四、Nginx配置实例/image-20210527160735454.png" class="lazyload"></p><h3 id="配置nginx-2"><a href="#配置nginx-2" class="headerlink" title="配置nginx"></a>配置nginx</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name localhost;</span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://127.0.0.1:8080;</span><br><span class="line">        index index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="根据访问路径跳转"><a href="#根据访问路径跳转" class="headerlink" title="根据访问路径跳转"></a>根据访问路径跳转</h2><h3 id="实现效果-2"><a href="#实现效果-2" class="headerlink" title="实现效果"></a>实现效果</h3><p>使用 nginx 反向代理，根据访问的路径跳转到不同端口的服务中。nginx 监听端口为<code>80</code>，<br>访问 <a href="http://47.98.151.160/server1" target="_blank" rel="noopener">http://47.98.151.160/server1</a> 直接跳转到 47.98.151.160:8081<br>访问 <a href="http://47.98.151.160/server2" target="_blank" rel="noopener">http://47.98.151.160/server2</a> 直接跳转到 47.98.151.160:8082</p><p>效果图如下：</p><p><img alt="image-20210527170030898" data-src="//orangesching.github.io/2021/05/27/服务器配置与管理/Nginx/四、Nginx配置实例/image-20210527170030898.png" class="lazyload"></p><p><img alt="image-20210527170103169" data-src="//orangesching.github.io/2021/05/27/服务器配置与管理/Nginx/四、Nginx配置实例/image-20210527170103169.png" class="lazyload"></p><h3 id="准备工作-3"><a href="#准备工作-3" class="headerlink" title="准备工作"></a>准备工作</h3><ol><li><p><strong>准备两个 tomcat，一个 8081 端口，一个 8082 端口</strong></p><p>(1) 将tomcat压缩包解压两份，一个重命名为<code>tomcat8081</code>一个重命名为<code>tomcat8082</code></p><p>(2) 编辑两台服务器的端口号，修改<code>/conf/server.xml</code>文件</p><p>​     <code>tomcat8081</code>：修改<code>http协议(8080-&gt;8081)</code>默认端口</p><p>​     <code>tomcat8082</code>：修改<code>server(8005-&gt;8091)</code>、<code>http协议(8080-&gt;8082)</code> 、<code>ajp协议(8009-&gt;9001)</code>的默认端口</p><p>​      <img alt="image-20210527163826676" data-src="//orangesching.github.io/2021/05/27/服务器配置与管理/Nginx/四、Nginx配置实例/image-20210527163826676.png" class="lazyload"></p><p>​      <img alt="image-20210527163935213" data-src="//orangesching.github.io/2021/05/27/服务器配置与管理/Nginx/四、Nginx配置实例/image-20210527163935213.png" class="lazyload"></p><p>​      <img alt="image-20210527164245419" data-src="//orangesching.github.io/2021/05/27/服务器配置与管理/Nginx/四、Nginx配置实例/image-20210527164245419.png" class="lazyload"></p><p>(3) 启动两个tomcat，执行<code>/bin/startup.sh</code></p><p>(4) 访问两个tomcat</p><p><img alt="image-20210527164723455" data-src="//orangesching.github.io/2021/05/27/服务器配置与管理/Nginx/四、Nginx配置实例/image-20210527164723455.png" class="lazyload"></p><p><img alt="image-20210527164802421" data-src="//orangesching.github.io/2021/05/27/服务器配置与管理/Nginx/四、Nginx配置实例/image-20210527164802421.png" class="lazyload"></p></li><li><p><strong>准备两个不同的测试的页面以区分访问的Tomcat服务器</strong><br>写一个<code>hello.html</code>页面<br>放到<code>tomcat8081</code>的目录<code>/webapps/server1</code> 下，内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1&gt;hello,tomcat-8081&lt;/h1&gt;</span><br></pre></td></tr></table></figure><p>放到<code>tomcat8082</code>的目录<code>/webapps/server2</code> 下，内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1&gt;hello,tomcat-8082&lt;/h1&gt;</span><br></pre></td></tr></table></figure><p>访问测试下</p><p><img alt="image-20210527165233240" data-src="//orangesching.github.io/2021/05/27/服务器配置与管理/Nginx/四、Nginx配置实例/image-20210527165233240.png" class="lazyload"></p><p><img alt="image-20210527165255949" data-src="//orangesching.github.io/2021/05/27/服务器配置与管理/Nginx/四、Nginx配置实例/image-20210527165255949.png" class="lazyload"></p></li></ol><h3 id="配置nginx-3"><a href="#配置nginx-3" class="headerlink" title="配置nginx"></a>配置nginx</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name localhost;</span><br><span class="line">    </span><br><span class="line">    location ~ /server1/ &#123;</span><br><span class="line">        proxy_pass http://127.0.0.1:8081;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    location ~ /server2/ &#123;</span><br><span class="line">        proxy_pass http://127.0.0.1:8082;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Nginx-动静分离"><a href="#Nginx-动静分离" class="headerlink" title="Nginx 动静分离"></a>Nginx 动静分离</h1><h2 id="什么是动静分离"><a href="#什么是动静分离" class="headerlink" title="什么是动静分离"></a>什么是动静分离</h2><p>Nginx 动静分离简单来说就是把动态跟静态请求分开，不能理解成只是单纯的把动态页面和静态页面物理分离。严格意义上说应该是 动态请求 跟 静态请求 分开，可以理解成使用 Nginx 处理静态页面，Tomcat 处理动态页面</p><p><img alt="img" data-src="//orangesching.github.io/2021/05/27/服务器配置与管理/Nginx/四、Nginx配置实例/1710915-20190906165935954-1700365552.jpg" class="lazyload"></p><p>动静分离从目前实现角度来讲大致分为两种：</p><ul><li><p>一种是纯粹把静态文件独立成单独的域名，放在独立的服务器上，可使用CDN技术，也是目前主流推崇的方案</p></li><li><p>一种方法就是动态跟静态文件混合在一起发布，通过 nginx 来分开</p></li></ul><p>通过 location 指定不同的后缀名实现不同的请求转发。通过 expires 参数设置，可以使浏览器缓存过期时间，减少与服务器之前的请求和流量</p><h2 id="实现效果-3"><a href="#实现效果-3" class="headerlink" title="实现效果"></a>实现效果</h2><p>就是简单文件服务器+反向代理</p><p>访问 <a href="http://47.98.151.160/www/hello.html" target="_blank" rel="noopener">http://47.98.151.160/www/hello.html</a> 走Tomcat服务器</p><p>访问 <a href="http://47.98.151.160/image/" target="_blank" rel="noopener">http://47.98.151.160/image/</a> 走跳转到静态文件列表</p><h2 id="配置nginx-4"><a href="#配置nginx-4" class="headerlink" title="配置nginx"></a>配置nginx</h2><p>见简单文件服务器配置+Nginx反向代理-根据访问路径跳转的配置</p><h1 id="Nginx负载均衡"><a href="#Nginx负载均衡" class="headerlink" title="Nginx负载均衡"></a>Nginx负载均衡</h1><h2 id="实现效果-4"><a href="#实现效果-4" class="headerlink" title="实现效果"></a>实现效果</h2><p>浏览器地址栏输入地址 <a href="http://47.98.151.160/home/hello.html，负载均衡效果，平均" target="_blank" rel="noopener">http://47.98.151.160/home/hello.html，负载均衡效果，平均</a> 8081 和 8082 两台tomcat中</p><p><img alt="GIF 2021-5-27 17-27-03" data-src="//orangesching.github.io/2021/05/27/服务器配置与管理/Nginx/四、Nginx配置实例/GIF 2021-5-27 17-27-03.gif" class="lazyload"></p><h2 id="准备工作-4"><a href="#准备工作-4" class="headerlink" title="准备工作"></a>准备工作</h2><ol><li><p><strong>准备两台Tomcat服务器</strong>，同 Nginx反向代理-根据访问路径跳转-准备工作 配置两台服务器</p></li><li><p><strong>准备两个不同的测试的页面以区分访问的Tomcat服务器</strong></p><p>写一个<code>hello.html</code>页面<br>放到<code>tomcat8081</code>的目录 <code>/webapps/home</code> 下，内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1&gt;hello,tomcat-8081&lt;/h1&gt;</span><br></pre></td></tr></table></figure><p>放到<code>tomcat8082</code>的目录 <code>/webapps/home</code> 下，内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1&gt;hello,tomcat-8082&lt;/h1&gt;</span><br></pre></td></tr></table></figure></li></ol><h2 id="配置nginx-5"><a href="#配置nginx-5" class="headerlink" title="配置nginx"></a>配置nginx</h2><p>配置项：</p><ol><li>负载均衡服务器集合：<code>upstram</code></li><li>负载均衡策略：这里没有配置均衡策略，即使用的是默认负载均衡策略：轮询。nginx还支持其他策略</li><li>走负载均衡的请求：<code>location</code></li></ol><pre><code>upstream myserver {    server 47.98.151.160:8081;    server 47.98.151.160:8082;}server {    listen       80;    server_name  47.98.151.160;    location / {        proxy_pass   http://myserver;}</code></pre><h3 id="负载均衡策略"><a href="#负载均衡策略" class="headerlink" title="负载均衡策略"></a>负载均衡策略</h3><p>负载均衡即是将负载分摊到不同的服务单元，可降低单个服务器的负载压力</p><p>负载均衡策略即按某一策略将请求分发到具体服务器</p><h4 id="轮询（默认）"><a href="#轮询（默认）" class="headerlink" title="轮询（默认）"></a>轮询（默认）</h4><p>每个请求按时间顺序逐一分配到不同的服务器，如果后端服务器挂掉，能自动剔除</p><h4 id="加权轮询"><a href="#加权轮询" class="headerlink" title="加权轮询"></a>加权轮询</h4><p>weight 代表权重, 默认为 1,权重越高被分配的客户端越多</p><pre><code>upstream myserver {    server 47.98.151.160:8081 weight=10;     server 47.98.151.160:8082 weight=10;}</code></pre><h4 id="ip-hash"><a href="#ip-hash" class="headerlink" title="ip_hash"></a>ip_hash</h4><p>ip_hash 每个请求按访问 ip 的 hash 结果分配，这样每个访客固定访问一个后端服务器</p><pre><code>upstream myserver {    ip_hash;                    server 47.98.151.160:8081;       server 47.98.151.160:8081;}</code></pre><h4 id="fair（第三方）"><a href="#fair（第三方）" class="headerlink" title="fair（第三方）"></a>fair（第三方）</h4><p>fair（第三方），按后端服务器的响应时间来分配请求，响应时间短的优先分配。</p><pre><code>upstream myserver {        fair;                                             server 47.98.151.160:8081;       server 47.98.151.160:8081;    }</code></pre><h1 id="Nginx缓存-未完成"><a href="#Nginx缓存-未完成" class="headerlink" title="Nginx缓存(未完成)"></a>Nginx缓存(未完成)</h1><h2 id="实现效果-5"><a href="#实现效果-5" class="headerlink" title="实现效果"></a>实现效果</h2><h2 id="准备工作-5"><a href="#准备工作-5" class="headerlink" title="准备工作"></a>准备工作</h2><p>创建共享目录，并授权，放一个图片进去</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir /home/nginx/share/public/image</span><br><span class="line">chmod <span class="number">777</span> -R /home/nginx/share/public/</span><br></pre></td></tr></table></figure><h2 id="配置nginx-6"><a href="#配置nginx-6" class="headerlink" title="配置nginx"></a>配置nginx</h2><p>缓存涉及以下配置：</p><ol><li><p>缓存文件放在哪儿？</p><p><code>proxy_cache_path</code>：指定缓存位置、缓存名称、内存中缓存内容元数据信息大小限制、缓存总大小限制。缓存位置是一个目录应该先创建好，nginx并不会帮我们创建这个缓存目录</p><p><code>proxy_cache</code>：指定使用前面设置的缓存名称</p></li><li><p>如何指定哪些请求被缓存？<br><code>proxy_cache_key</code>：自定义缓存key，Nginx默认会缓存所有get和head方法的请求结果，缓存的key默认使用请求字符串</p><p><code>proxy_cache_min_uses</code>：指定请求至少被发送了多少次以上时才缓存，可以防止低频请求被缓存</p><p><code>proxy_cache_methods</code>：指定缓存的请求方式如：GET、POST</p></li><li><p>缓存的有效期是多久？</p><p>默认情况下，缓存的内容是长期存留的，除非缓存的总量超出限制。可以指定缓存的有效期</p><p><code>proxy_cache_valid</code>：指定有效期，例如：</p><p>​               <code>proxy_cache_valid 200 302 10m;</code>响应状态码为200 302时，10分钟有效<br>​               <code>proxy_cache_valid any 5m;</code>对应任何状态码，5分钟有效 </p></li><li><p>如何指定哪些请求不被缓存？</p><p><code>proxy_cache_bypass</code>：指定请求响应来自原始服务器而不是缓存</p></li></ol><blockquote><p><strong>网页缓存</strong>由HTTP消息头中的<code>Cache-control</code>来控制的<br>常见的取值有private、no-cache、max-age、must-revalidate等，默认为private。</p><p>其作用根据不同的重新浏览方式分为以下几种情况</p><div class="table-container"><table><thead><tr><th>Cache-directive</th><th>说明</th></tr></thead><tbody><tr><td>public</td><td>所有内容都将被缓存（客户端和代理服务器都可缓存）</td></tr><tr><td>private</td><td>内容只缓存到私有缓存中（仅客户端可以缓存，代理服务器不可缓存）</td></tr><tr><td>no-cache</td><td>必须先与服务器确认返回的响应是否被更改，然后才能使用该响应来满足后续对同一个网址的请求。<br>no-cache会发起往返通信来验证缓存的响应，如果资源未被更改，可以避免下载</td></tr><tr><td>no-store</td><td>所有内容都不会被缓存到缓存或Internet临时文件中</td></tr><tr><td>must-revalidationproxy-revalidation</td><td>如果缓存内容失败，请求必须发送到服务器、代理以进行重新验证</td></tr><tr><td>max-age=xxx</td><td>缓存的内容将在xxx秒失效，这个选项只在HTTP 1.1可用，并如果和<code>Last-Modified</code>一起使用时，优先级较高</td></tr></tbody></table></div></blockquote><p>配置示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    proxy_cache_path /home/nginx/cache  keys_zone=one:10m  max_size=10g;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        proxy_cache  one;</span><br><span class="line">        server_name  aidan.org;</span><br><span class="line">        location / &#123;</span><br><span class="line">            proxy_pass  http://aidan.org;</span><br><span class="line">            expires 10m;</span><br><span class="line">            proxy_cache_valid any 5m;</span><br><span class="line">            add_header Cache-Control &quot;public&quot;;</span><br><span class="line">            add_header X-proxy-Cache $upstream_cache_status;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Nginx集群-未完成"><a href="#Nginx集群-未完成" class="headerlink" title="Nginx集群(未完成)"></a>Nginx集群(未完成)</h1><p>参考：</p><p><a href="https://blog.csdn.net/qq_40036754/article/details/102463099?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162199566116780265480863%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=162199566116780265480863&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-102463099.pc_search_result_no_baidu_js&amp;utm_term=nginx&amp;spm=1018.2226.3001.4187" target="_blank" rel="noopener">https://blog.csdn.net/qq_40036754/article/details/102463099?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162199566116780265480863%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=162199566116780265480863&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-102463099.pc_search_result_no_baidu_js&amp;utm_term=nginx&amp;spm=1018.2226.3001.4187</a></p><p><a href="https://blog.csdn.net/h13140995776/article/details/101174283?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-2.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-2.control" target="_blank" rel="noopener">https://blog.csdn.net/h13140995776/article/details/101174283?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-2.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-2.control</a></p>]]></content>
      
      
      <categories>
          
          <category> 服务器配置与管理 </category>
          
          <category> Nginx </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>三、Nginx配置文件剖析</title>
      <link href="/2021/05/26/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E4%B8%8E%E7%AE%A1%E7%90%86/Nginx/%E4%B8%89%E3%80%81Nginx%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%89%96%E6%9E%90/"/>
      <url>/2021/05/26/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E4%B8%8E%E7%AE%A1%E7%90%86/Nginx/%E4%B8%89%E3%80%81Nginx%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%89%96%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="Nginx配置文件结构"><a href="#Nginx配置文件结构" class="headerlink" title="Nginx配置文件结构"></a>Nginx配置文件结构</h1><p><strong>nginx 文件结构</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">...              #全局块</span><br><span class="line"></span><br><span class="line">events &#123;         #events块</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http      #http块</span><br><span class="line">&#123;</span><br><span class="line">    ...   #http全局块</span><br><span class="line">    server        #server块</span><br><span class="line">    &#123; </span><br><span class="line">        ...       #server全局块</span><br><span class="line">        location [PATTERN]   #location块</span><br><span class="line">        &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        location [PATTERN] </span><br><span class="line">        &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    server</span><br><span class="line">    &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...     #http全局块</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>全局块</strong>：配置影响nginx全局的指令。一般有运行nginx服务器的用户组，nginx进程pid存放路径，日志存放路径，配置文件引入，允许生成worker process数等</li><li><strong>events块</strong>：配置影响nginx服务器或与用户的网络连接。有每个进程的最大连接数，选取哪种事件驱动模型处理连接请求，是否允许同时接受多个网路连接，开启多个网络连接序列化等</li><li><strong>http块</strong>：可以嵌套多个server，配置代理，缓存，日志定义等绝大多数功能和第三方模块的配置。如文件引入，mime-type定义，日志自定义，是否使用sendfile传输文件，连接超时时间，单连接请求数等</li><li><strong>server块</strong>：配置虚拟主机的相关参数，一个http中可以有多个server</li><li><strong>location块</strong>：配置请求的路由，以及各种页面的处理情况</li></ul><h1 id="全局块"><a href="#全局块" class="headerlink" title="全局块"></a>全局块</h1><p>从配置文件开始到 events 块之间的内容，主要会设置一些影响nginx 服务器整体运行的配置指令</p><p>主要包括配 置运行 Nginx 服务器的用户（组）、允许生成的 worker process 数，进程 PID 存放路径、日志存放路径和类型以 及配置文件的引入等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 配置运行 nginx 服务器用户</span><br><span class="line">user nobody nobody;</span><br><span class="line"></span><br><span class="line"># 配置允许生成的 worker process 数</span><br><span class="line">worker_processes auto;</span><br><span class="line">worker_processes 4;</span><br><span class="line"># 这个数字跟电脑 CPU 核数要保持一致这个指令能查看CPU核数：grep ^proces /proc/cpuinfo | wc -l</span><br><span class="line"></span><br><span class="line"># 配置 nginx 进程 PID 存放路径</span><br><span class="line">pid logs/nginx.pid;</span><br><span class="line"># 这个文件保存的就是一个数字，nginx master 进程的进程号</span><br><span class="line"></span><br><span class="line"># 配置错误日志的存放路径</span><br><span class="line">error_log logs/error.log;</span><br><span class="line">error_log logs/error.log error;</span><br><span class="line"></span><br><span class="line"># 配置文件的引入</span><br><span class="line">include mime.types; include fastcgi_params; include ../../conf/*.conf;</span><br></pre></td></tr></table></figure><h1 id="Event块"><a href="#Event块" class="headerlink" title="Event块"></a>Event块</h1><p>Event块涉及的指令主要影响 Nginx 服务器与用户的网络连接</p><p>常用的设置包括：</p><ul><li>是否开启对多 work process 下的网络连接进行序列化</li><li>是否 允许同时接收多个网络连接</li><li>选取哪种事件驱动模型来处理连接请求</li><li>每个 word process 可以同时支持的最大连接数等</li></ul><p>这部分的配置对 Nginx 的性能影响较大，在实际中应该灵活配置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 设置网络连接的序列化</span><br><span class="line">accept_mutex on;</span><br><span class="line"># 对多个 nginx 进程接收连接进行序列化，防止多个进程对连接的争抢（惊群现象）</span><br><span class="line"></span><br><span class="line"># 设置是否允许同时接收多个网络连接</span><br><span class="line">multi_accept off;</span><br><span class="line"></span><br><span class="line"># 事件驱动模型的选择</span><br><span class="line">use select|poll|kqueue|epoll|rtsig|/dev/poll|eventport</span><br><span class="line"></span><br><span class="line"># 配置最大连接数</span><br><span class="line">worker_connections 512;</span><br></pre></td></tr></table></figure><blockquote><p>惊群现象：一个网路连接到来，多个睡眠的进程被同时叫醒，但只有一个进程能获得链接，这样会影响系统性能</p></blockquote><h1 id="HTTP块"><a href="#HTTP块" class="headerlink" title="HTTP块"></a>HTTP块</h1><p><code>Nginx</code> 服务器配置中最频繁的部分，<u>代理、缓存和日志</u>定义等绝大多数功能和<u>第三方模块</u>的配置都在这里。<code>http</code>块包括 <code>http全局块</code>、<code>server块</code></p><h2 id="HTTP全局块"><a href="#HTTP全局块" class="headerlink" title="HTTP全局块"></a>HTTP全局块</h2><p>http全局块配置的指令包括文件引入、MIME-TYPE 定义、日志自定义、连接超时时间、单链接请求数上限等</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 定义 MIME-Type</span><br><span class="line">include mime.types; default_type application/octet-stream;</span><br><span class="line"></span><br><span class="line"># 自定义服务日志</span><br><span class="line">access_log logs/access.log main; </span><br><span class="line">access_log off;</span><br><span class="line"></span><br><span class="line"># 配置允许 sendfile 方式传输文件</span><br><span class="line">sendfile off;</span><br><span class="line">sendfile on; </span><br><span class="line">sendfile_max_chunk 128k;</span><br><span class="line"># nginx 每个 worker process 每次调用 sendfile() 传输的数据量的最大值</span><br><span class="line"></span><br><span class="line"># 配置连接超时时间</span><br><span class="line">keepalive_timeout 75s 65s;</span><br><span class="line"># 与用户建立连接后，nginx 可以保持这些连接一段时间，默认 75s 下面的 65s 可以被Mozilla/Konqueror 识别，是发给用户端的头部信息Keep-Alive值</span><br><span class="line"></span><br><span class="line"># 单连接请求数上限</span><br><span class="line">keepalive_requests 100</span><br><span class="line"># 和用户端建立连接后，用户通过此连接发送请求；这条指令用于设置请求的上限数</span><br></pre></td></tr></table></figure><h2 id="Server块（多个）"><a href="#Server块（多个）" class="headerlink" title="Server块（多个）"></a>Server块（多个）</h2><p>这块和虚拟主机有密切关系<br>每个<code>http 块</code>可以包括多个<code>server 块</code>，而每个 <code>server 块</code>就相当于一个虚拟主机。<br>而每个<code>server 块</code>也分为全局 <code>server 块</code>，以及可以同时包含多个 <code>locaton 块</code></p><p>当客户端向 Nginx 服务器发送请求时，Nginx首先会根据 <strong>IP地址和端口（listen 属性）</strong> 对server服务器进行配置；如果IP地址匹配不成功，会对 <strong>域名（server_name属性）</strong> 进行匹配；如果域名也匹配不成功，则会<strong>默认匹配第一个server服务器</strong></p><blockquote><p><strong>虚拟主机</strong>（英语：virtual hosting）或称 <strong>共享主机</strong>（shared web hosting），又称<strong>虚拟服务器</strong>，是一种在单一主机或主机群上，实现多网域服务的方法，可以运行多个<a href="https://baike.baidu.com/item/网站" target="_blank" rel="noopener">网站</a>或服务的技术。虚拟主机之间完全独立，并可由用户自行管理，虚拟并非指不存在，而是指空间是由实体的服务器延伸而来，其<a href="https://baike.baidu.com/item/硬件" target="_blank" rel="noopener">硬件</a>系统可以是基于服务器群，或者单个服务器。</p><p>虚拟主机从用户角度看，和一台独立的硬件主机是完全一样的，该技术的产生是为了 节省互联网服务器硬件成本</p></blockquote><h3 id="Server全局块"><a href="#Server全局块" class="headerlink" title="Server全局块"></a>Server全局块</h3><p>最常见的配置是本虚拟机主机的监听配置和本虚拟主机的名称或IP配置</p><h4 id="基于IP地址和端口的虚拟主机配置"><a href="#基于IP地址和端口的虚拟主机配置" class="headerlink" title="基于IP地址和端口的虚拟主机配置"></a>基于IP地址和端口的虚拟主机配置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">listen *:80 | *:8000; # 监听所有的 80 和 8000 端口</span><br><span class="line"></span><br><span class="line">listen 192.168.1.10:8000; </span><br><span class="line">listen 192.168.1.10; </span><br><span class="line">listen 8000; </span><br><span class="line"># 等同于 listen *:8000; </span><br><span class="line">listen 192.168.1.10 default_server backlog=511; </span><br><span class="line"># 该 ip 的连接请求默认由此虚拟主机处理；最多允许 1024 个网络连接同时处于挂起状态</span><br></pre></td></tr></table></figure><h4 id="基于名称的虚拟主机配置"><a href="#基于名称的虚拟主机配置" class="headerlink" title="基于名称的虚拟主机配置"></a>基于名称的虚拟主机配置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">server_name myserver.com www.myserver.com;</span><br><span class="line"></span><br><span class="line">server_name *.myserver.com www.myserver.* myserver2.*; # 使用通配符</span><br><span class="line"></span><br><span class="line"># 不允许的情况：server_name www.ab*d.com; *只允许出现在 www 和 com 的位置</span><br><span class="line"></span><br><span class="line">server_name ~^www\d+.myserver.com$; # 使用正则</span><br><span class="line"></span><br><span class="line"># nginx 的配置中，可以用正则的地方，都以`~`开头</span><br><span class="line"></span><br><span class="line"># 从nginx~0.7.40 开始，server_name 中的正则支持 字符串捕获功能（capture）</span><br><span class="line"></span><br><span class="line">server_name ~^www.(.+).com$; </span><br><span class="line"># 当请求通过 www.myserver.com 请求时， myserver 就被记录到`$1`中，在本 server 的上下文中就可以使用</span><br></pre></td></tr></table></figure><p>如果一个名称 被多个虚拟主机的 server_name 匹配成功，则按以下优先级匹配：</p><ol><li>准确匹配到 server_name</li><li>通配符在开始时匹配到 server_name</li><li>通配符在结尾时匹配到 server_name</li><li>正则表达式匹配 server_name</li><li>先到先得</li></ol><h3 id="Location块（多个）"><a href="#Location块（多个）" class="headerlink" title="Location块（多个）"></a>Location块（多个）</h3><p><code>Location块</code>的主要作用是基于 Nginx 服务器接收到的请求字符串（例如 <code>server_name/uri-string</code>），对虚拟主机名称 （也可以是IP 别名）之外的字符串（例如 前面的<code>/uri-string</code>）进行匹配，对特定的请求进行处理。即<u>匹配URL</u>， <u>地址定向、数据缓 存和应答控制</u>等功能，还有许多<u>第三方模块</u>的配置也在这里进行</p><p><strong>Location配置语法规则：<code>location</code> <code>[匹配方式]</code> <code>url</code> <code>{命令序列}</code></strong></p><p>这里内容分 2 块，匹配方式和 <code>url</code> ， 其中 <code>url</code> 又分为 标准 <code>url</code>(如：127.0.0.1/home) 和正则 <code>url</code> </p><h4 id="匹配方式"><a href="#匹配方式" class="headerlink" title="匹配方式"></a>匹配方式</h4><p><strong>所有匹配方式：</strong></p><ul><li>不带匹配方式：必须以指定模式开始</li><li><code>=</code>:  用于<code>标准 uri</code>前，必须与指定的模式精确匹配，成功则立即处理，精确匹配，不在子路径生效，优先级最高</li><li><code>^~</code>: 用于<code>标准 uri</code>前，类似于不带匹配方式的行为，也是以指定模式开始，不同的是，如果模式匹配，<br>那么就停止搜索其他模式了</li><li><code>~</code>:  用于<code>正则 uri</code>前，url包含的正则表达式要区分大小写</li><li><code>~*</code>: 用于<code>正则 uri</code>前， url包含的正则表达式不区分大小写</li></ul><p><strong>匹配顺序：</strong></p><p>1：带有<code>=</code>的精确匹配优先<br>2：没有修饰符的精确匹配<br>3：正则表达式按照他们在配置文件中定义的顺序<br>4：带有<code>^~</code>修饰符的，开头匹配<br>5：带有<code>~</code> 或<code>~*</code> 修饰符的，如果正则表达式与URI匹配<br>6：没有修饰符的，如果指定字符串与URI开头匹配</p><h4 id="命令序列"><a href="#命令序列" class="headerlink" title="命令序列"></a>命令序列</h4><h5 id="alias"><a href="#alias" class="headerlink" title="alias"></a>alias</h5><p>别名配置，用于访问文件系统，在匹配到location配置的URL路径后，指向【alias】配置的路径。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">location /test/ </span><br><span class="line">&#123; </span><br><span class="line">alias /home/orange/img/; </span><br><span class="line">&#125;</span><br><span class="line"># 请求/test/1.jpg（省略了协议与域名），将会返回文件/home/orange/img/1.jpg</span><br></pre></td></tr></table></figure><h5 id="root"><a href="#root" class="headerlink" title="root"></a>root</h5><p>根路径配置，用于访问文件系统，在匹配到location配置的URL路径后，指向【root】配置的路径，并把location配置路径附加到其后。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">location /test/</span><br><span class="line">&#123; </span><br><span class="line">root /home/orange/img/; </span><br><span class="line">&#125;</span><br><span class="line"># 请求/test/1.jpg，将会返回文件/home/orange/img/test/1.jpg</span><br><span class="line"># 相较于alias，使用root会把/test/附加到根目录之后。</span><br></pre></td></tr></table></figure><blockquote><p>root和alias的区别：</p><p>root是追加URL<br>alias是改变URL</p><p>具体可见例子</p></blockquote><h5 id="proxy-pass"><a href="#proxy-pass" class="headerlink" title="proxy_pass"></a>proxy_pass</h5><p>反向代理配置，<u>用于代理请求，适用于前后端负载分离或多台机器、服务器负载分离的场景</u></p><p>在匹配到location配置的URL路径后，转发请求到【proxy_pass】配置的URL</p><p>是否会附加location配置路径与【proxy_pass】配置的路径后是否有<code>/</code>有关，<u>有<code>/</code>则不附加</u>，如配置为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 配法1：带/</span><br><span class="line">location /test/ </span><br><span class="line">&#123; </span><br><span class="line">proxy_pass http://127.0.0.1:8080/; </span><br><span class="line">&#125;</span><br><span class="line"># 请求/test/1.jpg将会被转发到http://127.0.0.1:8080/1.jpg</span><br><span class="line"></span><br><span class="line"># 配法2：不带/</span><br><span class="line">location /test/ </span><br><span class="line">&#123; </span><br><span class="line">proxy_pass http://127.0.0.1:8080; </span><br><span class="line">&#125;</span><br><span class="line"># 请求/test/1.jpg将会被转发到http://127.0.0.1:8080/test/1.jpg</span><br></pre></td></tr></table></figure><p>参考：</p><p><a href="https://blog.csdn.net/qq_40036754/article/details/102463099?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162199566116780265480863%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=162199566116780265480863&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-102463099.pc_search_result_no_baidu_js&amp;utm_term=nginx&amp;spm=1018.2226.3001.4187" target="_blank" rel="noopener">https://blog.csdn.net/qq_40036754/article/details/102463099?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162199566116780265480863%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=162199566116780265480863&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-102463099.pc_search_result_no_baidu_js&amp;utm_term=nginx&amp;spm=1018.2226.3001.4187</a></p><p><a href="https://blog.csdn.net/wangjun5159/article/details/109339922" target="_blank" rel="noopener">https://blog.csdn.net/wangjun5159/article/details/109339922</a></p>]]></content>
      
      
      <categories>
          
          <category> 服务器配置与管理 </category>
          
          <category> Nginx </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>二、Nginx安装卸载</title>
      <link href="/2021/05/25/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E4%B8%8E%E7%AE%A1%E7%90%86/Nginx/%E4%BA%8C%E3%80%81Nginx%E5%AE%89%E8%A3%85%E5%8D%B8%E8%BD%BD/"/>
      <url>/2021/05/25/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E4%B8%8E%E7%AE%A1%E7%90%86/Nginx/%E4%BA%8C%E3%80%81Nginx%E5%AE%89%E8%A3%85%E5%8D%B8%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="安装准备"><a href="#安装准备" class="headerlink" title="安装准备"></a>安装准备</h2><p>安装编译工具及库文件（安装过可跳过这一步）</p><ul><li><strong>make / gcc-c++</strong>： 编译使用</li><li><strong>zlib / zlib-devel</strong>： nginx中gzip使用</li><li><strong>openssl / openssl-devel</strong>： openssl是web安全通信的基石，nginx支持 https使用（即在ssl协议上传输http）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install make zlib zlib-devel gcc-c++ openssl openssl-devel libtool</span><br></pre></td></tr></table></figure><h2 id="安装-PCRE"><a href="#安装-PCRE" class="headerlink" title="安装 PCRE"></a>安装 PCRE</h2><p>PCRE 作用是让 Nginx 支持 Rewrite 功能</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y pcre pcre-devel</span><br></pre></td></tr></table></figure><h2 id="安装-Nginx"><a href="#安装-Nginx" class="headerlink" title="安装 Nginx"></a>安装 Nginx</h2><h3 id="下载-Nginx"><a href="#下载-Nginx" class="headerlink" title="下载 Nginx"></a>下载 Nginx</h3><p>在<a href="http://nginx.org/里找个最新稳定版下载" target="_blank" rel="noopener">http://nginx.org/里找个最新稳定版下载</a></p><p><img alt="image-20210524160109114" data-src="//orangesching.github.io/2021/05/25/服务器配置与管理/Nginx/二、Nginx安装卸载/image-20210524160109114.png" class="lazyload"></p><p>例如1.20版本的下载地址为： <a href="http://nginx.org/download/nginx-1.20.0.tar.gz" target="_blank" rel="noopener">http://nginx.org/download/nginx-1.20.0.tar.gz</a></p><p>创建nginx目录，使用wget下载源码包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://nginx.org/download/nginx-1.20.0.tar.gz</span><br></pre></td></tr></table></figure><h3 id="解压安装包"><a href="#解压安装包" class="headerlink" title="解压安装包"></a>解压安装包</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf nginx-1.20.0.tar.gz</span><br></pre></td></tr></table></figure><h3 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h3><p>使用./configure设置安装细节：</p><ul><li>指定编译安装目录： <code>--prefix=你的安装路径</code></li><li>监控模块： <code>--with-http_stub_status_module</code></li><li>SSL模块： <code>--with-http_ssl_module</code>模块</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cd nginx-1.18.0</span><br><span class="line"></span><br><span class="line"># 安装设置</span><br><span class="line">./configure --prefix=/usr/local/soft/nginx --with-http_stub_status_module --with-http_ssl_module </span><br><span class="line"></span><br><span class="line"># 编译</span><br><span class="line">make </span><br><span class="line"></span><br><span class="line"># 安装</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><h2 id="安全配置开启"><a href="#安全配置开启" class="headerlink" title="安全配置开启"></a>安全配置开启</h2><p>在服务端使用wget和curl测试下返回的是否正常，若正常，则可跳过</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget 127.0.0.1</span><br><span class="line">curl 127.0.0.1 # 云服务器可尝试用IP</span><br></pre></td></tr></table></figure><p>通过127.0.0.1访问正常则说明nginx正常启动着</p><p><img alt="image-20210524162928044" data-src="//orangesching.github.io/2021/05/25/服务器配置与管理/Nginx/二、Nginx安装卸载/image-20210524162928044.png" class="lazyload"></p><p>通过IP访问连接超时，可能由于防火墙打开但没有配置端口，或云服务器安全组未配置端口导致</p><p><img alt="image-20210524164130021" data-src="//orangesching.github.io/2021/05/25/服务器配置与管理/Nginx/二、Nginx安装卸载/image-20210524164130021.png" class="lazyload"></p><h3 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h3><p>如果打开了防火墙，则需配置80端口的准入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 添加80端口</span><br><span class="line">firewall-cmd --zone=public --add-port=80/tcp --permanent</span><br><span class="line"></span><br><span class="line"># 重新载入</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure><p><img alt="image-20210524164504029" data-src="//orangesching.github.io/2021/05/25/服务器配置与管理/Nginx/二、Nginx安装卸载/image-20210524164504029.png" class="lazyload"></p><p>PS：到这一步wget不一定能访问，若为云服务器则还需配置安全组</p><h3 id="云服务器安全组配置（云服务器专属配置）"><a href="#云服务器安全组配置（云服务器专属配置）" class="headerlink" title="云服务器安全组配置（云服务器专属配置）"></a>云服务器安全组配置（云服务器专属配置）</h3><p>云服务器安全组规则中配置80端口的访问权限</p><p><img alt="image-20210524163428854" data-src="//orangesching.github.io/2021/05/25/服务器配置与管理/Nginx/二、Nginx安装卸载/image-20210524163428854.png" class="lazyload"></p><h2 id="验证安装"><a href="#验证安装" class="headerlink" title="验证安装"></a>验证安装</h2><p>查看nginx版本来验证是否安装成功：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cd nginx安装目录/sbin</span><br><span class="line"></span><br><span class="line"># 执行查看版本命令</span><br><span class="line">./nginx -v</span><br><span class="line"></span><br><span class="line"># 开启nginx</span><br><span class="line">./nginx</span><br><span class="line"># 查看nginx运行状态</span><br><span class="line">ps -ef | grep nginx</span><br></pre></td></tr></table></figure><p>在客户端打开浏览器使用IP访问</p><p><img alt="image-20210524163521015" data-src="//orangesching.github.io/2021/05/25/服务器配置与管理/Nginx/二、Nginx安装卸载/image-20210524163521015.png" class="lazyload"></p><p>若不能访问见教程排查：<a href="https://www.cnblogs.com/achengmu/p/9093981.html" target="_blank" rel="noopener">https://www.cnblogs.com/achengmu/p/9093981.html</a></p><h2 id="配置systemctl-管理-选做"><a href="#配置systemctl-管理-选做" class="headerlink" title="配置systemctl 管理(选做)"></a>配置systemctl 管理(选做)</h2><ol><li>编辑systemctl服务配置文件</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /usr/lib/systemd/system/nginx.service</span><br></pre></td></tr></table></figure><ol><li>内容如下<br>注意更改nginx<code>启动命令</code>、<code>nginx.conf</code>、<code>nginx.pid</code>的路径</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=nginx  web server</span><br><span class="line">Documentation=http://nginx.org/en/docs/</span><br><span class="line">After=network.target remote-fs.target nss-lookup.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">PIDFile=/usr/local/soft/nginx/logs/nginx.pid</span><br><span class="line">ExecStartPre=/usr/local/soft/nginx/sbin/nginx -t -c /usr/local/soft/nginx/conf/nginx.conf</span><br><span class="line">ExecStart=/usr/local/soft/nginx/sbin/nginx -c /usr/local/soft/nginx/conf/nginx.conf</span><br><span class="line">ExecReload=/bin/kill -s HUP $MAINPID</span><br><span class="line">ExecStop=/bin/kill -s QUIT $MAINPID</span><br><span class="line">PrivateTmp=true</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><ol><li>重载系统服务</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br></pre></td></tr></table></figure><ol><li>启动nginx (启动前，记得把之前的先关闭)</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl start nginx</span><br><span class="line">systemctl status nginx</span><br></pre></td></tr></table></figure><ol><li>设置开机启动</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable nginx</span><br><span class="line">systemctl is-enabled nginx</span><br></pre></td></tr></table></figure><h1 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h1><p>全局查找nginx相关的文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">find / -name nginx*</span><br><span class="line">若报错用这个</span><br><span class="line">find / -name &quot;nginx*&quot;</span><br></pre></td></tr></table></figure><p>删除查出来的所有文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf 查出来的文件路径</span><br></pre></td></tr></table></figure><h1 id="附录1：安装时configure支持的配置选项"><a href="#附录1：安装时configure支持的配置选项" class="headerlink" title="附录1：安装时configure支持的配置选项"></a>附录1：安装时configure支持的配置选项</h1><p><code>--prefix = path</code> ：配置编译后文件存放的路径，默认使用<code>/usr/local/nginx</code>，<u>推荐使用默认</u></p><p><code>--sbin-path = path</code>：配置编译后可执行文件的路径，默认使用<code>prefix/sbin/nginx</code>，<u>推荐使用默认</u></p><p><code>--conf-path = path</code>：设置编译之后的conf文件的路径，默认是用<code>prefix/conf/nginx.conf</code>，<u>推荐使用默认</u></p><p><code>--pid-path = path</code>：配置<code>nginx.pid</code>文件（启动时生成的文件）存放的目录，默认是存放在<code>prefix/logs/nginx.pid</code>，<u>不推荐使用默认路径</u>，因为logs主要用于存放日志文件，这种情况下容易误删除，建议存放在<code>prefix/nginx.pid</code>目录下</p><p><code>--error-log-path = path</code>：配置错误日志文件的路径，默认路径为<code>prefix/logs/error.log</code>，在配置之后可以在<code>nginx.conf</code>中修改，在执行configure的时候<u>可以忽略</u></p><p><code>--http-log-path = path</code>：配置服务器访问日志路径，默认路径为<code>prefix/logs/access.log</code>，在配置之后可以在<code>nginx.conf</code>中修改，在执行configure的时候<u>可以忽略</u></p><p><code>--build = name</code>：设置nginx的编译的名字，<u>建议忽略该选项</u></p><p><code>--user = name</code> ：设置<code>worker</code>线程的linux用户信息，可以控制<code>worker</code>线程的权限，默认用户名为<code>nobody</code>，在配置之后可以在<code>nginx.conf</code>中修改，<u>推荐使用默认</u></p><p><code>--group = name</code>：同上，设置<code>worker</code>线程的linux用户分组，可以控制<code>worker</code>线程的权限，<u>推荐使用默认</u></p><p><code>--with-select_module</code>/<code>--without-select_module</code> ：配置服务器是否使用<code>select轮询接口</code>（该接口低效且有限制），在编译过程中默认首先使用高效的<code>epoll</code>、<code>poll</code>等机制，<u>推荐使用默认</u></p><p><code>--with-poll_module</code>/<code>--without-poll_module</code>：同上，<code>poll</code>接口比<code>select</code>接口更加高效，但是同样有一定的socket数量的限制，<u>推荐使用默认</u></p><p><code>--without-http_gzip_module</code> ：禁止服务器使用zip压缩传输数据，<u>忽略该选项</u></p><p><code>--without-http_rewrite_module</code>：禁止URL重写，<u>如果需要URL重写，忽略该选项</u></p><p><code>--without-http_proxy_module</code>：禁止代理模块，<u>如果需要代理，忽略该选项</u></p><p><code>--with-http_ssl_module</code>：开启SSL，<u>如果不需要SSL，忽略该选项</u></p><p><code>--with-pcre = path</code>：配置pcre库的源文件的路径，如果需要url重写或者是location正则匹配，那么需要配置该选项</p><p><code>--with-zlib = path</code>：配置zlib压缩库源文件的路径，如果需要数据传输压缩，那么需要配置该选项</p><p><code>--with-cc-opt = parameters</code>：该配置是用于扩展gcc编译配置，根据操作系统不同需要进行配置。</p><p><code>--with-ld-opt = parameters</code>：如果在FreeBSD操作系统下面配置PCRE，那么需要配置该选项</p><p>其他配置选项见：<a href="http://nginx.org/en/docs/configure.html" target="_blank" rel="noopener">http://nginx.org/en/docs/configure.html</a></p><h1 id="附录2：nginx-的模块清单"><a href="#附录2：nginx-的模块清单" class="headerlink" title="附录2：nginx 的模块清单"></a>附录2：nginx 的模块清单</h1><h2 id="核心模块"><a href="#核心模块" class="headerlink" title="核心模块"></a>核心模块</h2><ul><li>ngx_core</li><li>ngx_errlog</li><li>ngx_conf</li><li>ngx_events</li><li>ngx_event_core</li><li>ngx_epll</li><li>ngx_regex</li></ul><h2 id="标准-HTTP-模块"><a href="#标准-HTTP-模块" class="headerlink" title="标准 HTTP 模块"></a>标准 HTTP 模块</h2><ul><li>ngx_http</li><li>ngx_http_core             #配置端口，URI 分析，服务器相应错误处理，别名控制 (alias) 等</li><li>ngx_http_log              #自定义 access 日志</li><li>ngx_http_upstream         #定义一组服务器，可以接受来自 proxy, Fastcgi,Memcache 的重定向；主要用作<a href="https://cloud.tencent.com/product/clb?from=10680" target="_blank" rel="noopener">负载均衡</a></li><li>ngx_http_static</li><li>ngx_http_autoindex        #自动生成目录列表</li><li>ngx_http_index            #处理以<code>/</code>结尾的请求，如果没有找到 index 页，则看是否开启了<code>random_index</code>；如开启，则用之，否则用 autoindex</li><li>ngx_http_auth_basic       #基于 http 的身份认证 (auth_basic)</li><li>ngx_http_access           #基于 IP 地址的访问控制 (deny,allow)</li><li>ngx_http_limit_conn       #限制来自客户端的连接的响应和处理速率</li><li>ngx_http_limit_req        #限制来自客户端的请求的响应和处理速率</li><li>ngx_http_geo</li><li>ngx_http_map              #创建任意的键值对变量</li><li>ngx_http_split_clients</li><li>ngx_http_referer          #过滤 HTTP 头中 Referer 为空的对象</li><li>ngx_http_rewrite          #通过正则表达式重定向请求</li><li>ngx_http_proxy</li><li>ngx_http_fastcgi          #支持 fastcgi</li><li>ngx_http_uwsgi</li><li>ngx_http_scgi</li><li>ngx_http_memcached</li><li>ngx_http_empty_gif        #从内存创建一个 1×1 的透明 gif 图片，可以快速调用</li><li>ngx_http_browser          #解析 http 请求头部的 User-Agent 值</li><li>ngx_http_charset          #指定网页编码</li><li>ngx_http_upstream_ip_hash</li><li>ngx_http_upstream_least_conn</li><li>ngx_http_upstream_keepalive</li><li>ngx_http_write_filter</li><li>ngx_http_header_filter</li><li>ngx_http_chunked_filter</li><li>ngx_http_range_header</li><li>ngx_http_gzip_filter</li><li>ngx_http_postpone_filter</li><li>ngx_http_ssi_filter</li><li>ngx_http_charset_filter</li><li>ngx_http_userid_filter</li><li>ngx_http_headers_filter   #设置 http 响应头</li><li>ngx_http_copy_filter</li><li>ngx_http_range_body_filter</li><li>ngx_http_not_modified_filter</li></ul><h2 id="可选-HTTP-模块"><a href="#可选-HTTP-模块" class="headerlink" title="可选 HTTP 模块"></a>可选 HTTP 模块</h2><ul><li>ngx_http_addition         #在响应请求的页面开始或者结尾添加文本信息</li><li>ngx_http_degradation      #在低内存的情况下允许服务器返回 444 或者 204 错误</li><li>ngx_http_perl</li><li>ngx_http_flv              #支持将 Flash 多媒体信息按照流文件传输，可以根据客户端指定的开始位置返回 Flash</li><li>ngx_http_geoip            #支持解析基于 GeoIP 数据库的客户端请求</li><li>ngx_google_perftools</li><li>ngx_http_gzip             #gzip 压缩请求的响应</li><li>ngx_http_gzip_static      #搜索并使用预压缩的以.gz 为后缀的文件代替一般文件响应客户端请求</li><li>ngx_http_image_filter     #支持改变 png，jpeg，gif 图片的尺寸和旋转方向</li><li>ngx_http_mp4              #支持.mp4,.m4v,.m4a 等多媒体信息按照流文件传输，常与 ngx_http_flv 一起使用</li><li>ngx_http_random_index     #当收到 / 结尾的请求时，在指定目录下随机选择一个文件作为 index</li><li>ngx_http_secure_link      #支持对请求链接的有效性检查</li><li>ngx_http_ssl              #支持 https</li><li>ngx_http_stub_status</li><li>ngx_http_sub_module       #使用指定的字符串替换响应中的信息</li><li>ngx_http_dav              #支持 HTTP 和 WebDAV 协议中的 PUT/DELETE/MKCOL/COPY/MOVE 方法</li><li>ngx_http_xslt             #将 XML 响应信息使用 XSLT 进行转换</li></ul><h2 id="邮件服务模块"><a href="#邮件服务模块" class="headerlink" title="邮件服务模块"></a>邮件服务模块</h2><ul><li>ngx_mail_core</li><li>ngx_mail_pop3</li><li>ngx_mail_imap</li><li>ngx_mail_smtp</li><li>ngx_mail_auth_http</li><li>ngx_mail_proxy</li><li>ngx_mail_ssl</li></ul><h2 id="第三方模块"><a href="#第三方模块" class="headerlink" title="第三方模块"></a>第三方模块</h2><ul><li>echo-nginx-module         #支持在 nginx 配置文件中使用 echo/sleep/time/exec 等类 Shell 命令</li><li>memc-nginx-module</li><li>rds-json-nginx-module     #使 nginx 支持 json 数据的处理</li><li>lua-nginx-module</li></ul>]]></content>
      
      
      <categories>
          
          <category> 服务器配置与管理 </category>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境安装 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一、Nginx概述</title>
      <link href="/2021/05/24/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E4%B8%8E%E7%AE%A1%E7%90%86/Nginx/%E4%B8%80%E3%80%81Nginx%E6%A6%82%E8%BF%B0/"/>
      <url>/2021/05/24/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E4%B8%8E%E7%AE%A1%E7%90%86/Nginx/%E4%B8%80%E3%80%81Nginx%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h1><p><code>Nginx</code>是 HTTP 服务器和反向代理服务器，邮件代理服务器，以及 Igor Sysoev 最初编写的通用 TCP/UDP 代理服务器</p><h1 id="常用功能"><a href="#常用功能" class="headerlink" title="常用功能"></a>常用功能</h1><h2 id="Http正向-反向代理"><a href="#Http正向-反向代理" class="headerlink" title="Http正向/反向代理"></a>Http正向/反向代理</h2><p>web服务器最常用的功能之一，尤其是反向代理</p><p>Nginx在做反向代理时，提供性能稳定，并且能够提供配置灵活的转发功能。Nginx可以根据不同的正则匹配，采取不同的转发策略，比如图片文件结尾的走文件服务器，动态页面走web服务器，只要你正则写的没问题，又有相对应的服务器解决方案，你就可以随心所欲的玩。并且Nginx对返回结果进行错误页跳转，异常判断等。如果被分发的服务器存在异常，他可以将请求重新转发给另外一台服务器，然后自动去除异常服务器</p><h3 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h3><p>正向代理类似一个跳板机，代理访问外部资源</p><p>比如我们国内访问谷歌，直接访问访问不到，我们可以通过一个正向代理服务器，请求发到代理服，代理服务器能够访问谷歌，这样由代理去谷歌取到返回数据，再返回给我们，这样我们就能访问谷歌了</p><p><img alt="img" data-src="//orangesching.github.io/2021/05/24/服务器配置与管理/Nginx/一、Nginx概述/正向代理.jpg" class="lazyload"></p><p><strong>正向代理的作用：</strong></p><ul><li><p>访问原来无法访问的资源，如google</p></li><li><p>可以做缓存，加速访问资源</p></li><li><p>对客户端访问授权，上网进行认证</p></li><li><p>代理可以记录用户访问记录（上网行为管理），对外隐藏用户信息</p></li></ul><h3 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h3><p>反向代理（Reverse Proxy）实际运行方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器</p><p><img alt="img" data-src="//orangesching.github.io/2021/05/24/服务器配置与管理/Nginx/一、Nginx概述/反向代理.jpg" class="lazyload"></p><p> <strong>反向代理的作用：</strong></p><ul><li><p>保证内网的安全，阻止web攻击，大型网站，通常将反向代理作为公网访问地址，Web服务器是内网</p></li><li><p>负载均衡，通过反向代理服务器来优化网站的负载</p></li></ul><h3 id="正反向代理的区别"><a href="#正反向代理的区别" class="headerlink" title="正反向代理的区别"></a>正反向代理的区别</h3><p>正向代理相对于目标服务器而言<u>隐藏了客户端的IP地址</u>，因为对于目标服务器而言所有请求都是从正向代理服务器发出的，正向代理主要是为了突破网络访问限制，比如科学上网，还有就是隐藏客户端IP地址</p><p>反向代理相对于客户端而言<u>隐藏了目标服务器IP地址</u>，只需要知道代理服务器地址就能访问到目标服务器的资源。其主功能是可以做负载均衡和安全防护</p><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>Nginx提供的负载均衡策略有2种：</p><ul><li>内置策略：<ul><li>轮询：每个服务器轮流处理请求</li><li>加权轮询：按权重将请求分发</li><li>Ip hash：对客户端请求的 IP 进行 Hash 操作，然后根据Hash结果将同一个客户端 IP 的请求分发给同一台服务器进行处理，<u>可以解决session不共享的问题</u></li></ul></li><li>扩展策略：各种负载均衡算法</li></ul><p>内置策略例：假设有10个请求分别由192.168.1.2、192.168.1.3、192.168.1.4发出，则处理请求的服务器为下表所示</p><div class="table-container"><table><thead><tr><th></th><th>轮询</th><th>加权轮询</th><th>Ip hash</th></tr></thead><tbody><tr><td>服务器1</td><td>1、4、7、10</td><td>1、7</td><td>192.168.1.2的全部请求</td></tr><tr><td>服务器2</td><td>2、5、8</td><td>2、3、8、9</td><td>192.168.1.3的全部请求</td></tr><tr><td>服务器3</td><td>3、6、9</td><td>4、5、6、10</td><td>192.168.1.4的全部请求</td></tr></tbody></table></div><h2 id="web缓存"><a href="#web缓存" class="headerlink" title="web缓存"></a>web缓存</h2><p>Nginx可以对不同的文件做不同的缓存处理，配置灵活，并且支持FastCGI_Cache，主要用于对FastCGI的动态程序进行缓存。配合着第三方的ngx_cache_purge，对制定的URL缓存内容可以的进行增删管理</p><h1 id="与Apache服务器的区别"><a href="#与Apache服务器的区别" class="headerlink" title="与Apache服务器的区别"></a>与Apache服务器的区别</h1><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p><strong>Nginx相对于Apache的优势：</strong></p><ul><li>轻量级，采用C进行编写，同样的web服务，会占用更少的内存及资源</li><li>抗并发，原因见原理篇</li><li>设计高度模块化，编写模块相对简单，加上社区活跃，各种高性能模块出品迅速</li><li>配置简洁，正则配置让很多事情变得简单，而且改完配置能使用 -t 测试配置有没有问题</li><li>一般用于处理静态文件，静态处理性能比apache高三倍以上</li><li>作为负载均衡服务器，支持7层负载均衡</li><li>本身就是一个反向代理服务器，而且可以作为非常优秀的邮件代理服务器</li><li>nginx启动特别容易, 并且支持热部署，几乎可以做到 7*24 不间断运行，即使运行数个月也不需要重新启动</li></ul><p><strong>Apache相对于Nginx的优势：</strong></p><ul><li>apache的rewrite比nginx强大，在rewrite频繁的情况下，用apache</li><li>apache发展到现在，模块超多，基本想到的都可以找到</li><li>apache更为成熟，少bug ，nginx的bug相对较多</li><li>apache超稳定，一个进程死掉时，会影响到多个用户的使用，稳定性差</li><li>apache对PHP支持比较简单，nginx需要配合其他后端用</li><li>apache在处理动态请求有优势，nginx在这方面是鸡肋，一般动态请求要apache去做，nginx适合静态和反向</li><li>apache仍然是目前的主流，拥有丰富的特性，成熟的技术和开发社区</li></ul><p><strong>两者最核心的区别在于：</strong></p><p>Apache是同步多进程模型，一个连接对应一个进程<br>Nginx是异步的，多个连接（万级别）可以对应一个进程。</p><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><p>需要性能的web服务，用Nginx；如果不需要性能只求稳定，更考虑Apache；<br>Nginx处理放静态内容比Apache要好，特别是在可承受压力、带宽及资源消耗上都要优于Apache。<br>所以更为通用的方案是，前端Nginx抗并发，后端Apache集群，配合起来会更好</p>]]></content>
      
      
      <categories>
          
          <category> 服务器配置与管理 </category>
          
          <category> Nginx </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>五、Git分支操作</title>
      <link href="/2021/05/14/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7/Git/%E4%BA%94%E3%80%81Git%E5%88%86%E6%94%AF%E6%93%8D%E4%BD%9C/"/>
      <url>/2021/05/14/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7/Git/%E4%BA%94%E3%80%81Git%E5%88%86%E6%94%AF%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p>Git分支基础见三、Git基础</p><h1 id="查看分支"><a href="#查看分支" class="headerlink" title="查看分支"></a>查看分支</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 列出所有本地分支</span><br><span class="line">$ git branch</span><br><span class="line"></span><br><span class="line"># 列出所有远程分支</span><br><span class="line">$ git branch -r</span><br><span class="line"></span><br><span class="line"># 列出所有本地分支和远程分支</span><br><span class="line">$ git branch -a</span><br><span class="line"></span><br><span class="line"># 标*为当前版本</span><br></pre></td></tr></table></figure><p><img alt="image-20210520145041708" data-src="//orangesching.github.io/2021/05/14/版本控制工具/Git/五、Git分支操作/image-20210520145041708.png" class="lazyload"></p><h1 id="新建分支"><a href="#新建分支" class="headerlink" title="新建分支"></a>新建分支</h1><p>分支基础知识见三、Git基础。Git中新建分支即新建一个指向当前分支的指针</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 新建一个分支，但依然停留在当前分支</span><br><span class="line">$ git branch [branch-name]</span><br><span class="line"></span><br><span class="line"># 新建一个分支，并切换到该分支</span><br><span class="line">$ git checkout -b [branch]</span><br><span class="line"></span><br><span class="line"># 新建一个分支，指向指定commit</span><br><span class="line">$ git branch [branch] [commit-id]</span><br><span class="line"></span><br><span class="line"># 新建一个分支，与指定的远程分支建立追踪关系</span><br><span class="line">$ git branch --track [branch] [remote-branch]</span><br></pre></td></tr></table></figure><p>例如：新建分支后查看分支</p><p><img alt="image-20210521104227247" data-src="//orangesching.github.io/2021/05/14/版本控制工具/Git/五、Git分支操作/image-20210521104227247.png" class="lazyload"></p><h1 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 切换到指定分支，并更新工作区</span><br><span class="line">$ git checkout [branch-name]</span><br><span class="line"></span><br><span class="line"># 切换到上一个分支</span><br><span class="line">$ git checkout -</span><br><span class="line"></span><br><span class="line"># 建立追踪关系，在现有分支与指定的远程分支之间</span><br><span class="line">$ git branch --set-upstream [branch] [remote-branch]</span><br></pre></td></tr></table></figure><p>例1：切换到<code>dev1</code>分支，再切回上一个分支</p><p><img alt="image-20210521104436477" data-src="//orangesching.github.io/2021/05/14/版本控制工具/Git/五、Git分支操作/image-20210521104436477.png" class="lazyload"></p><p>例2：在master分支上提交两次，再新建一个分支，指向指定commit</p><p>在master提交三次</p><p><img alt="image-20210521105053768" data-src="//orangesching.github.io/2021/05/14/版本控制工具/Git/五、Git分支操作/image-20210521105053768.png" class="lazyload"></p><p>创建一个分支指向加a的commit（commit id 为c11b1）并切换到这个分支，查看提交记录没有加b的记录了</p><p><img alt="image-20210521105234523" data-src="//orangesching.github.io/2021/05/14/版本控制工具/Git/五、Git分支操作/image-20210521105234523.png" class="lazyload"></p><h1 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h1><h2 id="合并分支-1"><a href="#合并分支-1" class="headerlink" title="合并分支"></a>合并分支</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 合并指定分支到当前分支</span><br><span class="line">$ git merge [branch]</span><br><span class="line"></span><br><span class="line"># 选择一个commit，合并进当前分支</span><br><span class="line">$ git cherry-pick [commit]</span><br></pre></td></tr></table></figure><p>例如：刚刚我们在master上将文件readme.md修改为a提交了一次，修改为ab提交了一次，并创建了分支dev2指向提交a时的commit，所以dev2的修改是基于内容为a的readme.md，现在在dev2上修改文件readme.md为ac，创建文件dev2.txt并提交。git log 可查看当前分支的提交记录</p><p><img alt="image-20210521111716471" data-src="//orangesching.github.io/2021/05/14/版本控制工具/Git/五、Git分支操作/image-20210521111716471.png" class="lazyload"></p><p>切换到master分支，合并master与dev2分支，这时readme.md产生冲突，可使用git status查看当前文件状态</p><p><img alt="image-20210521112051994" data-src="//orangesching.github.io/2021/05/14/版本控制工具/Git/五、Git分支操作/image-20210521112051994.png" class="lazyload"></p><p>这时分支已合并，但部分文件有冲突，需你解决冲突</p><h2 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h2><p>解决冲突即人工将冲突部分合并后，在当前分支正常提交</p><p>如上述例子：</p><p>打开readme.md文件，发现冲突部分已在文件内，用<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，<code>=======</code>，<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>标记出不同分支的内容</p><p><code>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</code>是指主分支修改的内容</p><p><code>&gt;&gt;&gt;&gt;&gt;&gt;&gt; dev2</code> 是指dev2上修改的内容</p><p>人工修改整合两个分支的内容，再正常提交</p><p>通过<code>git status</code>可看到已经没有冲突了</p><p><img alt="image-20210521112336593" data-src="//orangesching.github.io/2021/05/14/版本控制工具/Git/五、Git分支操作/image-20210521112336593.png" class="lazyload"></p><h1 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 删除分支</span><br><span class="line">git branch -d [branch-name]</span><br><span class="line"># -D强制删除</span><br><span class="line"></span><br><span class="line"># 删除远程分支</span><br><span class="line">git push origin --delete [branch-name]</span><br><span class="line">git branch -dr [remote/branch]</span><br><span class="line"># -d表示删除分支。分支必须完全合并在其上游分支，或者在HEAD上没有设置上游</span><br><span class="line"># -r表示远程的意思remotes，如果-dr则表示删除远程分支</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 版本控制工具 </category>
          
          <category> Git </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>四、Git文件操作</title>
      <link href="/2021/05/07/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7/Git/%E5%9B%9B%E3%80%81Git%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"/>
      <url>/2021/05/07/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7/Git/%E5%9B%9B%E3%80%81Git%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="GIT仓库创建"><a href="#GIT仓库创建" class="headerlink" title="GIT仓库创建"></a>GIT仓库创建</h1><h2 id="创建全新仓库"><a href="#创建全新仓库" class="headerlink" title="创建全新仓库"></a>创建全新仓库</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方式一：在当前目录新建一个Git代码库</span></span><br><span class="line">git init</span><br><span class="line"><span class="comment"># 方式二：新建一个目录，将其初始化为Git代码库</span></span><br><span class="line">git init [project-name]</span><br></pre></td></tr></table></figure><p>执行后会再当前目录产生<code>.git</code>文件夹（隐藏的），关于版本等的所有信息都在这个目录里面，文件夹内容如下：</p><p><img alt="image-20210507102132460" data-src="//orangesching.github.io/2021/05/07/版本控制工具/Git/四、Git文件操作/image-20210507102132460.png" class="lazyload"></p><h2 id="克隆远程仓库"><a href="#克隆远程仓库" class="headerlink" title="克隆远程仓库"></a>克隆远程仓库</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 克隆一个项目和它的整个代码历史(版本信息)</span></span><br><span class="line">$ git <span class="built_in">clone</span> [url]</span><br></pre></td></tr></table></figure><h1 id="GIT文件操作"><a href="#GIT文件操作" class="headerlink" title="GIT文件操作"></a>GIT文件操作</h1><p>在Git基础中介绍到，git 模型可以抽象为  </p><ul><li>本地三级仓库<ol><li>level1——working directory：工作区/工作目录，就是你平时存放项目代码的地方，需要git来管理的目录</li><li>level2——stage(index)：暂存区，用于临时存放你的改动，它只是一个文件，保存即将提交到文件列表信息</li><li>level3——repository(History) ：资源库，就是安全存放数据的位置，这里面有你提交到所有版本的数据。其中HEAD指向最新放入仓库的版本</li></ol></li><li>远程仓库<ul><li>Remote Directory：托管代码的服务器，可以简单的认为是你项目组中的一台电脑用于远程数据交换</li></ul></li></ul><p>git 的各个命令可以理解为在各个仓库间转移数据，各个命令对应对每个仓库输入输出</p><p><img alt="img" data-src="//orangesching.github.io/2021/05/07/版本控制工具/Git/四、Git文件操作/63651-20170905212837976-775285128.png" class="lazyload"></p><p><img alt="img" data-src="//orangesching.github.io/2021/05/07/版本控制工具/Git/四、Git文件操作/262337009765252.jpg" class="lazyload"></p><h2 id="本地仓库操作"><a href="#本地仓库操作" class="headerlink" title="本地仓库操作"></a>本地仓库操作</h2><p><img alt="img" data-src="//orangesching.github.io/2021/05/07/版本控制工具/Git/四、Git文件操作/262308046017546.jpg" class="lazyload"></p><h3 id="向上提交操作"><a href="#向上提交操作" class="headerlink" title="向上提交操作"></a>向上提交操作</h3><h4 id="工作区-gt-暂存区-add"><a href="#工作区-gt-暂存区-add" class="headerlink" title="工作区-&gt;暂存区(add)"></a>工作区-&gt;暂存区(<code>add</code>)</h4><p>将untracked状态的文件添加到暂存区</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 添加指定文件到暂存区</span><br><span class="line">$ git add [file1] [file2] ...</span><br><span class="line"></span><br><span class="line"># 添加指定目录到暂存区，包括子目录</span><br><span class="line">$ git add [dir]</span><br><span class="line"></span><br><span class="line"># 添加当前目录的所有文件到暂存区</span><br><span class="line">$ git add .</span><br></pre></td></tr></table></figure><h4 id="暂存区-gt-资源库-commit"><a href="#暂存区-gt-资源库-commit" class="headerlink" title="暂存区-&gt;资源库(commit)"></a>暂存区-&gt;资源库(<code>commit</code>)</h4><p><strong><code>git commit</code>直接提交</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 提交暂存区到仓库区</span><br><span class="line">git commit -m [message]</span><br><span class="line"></span><br><span class="line"># 提交暂存区的指定文件到仓库区</span><br><span class="line">git commit [file1] [file2] ... -m [message]</span><br><span class="line"></span><br><span class="line"># 提交时显示所有diff信息</span><br><span class="line">git commit -v</span><br></pre></td></tr></table></figure><p>原理：</p><div class="table-container"><table><thead><tr><th>当前分支(head)是master分支的提交</th><th>当前分支(head)是非master分支的提交</th></tr></thead><tbody><tr><td><img alt="img" data-src="//orangesching.github.io/2021/05/07/版本控制工具/Git/四、Git文件操作/262341091173993.jpg" class="lazyload"></td><td><img alt="img" data-src="//orangesching.github.io/2021/05/07/版本控制工具/Git/四、Git文件操作/262343091647668.jpg" class="lazyload"></td></tr><tr><td>提交前，master指向ed489<br>提交后，master指向新的节点f0cec并以ed489作为父节点</td><td>maint分支就不再是<em>master</em>分支的祖父节点</td></tr></tbody></table></div><p><strong><code>git commit --amend</code>覆盖提交</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 使用一次新的commit，替代上一次提交</span><br><span class="line">git commit --amend -m [message]</span><br><span class="line"></span><br><span class="line"># 重做上一次commit，并包括指定文件的新变化</span><br><span class="line">git commit --amend [file1] [file2] ...</span><br></pre></td></tr></table></figure><p>原理：git会使用与当前提交相同的父节点进行一次新提交，旧的提交会被取消</p><p><img alt="img" data-src="//orangesching.github.io/2021/05/07/版本控制工具/Git/四、Git文件操作/262345359613448.jpg" class="lazyload"></p><h4 id="工作区-gt-资源库-commit-a"><a href="#工作区-gt-资源库-commit-a" class="headerlink" title="工作区-&gt;资源库(commit -a)"></a>工作区-&gt;资源库(<code>commit -a</code>)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 提交工作区自上次commit之后的变化，直接到仓库区，跳过了add,对新文件无效</span><br><span class="line">git commit -a</span><br></pre></td></tr></table></figure><h3 id="向下撤销操作"><a href="#向下撤销操作" class="headerlink" title="向下撤销操作"></a>向下撤销操作</h3><h4 id="资源库-gt-暂存区-工作区-reset"><a href="#资源库-gt-暂存区-工作区-reset" class="headerlink" title="资源库-&gt;暂存区/工作区(reset)"></a>资源库-&gt;暂存区/工作区(<code>reset</code>)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset [版本号，默认为HEAD] &lt;--hard/--soft/默认&gt;</span><br></pre></td></tr></table></figure><p>reset 的本质为移动HEAD到目标reset节点，并捎带上HEAD指向的分支<u>内容差异</u>，以下示意图为内容差异，即4分支上所做的修改</p><p><img alt="img" data-src="//orangesching.github.io/2021/05/07/版本控制工具/Git/四、Git文件操作/4428238-75ef41dc9eec6f8e" class="lazyload"></p><p>以下不同模式为对内容差异的处理</p><p><strong>—hard模式</strong></p><p>将<strong>working Tree工作区</strong>、 <strong>index 暂存区</strong>及 <strong>repository资源库</strong> 都重置成目标<strong>Reset</strong>节点的內容**</p><p>内容差异直接丢弃</p><p>效果等同于清空暂存区和工作区的修改，会丢失工作区修改的东西，很危险</p><p><strong>—soft模式</strong></p><p>保留<strong>working Tree工作区</strong>、 <strong>index 暂存区</strong>内容，只让<strong>repository资源库</strong>中的内容和<strong>Reset</strong>节点保持一致</p><p>内容差异体现在<strong>index 暂存区</strong>与<strong>repository资源库</strong></p><p>即使用<code>git diff --cached</code>可查看内容差异(如示意图的4分支的修改内容)</p><p><strong>—mixed模式（默认）</strong></p><p>保留<strong>working Tree工作区</strong>内容，让<strong>repository资源库</strong>、 <strong>index 暂存区</strong>中的内容和<strong>Reset</strong>节点保持一致</p><p>内容差异体现在<strong>working Tree工作区</strong>与<strong>index 暂存区</strong></p><p>即使用<code>git diff</code>可查看内容差异(如示意图的4分支的修改内容)</p><h4 id="资源库-暂存区-gt-工作区-checkout"><a href="#资源库-暂存区-gt-工作区-checkout" class="headerlink" title="资源库/暂存区-&gt;工作区(checkout)"></a>资源库/暂存区-&gt;工作区(<code>checkout</code>)</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用法一：将资源库/暂存区的指定文件/全部文件更新到工作区，不会切换HEAD分支</span></span><br><span class="line">git checkout [-q] [&lt;commit_id&gt;] [--] &lt;paths&gt;...</span><br><span class="line"><span class="comment"># commit_id通过git log可查看每次提交的md5码</span></span><br><span class="line"><span class="comment"># 例如：</span></span><br><span class="line"><span class="comment"># 用暂存区的filename文件覆盖工作区的该文件</span></span><br><span class="line">git checkout -- filename</span><br><span class="line"><span class="comment"># 用暂存区的所有文件直接覆盖工作区</span></span><br><span class="line">git checkout .</span><br><span class="line"><span class="comment"># 用资源库的filename文件覆盖工作区的该文件</span></span><br><span class="line">git checkout 53d8 -- filename</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用法二 检出branch分支;要完成图中的三个步骤，更新HEAD以指向branch分支，以及用branch指向的树更新暂存区和工作区</span></span><br><span class="line"><span class="comment"># 与用法一的区别：会切换分支</span></span><br><span class="line">git checkout [&lt;branch&gt;&lt;commit_id&gt;]</span><br><span class="line"><span class="comment"># 例如：以下两句都为chekout HEAD指向的分支</span></span><br><span class="line">git checkout</span><br><span class="line">git checkout HEAD</span><br><span class="line"><span class="comment"># 以下会将HEAD指向53d8分支</span></span><br><span class="line">git checkout 53d8</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用法三</span></span><br><span class="line">git checkout [-m] [[-b]--orphan] &lt;new_branch&gt;] [&lt;start_point&gt;]</span><br></pre></td></tr></table></figure><p><img alt="img" data-src="//orangesching.github.io/2021/05/07/版本控制工具/Git/四、Git文件操作/63651-20170906224842804-513302659.png" class="lazyload"></p><h4 id="reset与checkout的区别"><a href="#reset与checkout的区别" class="headerlink" title="reset与checkout的区别"></a>reset与checkout的区别</h4><p>首先不同于 reset —hard，checkout 对工作目录是安全的，它会通过检查来确保不会将已更改的文件弄丢；而 reset —hard 则会不做检查就全面地替换所有东西</p><p>第二个重要的区别是如何更新 HEAD。 reset 会移动 HEAD 分支的指向（即 HEAD 指向的分支的指向），而 checkout 只会移动 HEAD 自身来指向另一个分支</p><p><img alt="这里写图片描述" data-src="//orangesching.github.io/2021/05/07/版本控制工具/Git/四、Git文件操作/20180902113022436" class="lazyload"></p><h3 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h3><p>有些时候我们不想把某些文件纳入版本控制中，比如数据库文件，临时文件，设计文件等</p><p>在主目录下建立<code>.gitignore</code>文件，此文件有如下规则：</p><ol><li>忽略文件中的空行或以井号（#）开始的行</li><li>可使用Linux通配符。例如：<code>*</code>代表任意多个字符，<code>？</code>代表一个字符，方括号<code>[abc]</code>代表可选字符范围，大括号<code>{string1,string2,...}</code>代表可选的字符串等</li><li><code>!</code>加名称，表示例外规则，将不被忽略</li><li><code>/</code>加名称，表示要忽略的文件在此目录下，而子目录中的文件不忽略。</li><li>名称加<code>/</code>，表示要忽略的是此目录下该名称的子目录，而非文件（默认文件或目录都忽略）</li></ol><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#为注释</span><br><span class="line">*.txt #忽略所有 .txt结尾的文件</span><br><span class="line">!lib.txt #但lib.txt除外</span><br><span class="line">/temp #仅忽略项目根目录下的TODO文件,不包括其它目录temp</span><br><span class="line">build/ #忽略build/目录下的所有文件</span><br><span class="line">doc/*.txt #会忽略 doc/notes.txt 但不包括 doc/server/arch.txt</span><br></pre></td></tr></table></figure><h2 id="远程仓库操作"><a href="#远程仓库操作" class="headerlink" title="远程仓库操作"></a>远程仓库操作</h2><h3 id="远程主机管理-remote"><a href="#远程主机管理-remote" class="headerlink" title="远程主机管理(remote)"></a>远程主机管理(remote)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 显示所有远程仓库</span><br><span class="line">git remote -v</span><br><span class="line"></span><br><span class="line"># 显示某个远程仓库的信息</span><br><span class="line">git remote show [remote]</span><br><span class="line"></span><br><span class="line"># 增加一个新的远程仓库，并命名</span><br><span class="line">git remote add [shortname] [url]</span><br><span class="line"></span><br><span class="line"># 删除远程主机</span><br><span class="line">git remote rm &lt;主机名&gt;</span><br><span class="line"></span><br><span class="line"># 重命名远程主机</span><br><span class="line">git remote rename &lt;原主机名&gt; &lt;新主机名&gt;</span><br></pre></td></tr></table></figure><h3 id="获取更新-fetch-pull"><a href="#获取更新-fetch-pull" class="headerlink" title="获取更新(fetch/pull)"></a>获取更新(fetch/pull)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 下载远程仓库的所有变动</span><br><span class="line">$ git fetch [remote]</span><br><span class="line"></span><br><span class="line">#获取远程仓库数据，不自动合并当前分支</span><br><span class="line">git fetch [remote]</span><br><span class="line"></span><br><span class="line"># 取回远程仓库的变化，并与本地分支合并</span><br><span class="line">$ git pull [remote] [branch]</span><br><span class="line"></span><br><span class="line"># 获取仓库所有更新，并自动合并到当前分支</span><br><span class="line">git pull</span><br></pre></td></tr></table></figure><h3 id="上传更新"><a href="#上传更新" class="headerlink" title="上传更新"></a>上传更新</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#上传数据，如git push origin master</span><br><span class="line">git push [remote-name] [branch]</span><br><span class="line"></span><br><span class="line"># 上传本地指定分支到远程仓库</span><br><span class="line">$ git push [remote] [branch]</span><br><span class="line"></span><br><span class="line"># 强行推送当前分支到远程仓库，即使有冲突</span><br><span class="line">$ git push [remote] --force</span><br><span class="line"></span><br><span class="line"># 推送所有分支到远程仓库</span><br><span class="line">$ git push [remote] --all</span><br></pre></td></tr></table></figure><h2 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h2><h3 id="查看文件状态"><a href="#查看文件状态" class="headerlink" title="查看文件状态"></a>查看文件状态</h3><p>在Git基础中介绍到，文件有四种状态：<code>Untracked</code>、<code>Unmodified</code>、<code>Modified</code>、<code>Staged</code></p><p>可使用以下语句查看文件状态：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看指定文件状态</span></span><br><span class="line">git status [filename]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看所有文件状态</span></span><br><span class="line">git status</span><br></pre></td></tr></table></figure><h3 id="查看文件修改后的差异"><a href="#查看文件修改后的差异" class="headerlink" title="查看文件修改后的差异"></a>查看文件修改后的差异</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看工作区与暂存区的文件差异</span></span><br><span class="line">git diff [files]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 比较工作区与资源库的文件差异</span></span><br><span class="line">git diff HEAD~n</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看暂存区与资源库的文件差异</span></span><br><span class="line">git diff --cached</span><br></pre></td></tr></table></figure><p><img alt="img" data-src="//orangesching.github.io/2021/05/07/版本控制工具/Git/四、Git文件操作/63651-20170914095506203-2063795525.png" class="lazyload"></p><p>输出结果解析：</p><p><code>---</code>代表源文件<br><code>+++</code>代表目标文件 </p><ol><li><code>-</code>开头的行，是只出现在源文件中的行</li><li><code>+</code>开头的行，是只出现在目标文件中的行</li><li>空格开头的行，是源文件和目标文件中都出现的行</li><li>差异按照差异小结进行组织，每个差异小结的第一行都是定位语句，由<code>@@</code>开头，<code>@@</code>结尾。</li></ol><p>例如：</p><p>对文件做以下操作：</p><ol><li><p>创建readme.me，加上第一行a，使用<code>commit -a</code>提交到资源库</p></li><li><p>修改readme.me，加上第二行b，使用<code>add</code>提交到暂存区</p></li><li><p>修改readme.me，加上第三行c，不提交</p></li><li><p>使用以上三种方式查看三个位置的文件区别</p><p>| 工作区与暂存区的文件差异                                     | 工作区与资源库的文件差异                                     | 暂存区与资源库的文件差异                                     |<br>| —————————————————————————————— | —————————————————————————————— | —————————————————————————————— |<br>| <img alt="image-20210517132151639" data-src="//orangesching.github.io/2021/05/07/版本控制工具/Git/四、Git文件操作/image-20210517132151639.png" class="lazyload"> | <img alt="image-20210517132125683" data-src="//orangesching.github.io/2021/05/07/版本控制工具/Git/四、Git文件操作/image-20210517132125683.png" class="lazyload"> | <img alt="image-20210517132103215" data-src="//orangesching.github.io/2021/05/07/版本控制工具/Git/四、Git文件操作/image-20210517132103215.png" class="lazyload"> |<br>| <code>git diff [files]</code>                                           | <code>git diff HEAD~n</code>                                            | <code>git diff --cached</code>                                          |</p></li></ol><h3 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看提交日志 </span></span><br><span class="line">git <span class="built_in">log</span> [&lt;options&gt;] [&lt;revision range&gt;] [[\--] &lt;path&gt;…]</span><br><span class="line"><span class="comment"># --graph 以图形化的方式显示提交历史的关系</span></span><br><span class="line"><span class="comment"># -1 显示1行</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看所有分支日志，显示这个仓库中所有的分支的所有更新记录，包括已经撤销的更新</span></span><br><span class="line">git reflog</span><br></pre></td></tr></table></figure><h3 id="查看文件列表"><a href="#查看文件列表" class="headerlink" title="查看文件列表"></a>查看文件列表</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看指定状态的文件</span></span><br><span class="line">git ls-files [-z] [-t] [-v] (--[cached|deleted|others|ignored|stage|unmerged|killed|modified])* (-[c|d|o|i|s|u|k|m])*</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 版本控制工具 </category>
          
          <category> Git </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>三、Git基础</title>
      <link href="/2021/04/30/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7/Git/%E4%B8%89%E3%80%81Git%E5%9F%BA%E7%A1%80/"/>
      <url>/2021/04/30/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7/Git/%E4%B8%89%E3%80%81Git%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="Git工作区域"><a href="#Git工作区域" class="headerlink" title="Git工作区域"></a>Git工作区域</h1><p>git 模型可以抽象为  </p><ul><li>本地三级仓库: <ol><li>level1——working directory：工作区/工作目录，就是你平时存放项目代码的地方，需要git来管理的目录</li><li>level2——stage(index)：暂存区，用于临时存放你的改动，它只是一个文件，保存即将提交到文件列表信息</li><li>level3——repository(History) ：资源库，就是安全存放数据的位置，这里面有你提交到所有版本的数据。其中HEAD指向最新放入仓库的版本</li></ol></li><li>远程仓库<ul><li>Remote Directory：托管代码的服务器，可以简单的认为是你项目组中的一台电脑用于远程数据交换</li></ul></li></ul><p>git 的各个命令可以理解为在各个仓库间转移数据，各个命令对应对每个仓库输入输出。</p><p>文件在这四个区域之间的转换关系如下：</p><p><img alt="img" data-src="//orangesching.github.io/2021/04/30/版本控制工具/Git/三、Git基础/63651-20170905201017069-171460014.png" class="lazyload"></p><p>本地的三个区域确切的说应该是git仓库中HEAD指向的版本</p><p><img alt="img" data-src="//orangesching.github.io/2021/04/30/版本控制工具/Git/三、Git基础/63651-20170906230652788-1835188684.png" class="lazyload"></p><ul><li>Directory：使用Git管理的一个目录，也就是一个仓库，包含我们的工作空间和Git的管理空间。</li><li>WorkSpace：需要通过Git进行版本控制的目录和文件，这些目录和文件组成了工作空间。</li><li>.git：存放Git管理信息的目录，初始化仓库的时候自动创建。</li><li>Index/Stage：暂存区，或者叫待提交更新区，在提交进入repo之前，我们可以把所有的更新放在暂存区。</li><li>Local Repo：本地仓库，一个存放在本地的版本库；HEAD会只是当前的开发分支（branch）。</li><li>Stash：隐藏，是一个工作状态保存栈，用于保存/恢复WorkSpace中的临时状态。</li></ul><h1 id="Git文件4种状态"><a href="#Git文件4种状态" class="headerlink" title="Git文件4种状态"></a>Git文件4种状态</h1><ul><li><strong>Untracked</strong>: 未追踪，此文件在工作区文件夹中，但并没有加入到git库, <u>不参与版本控制</u>. 通过<code>git add</code> 状态变为<code>Staged</code>.</li><li><strong>Unmodify</strong>: 加入到git库，但未修改，即<u>版本库中的文件内容与文件夹中完全一致</u>. 这种类型的文件有两种去处, 如果它被修改, 而变为<code>Modified</code>. 如果使用<code>git rm</code>移出版本库, 则成为<code>Untracked</code>文件</li><li><strong>Modified</strong>: <u>文件已修改</u>, 仅仅是修改, 并没有进行其他的操作. 这个文件也有两个去处, 通过<code>git add</code>可进入暂存<code>staged</code>状态, 使用<code>git checkout</code> 则丢弃修改过, 返回到<code>unmodify</code>状态, 这个<code>git checkout</code>即从库中取出文件, 覆盖当前修改</li><li><strong>Staged</strong>: 暂存状态. <u>执行<code>git commit</code>则将修改同步到库</u>中, 这时库中的文件和本地文件又变为一致, 文件为<code>Unmodify</code>状态. 执行<code>git reset HEAD filename</code>取消暂存, 文件状态为<code>Modified</code></li></ul><p><img alt="Git 下文件生命周期图。" data-src="//orangesching.github.io/2021/04/30/版本控制工具/Git/三、Git基础/lifecycle.png" class="lazyload"></p><p><img alt="img" data-src="//orangesching.github.io/2021/04/30/版本控制工具/Git/三、Git基础/63651-20170909091456335-1787774607.jpg" class="lazyload"></p><h1 id="Git工作流程"><a href="#Git工作流程" class="headerlink" title="Git工作流程"></a>Git工作流程</h1><p>git的工作流程一般是这样的：</p><p>１、在工作目录中添加、修改文件；</p><p>２、将需要进行版本管理的文件放入暂存区域；</p><p>３、将暂存区域的文件提交到git仓库。</p><p>因此，git管理的文件有三种状态：已修改（modified）,已暂存（staged）,已提交(committed)</p><p><img alt="img" data-src="//orangesching.github.io/2021/04/30/版本控制工具/Git/三、Git基础/63651-20170905201033647-1915833066.png" class="lazyload"></p><p>个人认为Git的原理相比别的版本控制器还是复杂一些的，有一份图解教程比较直观：</p><p><a href="http://www.cnblogs.com/yaozhongxiao/p/3811130.html" target="_blank" rel="noopener">图解教程中文版</a></p><p><img alt="img" data-src="//orangesching.github.io/2021/04/30/版本控制工具/Git/三、Git基础/63651-20170914100820891-2098204183.png" class="lazyload"></p><h1 id="Git分支"><a href="#Git分支" class="headerlink" title="Git分支"></a>Git分支</h1><h2 id="分支是什么"><a href="#分支是什么" class="headerlink" title="分支是什么"></a>分支是什么</h2><p>分支就是科幻电影里面的平行宇宙，当你正在电脑前努力学习Git的时候，另一个你正在另一个平行宇宙里努力学习SVN。</p><p>如果两个平行宇宙互不干扰，那对现在的你也没啥影响。不过，在某个时间点，两个平行宇宙合并了，结果，你既学会了Git又学会了SVN！</p><p><img alt="learn-branches" data-src="//orangesching.github.io/2021/04/30/版本控制工具/Git/三、Git基础/919021987875136" class="lazyload"></p><p>分支在实际中有什么用呢？假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了50%的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。</p><p>现在有了分支，就不用怕了。你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。</p><h2 id="分支原理"><a href="#分支原理" class="headerlink" title="分支原理"></a>分支原理</h2><p>每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即<code>master</code>分支。<code>HEAD</code>严格来说不是指向提交，而是指向<code>master</code>，<code>master</code>才是指向提交的，所以，<code>HEAD</code>指向的就是当前分支。</p><p>一开始的时候，<code>master</code>分支是一条线，Git用<code>master</code>指向最新的提交，再用<code>HEAD</code>指向<code>master</code>，就能确定当前分支，以及当前分支的提交点：</p><p><img alt="git-br-initial" data-src="//orangesching.github.io/2021/04/30/版本控制工具/Git/三、Git基础/0" class="lazyload"></p><p>每次提交，<code>master</code>分支都会向前移动一步，这样，随着你不断提交，<code>master</code>分支的线也越来越长。</p><p>当我们创建新的分支，例如<code>dev</code>时，Git新建了一个指针叫<code>dev</code>，指向<code>master</code>相同的提交，再把<code>HEAD</code>指向<code>dev</code>，就表示当前分支在<code>dev</code>上：</p><p><img alt="git-br-create" data-src="//orangesching.github.io/2021/04/30/版本控制工具/Git/三、Git基础/l" class="lazyload"></p><p>所以，Git创建一个分支很快，因为除了增加一个<code>dev</code>指针，改改<code>HEAD</code>的指向，工作区的文件都没有任何变化！</p><p>不过，从现在开始，对工作区的修改和提交就是针对<code>dev</code>分支了，比如新提交一次后，<code>dev</code>指针往前移动一步，而<code>master</code>指针不变：</p><p><img alt="git-br-dev-fd" data-src="//orangesching.github.io/2021/04/30/版本控制工具/Git/三、Git基础/2" class="lazyload"></p><p>假如我们在<code>dev</code>上的工作完成了，就可以把<code>dev</code>合并到<code>master</code>上。Git怎么合并呢？最简单的方法，就是直接把<code>master</code>指向<code>dev</code>的当前提交，就完成了合并：</p><p><img alt="git-br-ff-merge" data-src="//orangesching.github.io/2021/04/30/版本控制工具/Git/三、Git基础/3" class="lazyload"></p><p>所以Git合并分支也很快！就改改指针，工作区内容也不变！</p><p>合并完分支后，甚至可以删除<code>dev</code>分支。删除<code>dev</code>分支就是把<code>dev</code>指针给删掉，删掉后，我们就剩下了一条<code>master</code>分支：</p><p><img alt="git-br-rm" data-src="//orangesching.github.io/2021/04/30/版本控制工具/Git/三、Git基础/4" class="lazyload"></p><p><img alt="img" data-src="//orangesching.github.io/2021/04/30/版本控制工具/Git/三、Git基础/63651-20170905212648335-1801547172.gif" class="lazyload"></p><p>参考整理自：</p><p><a href="https://www.cnblogs.com/syp172654682/p/7689328.html" target="_blank" rel="noopener">https://www.cnblogs.com/syp172654682/p/7689328.html</a></p><p><a href="https://www.liaoxuefeng.com/wiki/896043488029600/900003767775424" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/896043488029600/900003767775424</a></p>]]></content>
      
      
      <categories>
          
          <category> 版本控制工具 </category>
          
          <category> Git </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>二、Git安装与服务器搭建</title>
      <link href="/2021/04/29/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7/Git/%E4%BA%8C%E3%80%81Git%E5%AE%89%E8%A3%85%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/"/>
      <url>/2021/04/29/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7/Git/%E4%BA%8C%E3%80%81Git%E5%AE%89%E8%A3%85%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h1><h2 id="Windows安装"><a href="#Windows安装" class="headerlink" title="Windows安装"></a>Windows安装</h2><p>下载最新版Git安装包：<a href="https://git-scm.com/download/win" target="_blank" rel="noopener">https://git-scm.com/download/win</a></p><p>打开安装包后，<strong>可一直使用默认选项，点下一步</strong>，下面是各步骤选项详述</p><ol><li>设置安装路径</li></ol><p><img alt="安装路径" data-src="//orangesching.github.io/2021/04/29/版本控制工具/Git/二、Git安装与服务器搭建/安装路径.jpg" class="lazyload"></p><ol><li>选择安装组件</li></ol><p><img alt="安装组件" data-src="//orangesching.github.io/2021/04/29/版本控制工具/Git/二、Git安装与服务器搭建/安装组件.jpg" class="lazyload"></p><ol><li><p>选择默认编辑器</p><p><img alt="image-20210427134320574" data-src="//orangesching.github.io/2021/04/29/版本控制工具/Git/二、Git安装与服务器搭建/image-20210427134320574.png" class="lazyload"></p></li><li><p>修改系统的环境变量</p></li></ol><p><img alt="环境变量" data-src="//orangesching.github.io/2021/04/29/版本控制工具/Git/二、Git安装与服务器搭建/环境变量.jpg" class="lazyload"></p><ol><li>SSL的证书的选择</li></ol><p><img alt="SSH证书" data-src="//orangesching.github.io/2021/04/29/版本控制工具/Git/二、Git安装与服务器搭建/SSH证书.jpg" class="lazyload"></p><blockquote><p><strong>https：（全称：Hyper Text Transfer Protocol over Secure Socket Layer）</strong></p><p>简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。 它是一个URI scheme（抽象标识符体系），句法类同<a href="https://link.jianshu.com?t=https%3A%2F%2Fbaike.baidu.com%2Fitem%2Fhttp" target="_blank" rel="noopener">http</a>:体系。用于安全的HTTP数据传输。</p><p><a href="https://link.jianshu.com?t=https%3A%2F%2Fbaike.baidu.com%2Fitem%2Fhttps%2F285356%3Ffr%3Daladdin" target="_blank" rel="noopener">参考链接：百科</a></p></blockquote><ol><li>配置行尾结束符</li></ol><p><img alt="配置行尾结束符" data-src="//orangesching.github.io/2021/04/29/版本控制工具/Git/二、Git安装与服务器搭建/配置行尾结束符.jpg" class="lazyload"></p><p><strong>配置行尾结束符</strong></p><div class="table-container"><table><thead><tr><th>系统</th><th>换行符</th></tr></thead><tbody><tr><td>windows</td><td>\n\r</td></tr><tr><td>unix</td><td>\n</td></tr><tr><td>mac</td><td>\r</td></tr></tbody></table></div><ol><li>配置终端仿真</li></ol><p><img alt="配置终端仿真" data-src="//orangesching.github.io/2021/04/29/版本控制工具/Git/二、Git安装与服务器搭建/配置终端仿真.jpg" class="lazyload"></p><blockquote><p>大多数其他Cygwin/MSYS终端一样，MinTTY也是基于pseudo终端(“pty”)设备的。但是MinTTY并不能完全替代windows的<a href="https://link.jianshu.com?t=https%3A%2F%2Fbaike.baidu.com%2Fitem%2F%E5%91%BD%E4%BB%A4%E6%8F%90%E7%A4%BA%E7%AC%A6" target="_blank" rel="noopener">命令提示符</a>。windows上自带简单的<a href="https://link.jianshu.com?t=https%3A%2F%2Fbaike.baidu.com%2Fitem%2F%E6%96%87%E6%9C%AC%E8%BE%93%E5%87%BA" target="_blank" rel="noopener">文本输出</a>的原生态的<a href="https://link.jianshu.com?t=https%3A%2F%2Fbaike.baidu.com%2Fitem%2F%E5%91%BD%E4%BB%A4%E6%8F%90%E7%A4%BA%E7%AC%A6" target="_blank" rel="noopener">命令提示符</a>通常可以很好的工作，但交互性更好的诸如MinTTY这样的应用程序却可能出现故障——虽然通常都有应对方案。这就是为什么MinTTY不能完全替代windows自带的<a href="https://link.jianshu.com?t=https%3A%2F%2Fbaike.baidu.com%2Fitem%2F%E5%91%BD%E4%BB%A4%E6%8F%90%E7%A4%BA%E7%AC%A6" target="_blank" rel="noopener">命令提示符</a>。</p><p><a href="https://link.jianshu.com?t=https%3A%2F%2Fbaike.baidu.com%2Fitem%2FMinTTY%2F9579126%3Ffr%3Daladdin" target="_blank" rel="noopener">参考链接：百科</a></p></blockquote><ol><li>其他的配置</li></ol><p><img alt="其他配置" data-src="//orangesching.github.io/2021/04/29/版本控制工具/Git/二、Git安装与服务器搭建/其他配置.jpg" class="lazyload"></p><blockquote><p>认证管理器：<a href="https://link.jianshu.com?t=https%3A%2F%2Fgithub.com%2FMicrosoft%2FGit-Credential-Manager-for-Windows" target="_blank" rel="noopener">参考链接</a>就是Github的账号等认证机制</p><p>符号链接：<a href="https://link.jianshu.com?t=https%3A%2F%2Fgithub.com%2Fgit-for-windows%2Fgit%2Fwiki%2FSymbolic-Links" target="_blank" rel="noopener">参考</a>官方介绍<a href="https://link.jianshu.com?t=http%3A%2F%2Fblog.csdn.net%2Fu013777351%2Farticle%2Fdetails%2F50557260" target="_blank" rel="noopener">参考博文</a></p></blockquote><h2 id="CentOS安装"><a href="#CentOS安装" class="headerlink" title="CentOS安装"></a>CentOS安装</h2><h3 id="仓库安装"><a href="#仓库安装" class="headerlink" title="仓库安装"></a>仓库安装</h3><p>使用yum源仓库安装，安装方便，但缺点在于安装的版本不是最新版本且无法安装历史版本，可使用下面语句查看源仓库的版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum info git</span><br></pre></td></tr></table></figure><p><img alt="仓库版本" data-src="//orangesching.github.io/2021/04/29/版本控制工具/Git/二、Git安装与服务器搭建/image-20210427095620314.png" class="lazyload"></p><p>使用下述语句安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install git</span><br></pre></td></tr></table></figure><p>安装的git在<code>/usr/bin/git</code>下</p><h3 id="源码安装"><a href="#源码安装" class="headerlink" title="源码安装"></a>源码安装</h3><h4 id="源码安装依赖的依赖库安装"><a href="#源码安装依赖的依赖库安装" class="headerlink" title="源码安装依赖的依赖库安装"></a>源码安装依赖的依赖库安装</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum remove git -y</span><br><span class="line">yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel gcc perl-ExtUtils-MakeMaker -y</span><br></pre></td></tr></table></figure><h4 id="下载并解压源码"><a href="#下载并解压源码" class="headerlink" title="下载并解压源码"></a>下载并解压源码</h4><p><a href="https://mirrors.edge.kernel.org/pub/software/scm/git/找到最新版本的链接" target="_blank" rel="noopener">https://mirrors.edge.kernel.org/pub/software/scm/git/找到最新版本的链接</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/src/</span><br><span class="line">wget https://mirrors.edge.kernel.org/pub/software/scm/git/git-2.9.5.tar.gz</span><br><span class="line">tar zxvf git-2.9.5.tar.gz</span><br></pre></td></tr></table></figure><h4 id="配置安装路径，开始编译安装"><a href="#配置安装路径，开始编译安装" class="headerlink" title="配置安装路径，开始编译安装"></a>配置安装路径，开始编译安装</h4><p>安装路径为<code>/user/local/git</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd git-2.9.5</span><br><span class="line">./configure --prefix=/usr/local/git/</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><h4 id="添加到环境变量"><a href="#添加到环境变量" class="headerlink" title="添加到环境变量"></a>添加到环境变量</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/profile</span><br><span class="line">   i</span><br><span class="line">   文件末尾添加内容:export PATH="/usr/local/git/bin:$PATH"</span><br><span class="line">   :wq</span><br><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure><h4 id="查看是否安装成功（查看版本号）"><a href="#查看是否安装成功（查看版本号）" class="headerlink" title="查看是否安装成功（查看版本号）"></a>查看是否安装成功（查看版本号）</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git --version</span><br></pre></td></tr></table></figure><h4 id="将Git设置为默认路径，不然后面克隆时会报错"><a href="#将Git设置为默认路径，不然后面克隆时会报错" class="headerlink" title="将Git设置为默认路径，不然后面克隆时会报错"></a>将Git设置为默认路径，不然后面克隆时会报错</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ln -sf /usr/local/git/bin/git-upload-pack /bin/git-upload-pack</span><br><span class="line">ln -sf /usr/local/git/bin/git-receive-pack /bin/git-receive-pack</span><br></pre></td></tr></table></figure><h1 id="Git服务器搭建"><a href="#Git服务器搭建" class="headerlink" title="Git服务器搭建"></a>Git服务器搭建</h1><h2 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 添加git账户</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> adduser git</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改git的密码</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> passwd git</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 然后两次输入git的密码确认后</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看git是否安装成功</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> /home &amp;&amp; ls -al</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果已经有了git，那么表示成，参考如下：</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> drwxr-xr-x.  5 root root 4096 Apr  4 15:03 .</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> dr-xr-xr-x. 19 root root 4096 Apr  4 15:05 ..</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> drwx------  10 git  git  4096 Apr  4 00:26 git</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 默认还给我们分配一个名字叫git的组。</span></span><br></pre></td></tr></table></figure><h2 id="创建空仓库"><a href="#创建空仓库" class="headerlink" title="创建空仓库"></a>创建空仓库</h2><p>创建一个裸仓库，裸仓库没有工作区，因为服务器上的Git仓库纯粹是为了共享，所以不让用户直接登录到服务器上去改工作区，并且服务器上的Git仓库通常都以.git结尾。在仓库想放的文件夹下执行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">su git</span><br><span class="line">git init --bare learngit.git  </span><br><span class="line"># 若使用root执行上述命令，则使用以下命令把owner改为git</span><br><span class="line">chown git:git learngit.git</span><br></pre></td></tr></table></figure><h2 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h2><h3 id="手动管理"><a href="#手动管理" class="headerlink" title="手动管理"></a>手动管理</h3><h4 id="密码验证"><a href="#密码验证" class="headerlink" title="密码验证"></a>密码验证</h4><p>以上步骤完成后，就可以在客户端使用密码拉取服务器代码了，在客户端执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone git@IP地址:仓库路径</span><br><span class="line">如： git clone git@196.1.1.2:~/git/test.git</span><br></pre></td></tr></table></figure><p>当你第一次使用Git的clone或者push命令连接GitHub时，会得到一个警告：</p><p>这是因为Git使用SSH连接，而SSH连接在第一次验证GitHub服务器的Key时，需要你确认GitHub的Key的指纹信息是否真的来自GitHub的服务器，输入yes回车即可。</p><p><img alt="image-20210427150347039" data-src="//orangesching.github.io/2021/04/29/版本控制工具/Git/二、Git安装与服务器搭建/image-20210427150347039.png" class="lazyload"></p><p>Git会输出一个警告，告诉你已经把GitHub的Key添加到本机的一个信任列表里了：</p><p><code>Warning: Permanently added &#39;github.com&#39; (RSA) to the list of known hosts.</code></p><p>这个警告只会出现一次，后面的操作就不会有任何警告了。<br>如果你实在担心有人冒充GitHub服务器，输入yes前可以对照GitHub的RSA Key的指纹信息是否与SSH连接给出的一致</p><h4 id="SSH公钥验证"><a href="#SSH公钥验证" class="headerlink" title="SSH公钥验证"></a>SSH公钥验证</h4><h5 id="服务器打开RSA认证"><a href="#服务器打开RSA认证" class="headerlink" title="服务器打开RSA认证"></a>服务器打开RSA认证</h5><p>首先需要将<code>/etc/ssh/sshd_config</code>中将RSA认证打开，即：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RSAAuthentication yes     </span><br><span class="line">PubkeyAuthentication yes     </span><br><span class="line">AuthorizedKeysFile  .ssh/authorized_keys</span><br></pre></td></tr></table></figure><p>重启sshd服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart sshd.service</span><br></pre></td></tr></table></figure><p>这里我们可以看到公钥存放在<code>.ssh/authorized_keys</code>文件中。所以我们在<code>/home/git</code>下创建.ssh目录，然后创建<code>authorized_keys</code>文件，用于存公钥</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 切换到git账号，注意一定要切到这个用户，不然创建的文件要手动授权给这个用户</span></span><br><span class="line">su git</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入 git账户的主目录</span></span><br><span class="line">cd /home/git</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建.ssh的配置，如果此文件夹已经存在请忽略此步。</span></span><br><span class="line">mkdir .ssh</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入刚创建的.ssh目录并创建authorized_keys文件,此文件存放客户端远程访问的 ssh的公钥。</span></span><br><span class="line">cd /home/git/.ssh</span><br><span class="line">touch authorized_keys</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置权限，此步骤不能省略，而且权限值也不要改，不然会报错。</span></span><br><span class="line">chmod 700 /home/git/.ssh/</span><br><span class="line">chmod 600 /home/git/.ssh/authorized_keys</span><br></pre></td></tr></table></figure><h5 id="客户端创建ssh公钥私钥"><a href="#客户端创建ssh公钥私钥" class="headerlink" title="客户端创建ssh公钥私钥"></a>客户端创建ssh公钥私钥</h5><p><strong>查看是否有私钥</strong><br>检查是否已经拥有ssh公钥和私钥，进入用户的主目录：</p><ul><li>Windows系统：C:\Users\用户名</li><li>Linux系统：/home/用户名</li><li>Mac系统：/Users/用户名</li></ul><p>查看是否有<code>.ssh</code>文件夹，此文件夹下是否有如下几个文件：<code>id_rsa</code>、<code>id_rsa.pub</code>，<code>id_rsa.pub</code>即为需要用的私钥。若有则无需创建私钥，跳下一步</p><p><strong>创建私钥</strong></p><p>打开Shell（Windows下打开Git Bash），创建SSH Key：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</span><br></pre></td></tr></table></figure><p>一路三个回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码</p><p>创建成功后再次查看是否有私钥</p><h5 id="上传公钥"><a href="#上传公钥" class="headerlink" title="上传公钥"></a>上传公钥</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 切换到git账户</span></span><br><span class="line">su git</span><br><span class="line">cd /home/git/.ssh</span><br><span class="line"><span class="meta">#</span><span class="bash"> 上传公钥，选择公钥文件上传</span></span><br><span class="line">rz</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看一下.ssh目录是否有authorized_keys和刚上传的*.pub文件</span></span><br><span class="line">ls -al</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果有，那么进行下面的把*.pub文件中的内容添加到authorized_keys中. </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> &gt;&gt; 是在文件后面追加的意思，主要如果用其他编辑器，每个ssh的pub要单独一行，建议用cat命令方便简单。</span></span><br><span class="line">cat id_rsa.pub &gt;&gt; authorized_keys</span><br></pre></td></tr></table></figure><p>然后再次clone的时候，或者是之后push的时候，就不需要再输入密码了：</p><p><img alt="image-20210427155719466" data-src="//orangesching.github.io/2021/04/29/版本控制工具/Git/二、Git安装与服务器搭建/image-20210427155719466.png" class="lazyload"></p><h5 id="禁用git用户的shell登陆"><a href="#禁用git用户的shell登陆" class="headerlink" title="禁用git用户的shell登陆"></a>禁用git用户的shell登陆</h5><p>出于安全考虑，第二步创建的git用户不允许登录shell</p><ol><li>创建<code>git-shell-commands</code>目录</li></ol><p>给 <code>/home/git</code> 下面创建<code>git-shell-commands</code>目录，并把目录的拥有者设置为git账户。可以直接用git账号登录服务器终端操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ su git</span><br><span class="line">$ mkdir /home/git/git-shell-commands</span><br></pre></td></tr></table></figure><blockquote><p>此文件夹是git-shell用到的目录，需要我们手动创建，不然报错：fatal: Interactive git shell is not enabled. hint: ~/git-shell-commands should exist and have read and execute access.</p></blockquote><ol><li>修改<code>/etc/passwd</code>文件，修改</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/passwd</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 可以通过 vim的正则搜索快速定位到这行，  命名模式下  :/git:x</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 找到这句, 注意1000可能是别的数字</span></span><br><span class="line">git:x:1000:1000::/home/git:/bin/bash</span><br><span class="line"><span class="meta">#</span><span class="bash"> 改为：</span></span><br><span class="line">git:x:1000:1000::/home/git:/usr/local/git/bin/git-shell</span><br><span class="line"><span class="meta">#</span><span class="bash"> 注意修改后的路径为 git安装路径/bin/git-shell，若创建软链接可使用软链接</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 这句其实就是把git用户登录使用的shell从普通shell变更为git-shell</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 最好不要直接改，可以先复制一行，然后注释掉一行，修改一行，保留原始的，这就是经验</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> vim快捷键： 命令模式下：yy复制行， p 粘贴  0光标到行首 $到行尾 x删除一个字符  i进入插入模式 </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改完后退出保存：  esc进入命令模式， 输入：:wq!   保存退出。</span></span><br></pre></td></tr></table></figure><p>修改成功测试：</p><p>ssh登录，跳转到git-shell，不可执行shell指令</p><p><img alt="image-20210427165832161" data-src="//orangesching.github.io/2021/04/29/版本控制工具/Git/二、Git安装与服务器搭建/image-20210427165832161.png" class="lazyload"></p><p>git clone</p><p><img alt="image-20210427165954350" data-src="//orangesching.github.io/2021/04/29/版本控制工具/Git/二、Git安装与服务器搭建/image-20210427165954350.png" class="lazyload"></p><p>此时我们就不用担心客户端通过shell登录执行一些乱七八糟的操作了，只允许使用git-shell进行管理git的仓库</p><p>如果有其他小伙伴要连接git服务器，仅需要把他的公钥也添加到authorized_keys即可</p><h3 id="自动管理"><a href="#自动管理" class="headerlink" title="自动管理"></a>自动管理</h3><p>以下配置承接自本文：客户端创建SSH公钥私钥部分</p><h4 id="添加gitolite依赖包"><a href="#添加gitolite依赖包" class="headerlink" title="添加gitolite依赖包"></a>添加<code>gitolite</code>依赖包</h4><p>依赖<code>perl</code>包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install 'perl(Data::Dumper)'</span><br></pre></td></tr></table></figure><h4 id="清空服务器端配置的ssh的公钥"><a href="#清空服务器端配置的ssh的公钥" class="headerlink" title="清空服务器端配置的ssh的公钥"></a>清空服务器端配置的ssh的公钥</h4><p>确保：<code>~/.ssh/authorized_keys</code>文件是空的，或者不存在。如果已经存在，建议你把他改名即可，比如：authorized_keys.bak</p><h4 id="上传管理员客户端的ssh公钥"><a href="#上传管理员客户端的ssh公钥" class="headerlink" title="上传管理员客户端的ssh公钥"></a>上传管理员客户端的ssh公钥</h4><p>把你管理员电脑的ssh的<code>id_rsa.pub</code>文件拷贝到服务器的：<code>$HOME/YourName.pub</code></p><p>YourName可以自定义，最好根据不同伙伴的名字命名。</p><h4 id="安装配置gitolite"><a href="#安装配置gitolite" class="headerlink" title="安装配置gitolite"></a>安装配置gitolite</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 切换到git账号</span></span><br><span class="line">su git</span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入git主目录</span></span><br><span class="line">cd /home/git</span><br><span class="line"><span class="meta">#</span><span class="bash"> 下载gitolite的仓库</span></span><br><span class="line">git clone https://github.com/sitaramc/gitolite</span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建bin文件夹，必须！！！</span></span><br><span class="line">mkdir -p $HOME/bin</span><br><span class="line"><span class="meta">#</span><span class="bash"> 用下载下来的仓库中的insall执行安装操作，指向的目录就是上一命令行创建的目录</span></span><br><span class="line">./gitolite二进制/install -to $HOME/bin</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 把上传到服务器的 管理员的公钥setup到gitolite中，注意：YourName.pub改成你自己的文件名。</span></span><br><span class="line">~/bin/gitolite setup -pk ~/YourName.pub</span><br><span class="line"><span class="meta">#</span><span class="bash"> 此时安装配完成后，查看git主目录</span></span><br><span class="line">ls /home/git</span><br><span class="line"><span class="meta">#</span><span class="bash"> 以下为输出结果</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> drwxr-xr-x   7 git  git  4096 Apr  3 23:50 bin               <span class="comment"># 我们创建的存放gitolite二进制</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> drwxrwxr-x   6 git  git  4096 Apr  3 23:40 gitolite</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> drwx------   6 git  git  4096 Apr  3 23:52 .gitolite</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -rw-------   1 git  git  7130 Apr  3 23:52 .gitolite.rc</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -rw-------   1 git  git   398 Apr  3 23:39 malun.pub         <span class="comment"># 管理员的公钥</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> drwxrw----   3 git  git  4096 Apr  3 23:40 .pki</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -rw-------   1 git  git    19 Apr  4 00:26 projects.list     <span class="comment"># 仓库列表（gitolite自动创建）</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> drwx------   5 git  git  4096 Apr  4 00:26 repositories      <span class="comment"># 存放所有仓库文件夹</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> drwx------   2 git  git  4096 Apr  4 15:50 .ssh</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> repositories目录下已经有了两个git仓库了。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> .</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> |-- gitolite-admin.git    <span class="comment"># 管理配置权限的仓库</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> `-- testing.git           <span class="comment"># 测试仓库</span></span></span><br></pre></td></tr></table></figure><p>好了，到此位置，管理员就可以直接把默认的远程管理的仓库gitolite-admin直接clone到本地进行管理git服务了。</p><h4 id="管理员在本地管理和配置服务器端仓库"><a href="#管理员在本地管理和配置服务器端仓库" class="headerlink" title="管理员在本地管理和配置服务器端仓库"></a>管理员在本地管理和配置服务器端仓库</h4><p>下载服务器端的远程管理仓库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 下载远程管理仓库, 请把aicoder.com换成你自己服务器的域名或者ip</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> git@aicoder.com:gitolite-admin</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> gitolite-admin</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 目录结构如下：</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> .</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ├── conf                <span class="comment"># 配置文件夹</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> │   └── gitolite.conf   <span class="comment"># 配置权限的文件</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> └── keydir              <span class="comment"># 客户端的公钥文件夹，所有伙伴的公钥要放到此目录下</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">     └── malun.pub</span></span><br></pre></td></tr></table></figure><h4 id="gitolite的权限配置"><a href="#gitolite的权限配置" class="headerlink" title="gitolite的权限配置"></a>gitolite的权限配置</h4><ol><li><p>添加其他开发的小伙伴</p><p>把小伙伴的公钥发给管理员。管理员添加到<code>gitolite-admin</code>仓库的<code>keydir</code>目录下,注意  文件名字格式为<code>username.pub</code>,username就是配置权限时的用户名。</p></li><li><p>配置用户对仓库的读写权限</p><p>直接修改conf文件夹下的，gitolite.conf文件。简单解释下几个用法：</p><ul><li><code>repo</code>代表仓库的意思，如果新添加一个repo，代表服务端新建一个空仓库，仓库push到服务端后会自动创建。</li></ul></li></ol><ul><li><p><code>RW</code> 代表可读可写</p><ul><li><code>@all</code> 代表所有人。</li><li><p><code>master</code>和 <code>dev</code>代表分支</p><p>参考：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@admin = malun  </span><br><span class="line">@om = malun bcd  </span><br><span class="line">  </span><br><span class="line">repo gitolite-admin  </span><br><span class="line">    RW+     =   malun </span><br><span class="line">  </span><br><span class="line">repo testing  </span><br><span class="line">    RW+     =   @all  </span><br><span class="line">  </span><br><span class="line">repo om  </span><br><span class="line">    RW+     =   @admin  </span><br><span class="line">    RW+ master = @admin  </span><br><span class="line">    RW+ dev  =   @om</span><br></pre></td></tr></table></figure></li></ul></li></ul><ol><li><p>应用修改到服务器端</p><p>做好配置后，由管理员把修改push到服务器端，会自动处理</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git add conf</span><br><span class="line">git add keydir</span><br><span class="line">git commit -m "added foo, gave access to alice, bob, carol"</span><br><span class="line">git push</span><br></pre></td></tr></table></figure></li></ol><p>参考：</p><p><a href="https://www.cnblogs.com/fly_dragon/p/8718614.html" target="_blank" rel="noopener">https://www.cnblogs.com/fly_dragon/p/8718614.html</a></p><p><a href="https://blog.csdn.net/wave_1102/article/details/47779401?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-3.control&amp;dist_request_id=&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-3.control" target="_blank" rel="noopener">https://blog.csdn.net/wave_1102/article/details/47779401?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-3.control&amp;dist_request_id=&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-3.control</a></p>]]></content>
      
      
      <categories>
          
          <category> 版本控制工具 </category>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL安装与部署</title>
      <link href="/2021/04/28/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2/"/>
      <url>/2021/04/28/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="CentOS安装"><a href="#CentOS安装" class="headerlink" title="CentOS安装"></a>CentOS安装</h1><p>CentOS8安装mysql8</p><h2 id="安装MySQL"><a href="#安装MySQL" class="headerlink" title="安装MySQL"></a>安装MySQL</h2><h3 id="检查是否安装过"><a href="#检查是否安装过" class="headerlink" title="检查是否安装过"></a>检查是否安装过</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">systemctl status mysqld.service</span><br><span class="line"><span class="comment"># 输出Unit mysqld.service could not be found.</span></span><br><span class="line">find / -name my.cnf</span><br><span class="line"><span class="comment"># 输出为空</span></span><br></pre></td></tr></table></figure><p>若已安装过，或可能某步错误导致没走完整个步骤，见下面的卸载流程</p><h3 id="下载mysql源安装包"><a href="#下载mysql源安装包" class="headerlink" title="下载mysql源安装包"></a>下载mysql源安装包</h3><p>在这里找到与自己系统版本一致的安装包<a href="https://dev.mysql.com/downloads/repo/yum/" target="_blank" rel="noopener">https://dev.mysql.com/downloads/repo/yum/</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://dev.mysql.com/get/mysql80-community-release-el8-1.noarch.rpm</span><br></pre></td></tr></table></figure><blockquote><p>查看系统版本<code>uname -a</code></p><p><img alt="image-20210428185338553" data-src="//orangesching.github.io/2021/04/28/数据库/关系型数据库/MySQL安装与部署/image-20210428185338553.png" class="lazyload"></p><p>这里为8则选择Linux8</p></blockquote><h3 id="安装mysql源"><a href="#安装mysql源" class="headerlink" title="安装mysql源"></a>安装mysql源</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum localinstall  mysql80-community-release-el8-1.noarch.rpm</span><br></pre></td></tr></table></figure><h3 id="安装MySql"><a href="#安装MySql" class="headerlink" title="安装MySql"></a>安装MySql</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install mysql-community-server</span><br></pre></td></tr></table></figure><blockquote><p>出现以下报错的处理方式：</p><p><img alt="image-20210428184759491" data-src="//orangesching.github.io/2021/04/28/数据库/关系型数据库/MySQL安装与部署/image-20210428184759491.png" class="lazyload"></p><p>先执行 <code>yum module disable mysql</code><br>再执行<code>yum -y install mysql-community-server</code></p></blockquote><h3 id="卸载Yum-Repository"><a href="#卸载Yum-Repository" class="headerlink" title="卸载Yum Repository"></a>卸载Yum Repository</h3><p>于每次 yum 操作都会自动更新，需要把这个卸载掉</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y remove mysql80-community-release-el8-1.noarch.rpm</span><br></pre></td></tr></table></figure><h2 id="配置MySQL"><a href="#配置MySQL" class="headerlink" title="配置MySQL"></a>配置MySQL</h2><h3 id="查看MySQL状态"><a href="#查看MySQL状态" class="headerlink" title="查看MySQL状态"></a>查看MySQL状态</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status mysqld.service</span><br></pre></td></tr></table></figure><p>下图为关闭状态</p><p><img alt="image-20210429150517161" data-src="//orangesching.github.io/2021/04/28/数据库/关系型数据库/MySQL安装与部署/image-20210429150517161.png" class="lazyload"></p><h3 id="启动MySQL"><a href="#启动MySQL" class="headerlink" title="启动MySQL"></a>启动MySQL</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start mysqld.service</span><br></pre></td></tr></table></figure><h3 id="登录MySQL"><a href="#登录MySQL" class="headerlink" title="登录MySQL"></a>登录MySQL</h3><p>此时MySQL已经开始正常运行，不过想要登录MySQL还得先找出此时root用户的密码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep <span class="string">"password"</span> /var/<span class="built_in">log</span>/mysqld.log</span><br></pre></td></tr></table></figure><p><img alt="image-20210429155325491" data-src="//orangesching.github.io/2021/04/28/数据库/关系型数据库/MySQL安装与部署/image-20210429155325491.png" class="lazyload"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot –p  </span><br><span class="line"><span class="comment"># 输入上述查出来的随机密码</span></span><br></pre></td></tr></table></figure><h3 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a>修改密码</h3><p>密码设置必须包含大小写字母、数字和特殊字符，不然修改密码失败</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER USER <span class="string">'root'</span>@<span class="string">'localhost'</span> IDENTIFIED BY <span class="string">'密码'</span>;</span><br></pre></td></tr></table></figure><h3 id="开启远程访问"><a href="#开启远程访问" class="headerlink" title="开启远程访问"></a>开启远程访问</h3><h4 id="Mysql开启远程访问"><a href="#Mysql开启远程访问" class="headerlink" title="Mysql开启远程访问"></a>Mysql开启远程访问</h4><p>方式一：授权法</p><p>以下语句为允许某个IP使用root账号远程访问MySQL，若想使用root从任何主机连接到mysql服务器的话将IP替换为<code>%</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grant all privileges on *.* to <span class="string">'root'</span>@<span class="string">'192.168.1.64'</span> identified by <span class="string">'MySQL%57'</span> with grant option;</span><br></pre></td></tr></table></figure><p>方式二：改库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 登录数据库，输入密码后完成登录</span></span><br><span class="line">mysql -h localhost -u root -p </span><br><span class="line"><span class="comment"># 选择 mysql 库</span></span><br><span class="line">mysql&gt; use mysql;</span><br><span class="line"><span class="comment"># 查询连接配置</span></span><br><span class="line">mysql&gt; select user,host from user; </span><br><span class="line">+------------------+-----------+</span><br><span class="line">| user             | host      |</span><br><span class="line">+------------------+-----------+</span><br><span class="line">| mysql.infoschema | localhost |</span><br><span class="line">| mysql.session    | localhost |</span><br><span class="line">| mysql.sys        | localhost |</span><br><span class="line">| root             | localhost |</span><br><span class="line">+------------------+-----------+</span><br><span class="line">4 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置允许使用 root 账户进行远程登录</span></span><br><span class="line">mysql&gt; update user <span class="built_in">set</span> host=<span class="string">'%'</span> <span class="built_in">where</span> user=<span class="string">'root'</span>;</span><br><span class="line"><span class="comment"># 刷新设置</span></span><br><span class="line">mysql&gt; flush privileges;</span><br></pre></td></tr></table></figure><h4 id="阿里云设置（云服务器必做）"><a href="#阿里云设置（云服务器必做）" class="headerlink" title="阿里云设置（云服务器必做）"></a>阿里云设置（云服务器必做）</h4><p>在云服务器控制台中，配置安全组规则，添加3306入站规则</p><p><img alt="image-20210506101732952" data-src="//orangesching.github.io/2021/04/28/数据库/关系型数据库/MySQL安装与部署/image-20210506101732952.png" class="lazyload"></p><p><img alt="image-20210506101654792" data-src="//orangesching.github.io/2021/04/28/数据库/关系型数据库/MySQL安装与部署/image-20210506101654792.png" class="lazyload"></p><p><img alt="image-20210506101607704" data-src="//orangesching.github.io/2021/04/28/数据库/关系型数据库/MySQL安装与部署/image-20210506101607704.png" class="lazyload"></p><h4 id="防火墙添加端口（选做）"><a href="#防火墙添加端口（选做）" class="headerlink" title="防火墙添加端口（选做）"></a>防火墙添加端口（选做）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=3306/tcp --permanent</span><br></pre></td></tr></table></figure><p>若上述语句提示未打开防火墙，则打开再执行</p><blockquote><p>查看防火墙状态<br><code>systemctl status firewalld</code></p><p>打开/关闭防火墙<br><code>systemctl start firewalld</code><br><code>systemctl stop firewalld</code></p><p>重启防火墙<br><code>systemctl restart firewalld</code></p><p>查看防火墙某个端口是否开放<br><code>firewall-cmd --query-port=3306/tcp</code></p><p>开放防火墙端口3306<br><code>firewall-cmd --zone=public --add-port=3306/tcp --permanent</code><br>注意：开放端口后要重启防火墙生效</p><p>关闭防火墙端口<br><code>firewall-cmd --remove-port=3306/tcp --permanent</code></p></blockquote><h4 id="测试远程访问"><a href="#测试远程访问" class="headerlink" title="测试远程访问"></a>测试远程访问</h4><p>客户端使用下面语句远程连接</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -h localhost -u root -p</span><br></pre></td></tr></table></figure><p>若上述代码能连上，再使用可视化连接工具，如Navicat、WorkBench等，若可视化连接工具连接不上则为工具问题，与服务器配置无关。如：<a href="https://blog.csdn.net/CliffordR/article/details/89598087?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162026866116780255299561%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=162026866116780255299561&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-89598087.nonecase&amp;utm_term=navicat+mysql8" target="_blank" rel="noopener">Navicat连不上MYSQL问题</a></p><h3 id="配置开机自启动"><a href="#配置开机自启动" class="headerlink" title="配置开机自启动"></a>配置开机自启动</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> mysqld</span><br></pre></td></tr></table></figure><h3 id="修改字符集"><a href="#修改字符集" class="headerlink" title="修改字符集"></a>修改字符集</h3><p>修改配置文件my.cnf</p><ol><li><p>查找my.cnf所在目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -name my.cnf</span><br></pre></td></tr></table></figure><p><img alt="image-20210506140358592" data-src="//orangesching.github.io/2021/04/28/数据库/关系型数据库/MySQL安装与部署/image-20210506140358592.png" class="lazyload"></p></li><li><p>打开文件，新增以下四行代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[client]</span><br><span class="line">default-character-set=utf8</span><br><span class="line">character-set-server=utf8</span><br><span class="line">collation-server=utf8_general_ci</span><br></pre></td></tr></table></figure></li><li><p>保存my.cnf后，重启MySQL</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart mysqld.service</span><br></pre></td></tr></table></figure></li><li><p>登录MySQL，查看status，可以看到字符集编码已经成功修改为utf8</p><p><img alt="image-20210506140646199" data-src="//orangesching.github.io/2021/04/28/数据库/关系型数据库/MySQL安装与部署/image-20210506140646199.png" class="lazyload"></p></li></ol><h1 id="CentOS卸载"><a href="#CentOS卸载" class="headerlink" title="CentOS卸载"></a>CentOS卸载</h1><ol><li>快速删除</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum remove  mysql mysql-server mysql-libs mysql-server</span><br></pre></td></tr></table></figure><ol><li>查找残留文件</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa | grep -i mysql</span><br><span class="line"><span class="comment"># 将查询出来的文件删除</span></span><br><span class="line">yum remove mysql-community-common-5.7.20-1.el6.x86_64</span><br><span class="line"><span class="comment"># 删除残余目录</span></span><br><span class="line">whereis mysql</span><br><span class="line"><span class="comment"># mysql : /usr/lib64/mysql</span></span><br><span class="line">rm –rf /usr/lib64/mysql</span><br></pre></td></tr></table></figure><ol><li>删除依赖</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查找依赖 </span></span><br><span class="line">yum list installed | grep mysql</span><br><span class="line"><span class="comment"># 删除找到的依赖</span></span><br><span class="line">yum -y remove mysql-libs.x86_64</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> 关系型数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>版本控制系统概述</title>
      <link href="/2021/04/28/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E6%A6%82%E8%BF%B0/"/>
      <url>/2021/04/28/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="版本控制系统简述"><a href="#版本控制系统简述" class="headerlink" title="版本控制系统简述"></a>版本控制系统简述</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>写毕业论文时是否有过以下感受，改一点东西就备份下，最后你的文件夹如下：</p><p><img alt="image-20210506160003762" data-src="//orangesching.github.io/2021/04/28/版本控制工具/版本控制概述/OrangeBlog\source\_posts\版本控制工具\版本控制概述\image-20210506160003762.png" class="lazyload"></p><p>导师让你来来回回改，碰到坑的还有让你改回原版的情况，你想找回被删除的文字，但是已经记不清删除前保存在哪个文件里了，只好一个一个文件去找</p><p>一堆文件看着心烦又不敢删怕哪天要用</p><p>更要命的是，发给导师改的时候，自己也在改，最后还要自己手动合并，还可能漏</p><p>以上所述为手动版本控制的流程，未解决上述头疼的问题，版本控制系统出现了</p><h2 id="概念和作用"><a href="#概念和作用" class="headerlink" title="概念和作用"></a>概念和作用</h2><p><strong>版本控制系统</strong>能记录所有文件的所有版本，可以有效的追踪文件的变化，同时很容易回滚到之前某个版本的状态。</p><p>作用：</p><ul><li>备份文件：在服务器中保存代码，方便随时恢复</li><li>记录历史：追溯任意代码文件的任意一行在什么时间被什么人修改过</li><li>回到过去：让版本库中的任意一个文件恢复到任意一个历史版本</li><li>多端共享：多个终端都可以共享同一份代码</li><li>团队协作：方便团队协作开发，尽可能减少冲突代码不一致情况</li></ul><h1 id="常用术语"><a href="#常用术语" class="headerlink" title="常用术语"></a>常用术语</h1><h2 id="仓库（Repository）"><a href="#仓库（Repository）" class="headerlink" title="仓库（Repository）"></a>仓库（Repository）</h2><p>受版本控制的所有文件修订历史的共享数据库</p><h2 id="工作空间（Workspace"><a href="#工作空间（Workspace" class="headerlink" title="工作空间（Workspace)"></a>工作空间（Workspace)</h2><p>本地硬盘或Unix 用户帐户上编辑的文件副本</p><h2 id="工作树-区（Working-tree）"><a href="#工作树-区（Working-tree）" class="headerlink" title="工作树/区（Working tree）"></a>工作树/区（Working tree）</h2><p>工作区中包含了仓库的工作文件。您可以修改的内容和提交更改作为新的提交到仓库。</p><h2 id="签入（Checkin）"><a href="#签入（Checkin）" class="headerlink" title="签入（Checkin）"></a>签入（Checkin）</h2><p>将新版本复制回仓库</p><h2 id="签出（Checkout）"><a href="#签出（Checkout）" class="headerlink" title="签出（Checkout）"></a>签出（Checkout）</h2><p>从仓库中将文件的最新修订版本复制到工作空间</p><h2 id="提交（Commit）"><a href="#提交（Commit）" class="headerlink" title="提交（Commit）"></a>提交（Commit）</h2><p>对各自文件的工作副本做了更改，并将这些更改提交到仓库</p><h2 id="冲突（Conflict）"><a href="#冲突（Conflict）" class="headerlink" title="冲突（Conflict）"></a>冲突（Conflict）</h2><p>多人对同一文件的工作副本进行更改，并将这些更改提交到仓库</p><h2 id="合并（Merge）"><a href="#合并（Merge）" class="headerlink" title="合并（Merge）"></a>合并（Merge）</h2><p>将某分支上的更改联接到此主干或同为主干的另一个分支</p><h2 id="分支（Branch）"><a href="#分支（Branch）" class="headerlink" title="分支（Branch）"></a>分支（Branch）</h2><p>从主线上分离开的副本，默认分支叫master</p><h2 id="锁（Lock）"><a href="#锁（Lock）" class="headerlink" title="锁（Lock）"></a>锁（Lock）</h2><p>获得修改文件的专有权限。</p><h2 id="头（HEAD）"><a href="#头（HEAD）" class="headerlink" title="头（HEAD）"></a>头（HEAD）</h2><p>头是一个象征性的参考，最常用以指向当前选择的分支。</p><h2 id="修订（Revision）"><a href="#修订（Revision）" class="headerlink" title="修订（Revision）"></a>修订（Revision）</h2><p>表示代码的一个版本状态。Git通过用SHA1 hash算法表示的ID来标识不同的版本。</p><h2 id="标记（Tags）"><a href="#标记（Tags）" class="headerlink" title="标记（Tags）"></a>标记（Tags）</h2><p>标记指的是某个分支某个特定时间点的状态。通过标记，可以很方便的切换到标记时的状态。</p><h1 id="常见的版本控制器"><a href="#常见的版本控制器" class="headerlink" title="常见的版本控制器"></a>常见的版本控制器</h1><p>主流的版本控制器有如下这些：</p><ul><li><strong>Git</strong></li><li><strong>SVN</strong>（Subversion）</li><li><strong>CVS</strong>（Concurrent Versions System）</li><li><strong>VSS</strong>（Micorosoft Visual SourceSafe）</li><li><strong>TFS</strong>（Team Foundation Server）</li><li>Visual Studio Online</li></ul><p>版本控制产品非常的多（Perforce、Rational ClearCase、RCS（GNU Revision Control System）、Serena Dimention、SVK、BitKeeper、Monotone、Bazaar、Mercurial、SourceGear Vault），现在影响力最大且使用最广泛的是Git与SVN</p><p><img alt="img" data-src="//orangesching.github.io/2021/04/28/版本控制工具/版本控制概述/OrangeBlog\source\_posts\版本控制工具\版本控制概述\14795543-10c11b0579edd654.png" class="lazyload"></p><h2 id="CVS"><a href="#CVS" class="headerlink" title="CVS"></a>CVS</h2><p><code>CVS（Concurrent Versions System）</code>版本控制系统是一种GNU软件包，主要用于在多人开发环境下的源码的维护。<br> <code>CVS</code>用<code>Copy-Modify-Merge</code>(拷贝、修改、合并)变化表支持对文件的同时访问和修改。<br> <code>CVS</code>基于客户端/服务器的行为使其可容纳多个用户。<br> <code>CVS</code>作为最早的开源而且免费的集中式版本控制系统，直到现在还有不少人在用。</p><h2 id="SVN"><a href="#SVN" class="headerlink" title="SVN"></a>SVN</h2><p>由于<code>CVS</code>自身设计的问题，会造成提交文件不完整，版本库莫名其妙损坏的情况。<br> 同样是开源而且免费的<code>SVN</code>修正了<code>CVS</code>的一-些稳定性问题，是目前用得最多的集中式版本库控制系统。</p><h2 id="GIT"><a href="#GIT" class="headerlink" title="GIT"></a>GIT</h2><p><code>GIT（The stupid content tracker）</code>傻瓜内容跟踪器。<code>Linus Torvalds</code>这样介绍。是一款免费、开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。<br> 分布式相比于集中式的最大区别在于开发者可以提交到本地，每个开发者机器上都是一个完整的数据库。</p><h2 id="工具对比"><a href="#工具对比" class="headerlink" title="工具对比"></a>工具对比</h2><div class="table-container"><table><thead><tr><th>特性</th><th>CVS</th><th>SVN</th><th>GIT</th></tr></thead><tbody><tr><td>并发修改</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>并发提交</td><td>不支持</td><td>支持</td><td>支持</td></tr><tr><td>历史轨迹</td><td>不支持更名</td><td>支持更名</td><td>支持更名</td></tr><tr><td>分布式</td><td>不支持</td><td>不支持</td><td>支持</td></tr></tbody></table></div><h1 id="版本控制分类"><a href="#版本控制分类" class="headerlink" title="版本控制分类"></a>版本控制分类</h1><h2 id="本地版本控制"><a href="#本地版本控制" class="headerlink" title="本地版本控制"></a>本地版本控制</h2><p>记录文件每次的更新，可以对每个版本做一个快照，或是记录补丁文件，适合个人用，如RCS。</p><p><img alt="img" data-src="//orangesching.github.io/2021/04/28/版本控制工具/版本控制概述/OrangeBlog\source\_posts\版本控制工具\版本控制概述\05163110-c8a48b29015245b78dc0127429ef5213.png" class="lazyload"></p><h2 id="集中版本控制"><a href="#集中版本控制" class="headerlink" title="集中版本控制"></a>集中版本控制</h2><p>所有的版本数据都保存在服务器上，协同开发者从服务器上同步更新或上传自己的修改</p><p><img alt="img" data-src="//orangesching.github.io/2021/04/28/版本控制工具/版本控制概述/OrangeBlog\source\_posts\版本控制工具\版本控制概述\63651-20170904213634085-673206677.png" class="lazyload"></p><p>所有的版本数据都存在服务器上，用户的本地只有自己以前所同步的版本，如果不连网的话，用户就看不到历史版本，也无法切换版本验证问题，或在不同分支工作。而且，所有数据都保存在单一的服务器上，有很大的风险这个服务器会损坏，这样就会丢失所有的数据，当然可以定期备份。代表产品：SVN、CVS、VSS</p><h2 id="分布式版本控制"><a href="#分布式版本控制" class="headerlink" title="分布式版本控制"></a>分布式版本控制</h2><p>所有版本信息仓库全部同步到本地的每个用户，这样就可以在本地查看所有版本历史，可以离线在本地提交，只需在连网时push到相应的服务器或其他用户那里。由于每个用户那里保存的都是所有的版本数据，只要有一个用户的设备没有问题就可以恢复所有的数据，但这增加了本地存储空间的占用。</p><p><img alt="img" data-src="//orangesching.github.io/2021/04/28/版本控制工具/版本控制概述/OrangeBlog\source\_posts\版本控制工具\版本控制概述\63651-20170904214244944-1222535795.png" class="lazyload"></p><h2 id="集中式vs分布式"><a href="#集中式vs分布式" class="headerlink" title="集中式vs分布式"></a>集中式vs分布式</h2><p><img alt="img" data-src="https://upload-images.jianshu.io/upload_images/14795543-c002b4c1af4a3190.png?imageMogr2/auto-orient/strip|imageView2/2/w/900/format/webp" class="lazyload"></p><p>整理自：</p><p><a href="https://www.jianshu.com/p/35a73169ac4a" target="_blank" rel="noopener">https://www.jianshu.com/p/35a73169ac4a</a></p><p><a href="https://www.cnblogs.com/syp172654682/p/7689328.html" target="_blank" rel="noopener">https://www.cnblogs.com/syp172654682/p/7689328.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 版本控制工具 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>一、Git初识及简单使用</title>
      <link href="/2021/04/28/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7/Git/%E4%B8%80%E3%80%81Git%E5%88%9D%E8%AF%86%E5%8F%8A%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
      <url>/2021/04/28/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7/Git/%E4%B8%80%E3%80%81Git%E5%88%9D%E8%AF%86%E5%8F%8A%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Git简述"><a href="#Git简述" class="headerlink" title="Git简述"></a>Git简述</h1><p>Git是目前世界上最先进的分布式版本控制系统</p><p>Git是免费、开源的</p><p>最初Git是为辅助 Linux 内核开发的，来替代 BitKeeper</p><p><strong>优点：</strong></p><ul><li>适合分布式开发，强调个体。</li><li>公共服务器压力和数据量都不会太大。</li><li>速度快、灵活。</li><li>任意两个开发者之间可以很容易的解决冲突。</li><li>离线工作。</li></ul><p><strong>缺点：</strong></p><ul><li>模式上比SVN更加复杂。</li><li>不符合常规思维。</li><li>代码保密性差，一旦开发者把整个库克隆下来就可以完全公开所有代码和版本信息。</li></ul><h1 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h1><ol><li><p>新建文件夹，在文件夹内，执行<code>git init</code>初始化仓库</p><p><img alt="image-20210520111007057" data-src="//orangesching.github.io/2021/04/28/版本控制工具/Git/一、Git初识及简单使用/image-20210520111007057.png" class="lazyload"></p><p>执行后会创建隐藏文件<code>.git</code></p><p><img alt="image-20210520111103760" data-src="//orangesching.github.io/2021/04/28/版本控制工具/Git/一、Git初识及简单使用/image-20210520111103760.png" class="lazyload"></p></li><li><p>新建文件<code>readme.md</code>，内容随便输，执行<code>git status</code>查看状态为<code>untracked</code>(这个概念在Git基础中详述)</p><p><img alt="image-20210520111435054" data-src="//orangesching.github.io/2021/04/28/版本控制工具/Git/一、Git初识及简单使用/image-20210520111435054.png" class="lazyload"></p></li><li><p>执行<code>git add readme.md</code>提交到暂存区(这个概念在Git基础中详述)，执行<code>git status</code>查看状态为<code>staged</code></p><p><img alt="image-20210520111616020" data-src="//orangesching.github.io/2021/04/28/版本控制工具/Git/一、Git初识及简单使用/image-20210520111616020.png" class="lazyload"></p></li><li><p>执行<code>git commit -m &quot;创建readme&quot;</code>提交到资源库(这个概念在Git基础中详述)</p><p><img alt="image-20210520111908474" data-src="//orangesching.github.io/2021/04/28/版本控制工具/Git/一、Git初识及简单使用/image-20210520111908474.png" class="lazyload"></p></li><li><p>修改<code>readme.md</code>文件，随便改点，执行<code>git status</code>查看状态</p><p><img alt="image-20210520112045776" data-src="//orangesching.github.io/2021/04/28/版本控制工具/Git/一、Git初识及简单使用/image-20210520112045776.png" class="lazyload"></p></li><li><p>执行<code>git checkout readme.md</code>，撤销<code>readme.md</code>的修改</p><p><img alt="image-20210520112257870" data-src="//orangesching.github.io/2021/04/28/版本控制工具/Git/一、Git初识及简单使用/image-20210520112257870.png" class="lazyload"></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 版本控制工具 </category>
          
          <category> Git </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JDK安装与部署</title>
      <link href="/2021/04/28/Java/JDK%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2/"/>
      <url>/2021/04/28/Java/JDK%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="CentOS安装"><a href="#CentOS安装" class="headerlink" title="CentOS安装"></a>CentOS安装</h1><h2 id="下载JDK"><a href="#下载JDK" class="headerlink" title="下载JDK"></a>下载JDK</h2><p>可在Windows上下载linux tar.gz结尾的包，在再上传到服务器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://www.oracle.com/java/technologies/javase/javase-jdk8-downloads.html</span><br></pre></td></tr></table></figure><h2 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 创建文件夹</span><br><span class="line">cd /usr/local</span><br><span class="line">mkdir java</span><br><span class="line">cd java</span><br><span class="line"># 解压</span><br><span class="line">tar -zxvf</span><br><span class="line">cd jdk （解压后的文件夹名）</span><br><span class="line"># 查看JAVA_HOME路径</span><br><span class="line">pwd</span><br></pre></td></tr></table></figure><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 编辑配置，配置环境变量</span><br><span class="line">vi /etc/profile</span><br><span class="line">i</span><br><span class="line"># 添加以下内容</span><br><span class="line">export JAVA_HOME = jdk的主目录路径(上述pwd输出的日志)</span><br><span class="line">export PATH = $JAVA_HOME/bin:$PATH</span><br><span class="line">export CLASSPATH = .:$JAVA_HOME/lib</span><br><span class="line"># 内容结束</span><br><span class="line">:wq</span><br><span class="line"># 配置生效</span><br><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure><h2 id="验证安装"><a href="#验证安装" class="headerlink" title="验证安装"></a>验证安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure><h1 id="Windows安装"><a href="#Windows安装" class="headerlink" title="Windows安装"></a>Windows安装</h1>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java集合</title>
      <link href="/2021/02/19/Java/Java%E5%9F%BA%E7%A1%80/Java%E9%9B%86%E5%90%88/"/>
      <url>/2021/02/19/Java/Java%E5%9F%BA%E7%A1%80/Java%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组与集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java反射机制</title>
      <link href="/2021/02/19/Java/Java%E5%9F%BA%E7%A1%80/Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"/>
      <url>/2021/02/19/Java/Java%E5%9F%BA%E7%A1%80/Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="反射是什么？"><a href="#反射是什么？" class="headerlink" title="反射是什么？"></a>反射是什么？</h1><p>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。</p><p>反射就是把java类中的各种成分映射成一个个的Java对象，例如：一个类有：成员变量、方法、构造方法、包等等信息，利用反射技术可以对一个类进行解剖，把个个组成部分映射成一个个对象。</p><h2 id="Java反射机制主要功能"><a href="#Java反射机制主要功能" class="headerlink" title="Java反射机制主要功能"></a>Java反射机制主要功能</h2><ol><li>在运行时判断任意一个对象所属的类</li><li>在运行时构造任意一个类的对象</li><li>在运行时判断任意一个类所具有的成员变量和方法</li><li>在运行时调用任意一个对象的方法</li></ol><h2 id="对反射提供支持的类"><a href="#对反射提供支持的类" class="headerlink" title="对反射提供支持的类"></a>对反射提供支持的类</h2><ul><li>Class类：代表一个类，位于java.lang包下。</li><li>Field类：代表类的成员变量（成员变量也称为类的属性）。</li><li>Method类：代表类的方法。</li><li>Constructor类：代表类的构造方法。</li><li>Array类：提供了动态创建数组，以及访问数组的元素的静态方法。</li></ul><h2 id="反射的意义"><a href="#反射的意义" class="headerlink" title="反射的意义"></a>反射的意义</h2><p><strong>反射是框架设计的灵魂</strong></p><p>使用的前提条件：必须先得到代表的字节码的Class，Class类用于表示.class文件（字节码）</p><h1 id="反射使用"><a href="#反射使用" class="headerlink" title="反射使用"></a>反射使用</h1><h2 id="示例类：学生类"><a href="#示例类：学生类" class="headerlink" title="示例类：学生类"></a>示例类：学生类</h2><p>学生类 继承 人 实现 学习接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> rejection;</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Human</span> <span class="keyword">implements</span> <span class="title">Learn</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> grade;</span><br><span class="line">    <span class="keyword">public</span> String className;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> grade, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name, age);</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.grade = grade;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Student</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"这是个名叫"</span>+name+<span class="string">"的"</span>+grade+<span class="string">"年级学生"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"春眠不觉晓"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remember</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"记忆消息："</span>+message);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口：学习</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> rejection;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Learn</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">remember</span><span class="params">(String message)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>父类：人</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> rejection;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Human</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Human</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speak</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello, My name is "</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="获取Class对象"><a href="#获取Class对象" class="headerlink" title="获取Class对象"></a>获取Class对象</h2><p>三种方式：</p><ol><li><code>实例对象.getClass()</code>：因为Object类中的getClass方法、因为所有类都继承Object类。从而调用Object类来获取；<u>会先初始化静态块，接着执行非静态块的初始化，最后调用构造函数</u></li><li><code>类名.Class</code>：任何数据类型（包括基本数据类型）都有一个“静态”的class属性；<u>不会初始化的静态块，不会初始化参数，不会调用构造函数</u></li><li><code>Class.forName(&quot;全路径名&quot;)</code><strong>(常用)</strong>；<u>会初始化类静态块，但不会初始化非静态的代码块，也不调用构造函数</u></li></ol><blockquote><p>三种方式的区别</p><p>1 类名.class(也称类字面常量)  方式生成Class对象不会初始化的静态块，不会初始化参数，不会调用构造函数<br>3 Object.getClass()方式生成Class对象会先初始化静态块，接着执行非静态块的初始化，最后调用构造函数</p><p> 在运行期间，一个类/接口，只有一个Class对象产生。 </p><p>三种方式常用<strong>第三种</strong><br>第一种实例对象都有了还要反射干什么。<br>第二种需要导入类的包，依赖太强，不导包就抛编译错误。<br>第三种，一个字符串可以传入也可写在配置文件中等多种方法。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; getClassByThreeMethod(<span class="keyword">int</span> method)&#123;</span><br><span class="line">        <span class="keyword">switch</span> (method) &#123;</span><br><span class="line">            <span class="comment">// 实例对象.getClass()</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                Student student = <span class="keyword">new</span> Student(<span class="string">"Orange"</span>,<span class="number">1</span>,<span class="number">6</span>);</span><br><span class="line">                <span class="keyword">return</span> student.getClass();</span><br><span class="line">                </span><br><span class="line">            <span class="comment">// 类名.Class</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span> Student.class;</span><br><span class="line">                </span><br><span class="line">            <span class="comment">// Class.forName("全路径名")</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> Class.forName(<span class="string">"rejection.Student"</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;  <span class="comment">// 需处理ClassNotFoundException异常</span></span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="通过反射获取类信息"><a href="#通过反射获取类信息" class="headerlink" title="通过反射获取类信息"></a>通过反射获取类信息</h2><p><strong>获取类信息其实就是调用Class类中的方法</strong>，以下为class类中常见方法</p><div class="table-container"><table><thead><tr><th>获取类信息</th><th>方法</th><th>备注</th></tr></thead><tbody><tr><td>类名</td><td><code>public String getName()</code></td><td>获取类名</td></tr><tr><td>包</td><td><code>public Package getPackage()</code></td><td>获取所属包</td></tr><tr><td>父类</td><td><code>public Class&lt;? super T&gt; getSuperclass()</code></td><td>获取父类class</td></tr><tr><td>实现接口</td><td><code>public Class&lt;?&gt;[] getInterfaces()</code></td><td>获取实现接口class</td></tr><tr><td>构造方法们</td><td><code>Constructor[] getConstructors()</code></td><td>获取所有public的构造方法（不包含父类构造方法）</td></tr><tr><td>构造方法们</td><td><code>Constructor[] getDeclaredConstructors()</code></td><td>获取所有构造方法（忽略访问控制符，不包含父类构造方法）</td></tr><tr><td>构造方法</td><td><code>Constructor getConstructor(Class... parameterTypes)</code></td><td>获取某个构造方法（按参数类型定位，忽略访问控制符）</td></tr><tr><td>构造方法</td><td><code>Constructor getDeclaredConstructor(Class... parameterTypes)</code></td><td>获取某个构造方法（忽略访问控制符，无法获取父类构造方法）</td></tr><tr><td>成员变量们</td><td><code>Field[] getFields()</code></td><td>获取所有public的成员变量（包含父类属性）</td></tr><tr><td>成员变量们</td><td><code>Field[] getDeclaredFields()</code></td><td>获取所有成员变量（忽略访问控制符，不包含父类属性）</td></tr><tr><td>成员变量</td><td><code>Field[] getField(String name)</code></td><td>获取某个成员变量（按变量名定位）</td></tr><tr><td>成员变量</td><td><code>Field[] getDeclaredField(String name)</code></td><td>获取某个成员变量（忽略访问控制符，无法获取父类属性）</td></tr><tr><td>成员方法们</td><td><code>Method[] getMethods()</code></td><td>获取所有public的成员方法（包含父类方法）</td></tr><tr><td>成员方法们</td><td><code>Method[] getDeclaredMethods()</code></td><td>获取所有成员方法（忽略访问控制符，不包含父类方法）</td></tr><tr><td>成员方法</td><td><code>Method getMethod(String name, Class&lt;?&gt;... parameterTypes)</code></td><td>获取某个成员方法（按变量名和参数类型定位）</td></tr><tr><td>成员方法</td><td><code>Method getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes)</code></td><td>获取某个成员方法（忽略访问控制符，无法获取父类方法）</td></tr></tbody></table></div><p>示例，获取Student类的信息，整个Student可被拆解为以下部分存储在Class对象中供获取</p><p><img alt="拆解Student" data-src="//orangesching.github.io/2021/02/19/Java/Java基础/Java反射机制/image-20210219164148147.png" class="lazyload"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getClassMessage</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取所有方法并遍历</span></span><br><span class="line">    System.out.println(<span class="string">"获取所有public方法并遍历"</span>);</span><br><span class="line">    Method[] methods = clazz.getMethods();</span><br><span class="line">    <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">        System.out.println(method);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"获取所有声明方法并遍历（忽略访问修饰符）"</span>);</span><br><span class="line">    Method[] methods1 = clazz.getDeclaredMethods();</span><br><span class="line">    <span class="keyword">for</span> (Method method : methods1) &#123;</span><br><span class="line">        System.out.println(method);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取所有构造方法并遍历</span></span><br><span class="line">    System.out.println(<span class="string">"获取所有public构造方法并遍历"</span>);</span><br><span class="line">    Constructor&lt;?&gt;[] constrctors = clazz.getConstructors();</span><br><span class="line">    <span class="keyword">for</span> (Constructor constrctor : constrctors) &#123;</span><br><span class="line">        System.out.println(constrctor);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"获取所有声明构造方法并遍历（忽略访问修饰符）"</span>);</span><br><span class="line">    Constructor&lt;?&gt;[] constrctors1 = clazz.getDeclaredConstructors();</span><br><span class="line">    <span class="keyword">for</span> (Constructor constrctor : constrctors1) &#123;</span><br><span class="line">        System.out.println(constrctor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取父类并打印父类名</span></span><br><span class="line">    System.out.println(<span class="string">"获取父类并打印父类名"</span>);</span><br><span class="line">    Class&lt;?&gt; superClazz = clazz.getSuperclass();</span><br><span class="line">    System.out.println(superClazz.getName());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取所有声明的属性（忽略访问修饰符）</span></span><br><span class="line">    System.out.println(<span class="string">"获取public的属性"</span>);</span><br><span class="line">    Field[] declaredField = clazz.getFields();</span><br><span class="line">    <span class="keyword">for</span> (Field field : declaredField) &#123;</span><br><span class="line">        System.out.println(field);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"获取所有声明的属性（忽略访问修饰符）"</span>);</span><br><span class="line">    Field[] declaredField1 = clazz.getDeclaredFields();</span><br><span class="line">    <span class="keyword">for</span> (Field field : declaredField1) &#123;</span><br><span class="line">        System.out.println(field);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">获取所有public方法并遍历</span><br><span class="line">public void rejection.Student.read()</span><br><span class="line">public boolean rejection.Student.remember(java.lang.String)</span><br><span class="line">public void rejection.Human.speak()</span><br><span class="line">public final void java.lang.Object.wait() throws java.lang.InterruptedException</span><br><span class="line">public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException</span><br><span class="line">public final native void java.lang.Object.wait(long) throws java.lang.InterruptedException</span><br><span class="line">public boolean java.lang.Object.equals(java.lang.Object)</span><br><span class="line">public java.lang.String java.lang.Object.toString()</span><br><span class="line">public native int java.lang.Object.hashCode()</span><br><span class="line">public final native java.lang.Class java.lang.Object.getClass()</span><br><span class="line">public final native void java.lang.Object.notify()</span><br><span class="line">public final native void java.lang.Object.notifyAll()</span><br><span class="line">获取所有声明方法并遍历（忽略访问修饰符）</span><br><span class="line">public void rejection.Student.read()</span><br><span class="line">private void rejection.Student.show()</span><br><span class="line">public boolean rejection.Student.remember(java.lang.String)</span><br><span class="line">获取所有public构造方法并遍历</span><br><span class="line">public rejection.Student(java.lang.String,int,int)</span><br><span class="line">获取所有声明构造方法并遍历（忽略访问修饰符）</span><br><span class="line">public rejection.Student(java.lang.String,int,int)</span><br><span class="line">private rejection.Student(java.lang.String)</span><br><span class="line">获取父类并打印父类名</span><br><span class="line">rejection.Human</span><br><span class="line">获取public的属性</span><br><span class="line">public java.lang.String rejection.Student.className</span><br><span class="line">public java.lang.String rejection.Human.name</span><br><span class="line">获取所有声明的属性（忽略访问修饰符）</span><br><span class="line">private int rejection.Student.grade</span><br><span class="line">public java.lang.String rejection.Student.className</span><br></pre></td></tr></table></figure><h2 id="调用-修改所获取的类信息"><a href="#调用-修改所获取的类信息" class="headerlink" title="调用/修改所获取的类信息"></a>调用/修改所获取的类信息</h2><h3 id="Constructor"><a href="#Constructor" class="headerlink" title="Constructor"></a>Constructor</h3><p>使用Constructor调用构造方法相当于new</p><p><code>Constructor对象.newInstance(参数)</code></p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">clazz.getConstructor().newInstance(); // 调用无参构造方法</span><br><span class="line">等价于</span><br><span class="line">Student stu = new Student()</span><br></pre></td></tr></table></figure><p><strong>注意所有调用的前提是可访问的</strong></p><p>对于构造方法<code>private Student(String name)</code>可使用暴力访问来调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Constructor constructor = clazz.getDeclaredConstructor(String.class);</span><br><span class="line">constructor.setAccessible(true);  // 暴力设置为可访问然后调用</span><br><span class="line">constructor.newInstance(&quot;Orange&quot;)</span><br><span class="line">等价于</span><br><span class="line">Student stu = new Student(&quot;Orange&quot;)</span><br></pre></td></tr></table></figure><h3 id="Field"><a href="#Field" class="headerlink" title="Field"></a>Field</h3><p>使用Field中的set为成员变量赋值</p><p><code>Field对象.set(class对象, 值)</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 获取成员变量</span><br><span class="line">Field f = clazz.getField(&quot;className&quot;);</span><br><span class="line">//获取一个对象</span><br><span class="line">Object obj = clazz.getConstructor().newInstance();</span><br><span class="line">//为字段设置值</span><br><span class="line">f.set(obj, &quot;一年三班&quot;);</span><br><span class="line">//验证</span><br><span class="line">Student stu = (Student)obj;</span><br><span class="line">System.out.println(stu.className);</span><br></pre></td></tr></table></figure><p><strong>注意所有调用的前提是可访问的</strong></p><p>对于构造方法<code>private int grade</code>可使用暴力访问来修改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 获取成员变量</span><br><span class="line">Field f = clazz.getDeclaredField(&quot;grade&quot;);</span><br><span class="line">//获取一个对象</span><br><span class="line">Object obj = clazz.getConstructor().newInstance();</span><br><span class="line">//为字段设置值</span><br><span class="line">f.set(obj, 1);</span><br><span class="line">//验证</span><br><span class="line">Student stu = (Student)obj;</span><br><span class="line">System.out.println(stu.grade);</span><br></pre></td></tr></table></figure><h3 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 获取成员方法</span><br><span class="line">Method m = clazz.getMethod(&quot;remember&quot;, String.class);</span><br><span class="line">//实例化一个Student对象</span><br><span class="line">Object obj = clazz.getConstructor().newInstance();</span><br><span class="line">// 调用</span><br><span class="line">m.invoke(obj, &quot;Orange&quot;);</span><br></pre></td></tr></table></figure><p>特别地，当调用方法为静态方法时<code>invoke(null, 参数)</code></p><p><strong>同样注意所有调用的前提是可访问的，可使用修改访问信号来调用</strong></p><p>参考：<a href="https://blog.csdn.net/weixin_42724467/article/details/84311385?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.control&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.control" target="_blank" rel="noopener">https://blog.csdn.net/weixin_42724467/article/details/84311385?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.control&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.control</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 反射 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java泛型</title>
      <link href="/2021/02/19/Java/Java%E5%9F%BA%E7%A1%80/Java%E6%B3%9B%E5%9E%8B/"/>
      <url>/2021/02/19/Java/Java%E5%9F%BA%E7%A1%80/Java%E6%B3%9B%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="泛型概述"><a href="#泛型概述" class="headerlink" title="泛型概述"></a>泛型概述</h1><h2 id="什么是泛型"><a href="#什么是泛型" class="headerlink" title="什么是泛型"></a>什么是泛型</h2><p>泛型，即<strong>参数化类型</strong>，将类型由原来的具体的类型替换为参数形式变量，然后在使用/调用时传入具体的类型（类型实参）；也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。</p><p>泛型在面向对象编程及各种设计模式中有非常广泛的应用</p><h2 id="为什么需要泛型"><a href="#为什么需要泛型" class="headerlink" title="为什么需要泛型"></a>为什么需要泛型</h2><h3 id="保证类型的安全性"><a href="#保证类型的安全性" class="headerlink" title="保证类型的安全性"></a>保证类型的安全性</h3><p>以下述程序为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List arrayList = new ArrayList();</span><br><span class="line">arrayList.add(&quot;aaaa&quot;);</span><br><span class="line">arrayList.add(100);</span><br><span class="line"></span><br><span class="line">for(int i = 0; i&lt; arrayList.size();i++)&#123;</span><br><span class="line">    String item = (String)arrayList.get(i);</span><br><span class="line">    Log.d(&quot;泛型测试&quot;,&quot;item = &quot; + item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>毫无疑问，程序的运行结果会以崩溃结束：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String</span><br></pre></td></tr></table></figure><p>ArrayList可以存放任意类型，例子中添加了一个String类型，添加了一个Integer类型，再使用时都以String的方式使用，因此程序崩溃了。</p><p><strong>为了解决在编译阶段就能发现类似这样的问题并解决，泛型应运而生</strong></p><p>我们将第一行声明初始化list的代码更改一下，编译器会在编译阶段就能够帮我们发现类似这样的问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; arrayList = new ArrayList&lt;String&gt;();</span><br><span class="line">...</span><br><span class="line">//arrayList.add(100); 在编译阶段，编译器就会报错</span><br></pre></td></tr></table></figure><h3 id="避免不必要的装箱、拆箱操作，提高程序的性能"><a href="#避免不必要的装箱、拆箱操作，提高程序的性能" class="headerlink" title="避免不必要的装箱、拆箱操作，提高程序的性能"></a>避免不必要的装箱、拆箱操作，提高程序的性能</h3><p>泛型变量固定了类型，使用的时候就已经知道是值类型还是引用类型，可以避免不必要的装箱、拆箱操作</p><p>例如：</p><p>使用泛型之前，我们使用object代替。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">object a=1;//由于是object类型，会自动进行装箱操作。</span><br><span class="line"></span><br><span class="line">int b=(int)a;//强制转换，拆箱操作。当次数多了以后会影响程序的运行效率。</span><br></pre></td></tr></table></figure><p>使用泛型之后</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static T GetValue&lt;T&gt;(T a) &#123;</span><br><span class="line">　　return a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void Main() &#123;</span><br><span class="line">　　int b=GetValue&lt;int&gt;(1);//使用这个方法的时候已经指定了类型是int，所以不会有装箱和拆箱的操作。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="提高方法、算法的重用性"><a href="#提高方法、算法的重用性" class="headerlink" title="提高方法、算法的重用性"></a>提高方法、算法的重用性</h3><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p><strong>泛型只在编译阶段有效</strong>。看下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; stringArrayList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">List&lt;Integer&gt; integerArrayList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">Class classStringArrayList = stringArrayList.getClass();</span><br><span class="line">Class classIntegerArrayList = integerArrayList.getClass();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果：D/泛型测试: 类型相同</span></span><br><span class="line"><span class="keyword">if</span>(classStringArrayList.equals(classIntegerArrayList))&#123;</span><br><span class="line">    Log.d(<span class="string">"泛型测试"</span>,<span class="string">"类型相同"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的例子可以证明：<strong>在编译之后程序会采取去泛型化的措施</strong>。在编译过程中，正确检验泛型结果后，<u>会将泛型的相关信息擦出，并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法</u>。也就是说，泛型信息不会进入到运行时阶段。</p><p><strong>泛型类型在逻辑上看以看成是多个不同的类型，实际上都是相同的基本类型</strong></p><h1 id="泛型的使用"><a href="#泛型的使用" class="headerlink" title="泛型的使用"></a>泛型的使用</h1><p>泛型有三种使用方式，分别为：泛型类、泛型接口、泛型方法</p><h2 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h2><p>泛型类型用于类的定义中，被称为泛型类。通过泛型可以完成对一组类的操作对外开放相同的接口</p><p>最典型的就是各种容器类，如：List、Set、Map。</p><p>泛型类的最基本写法：</p><p><code>class 类名称 &lt;泛型标识&gt;</code></p><p>泛型标识符可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型</p><p>例：一个最普通的泛型类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在实例化泛型类时，必须指定T的具体类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericClass</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T t;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GenericClass</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.t = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.t = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化</span></span><br><span class="line"><span class="comment">//泛型的类型参数只能是类类型（包括自定义类），不能是简单类型</span></span><br><span class="line">GenericClass&lt;String&gt; genericClass = <span class="keyword">new</span> GenericClass&lt;String&gt;(<span class="string">"Orange"</span>);</span><br><span class="line">GenericClass&lt;Integer&gt; genericClass2 = <span class="keyword">new</span> GenericClass&lt;Integer&gt;(<span class="number">123</span>);</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：在使用泛型的时候如果传入泛型实参，则会根据传入的泛型实参做相应的限制，此时泛型才会起到本应起到的限制作用。如果不传入泛型类型实参的话，在泛型类中使用泛型的方法或成员变量定义的类型可以为任何的类型。</p><p>例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GenericClass genericClass = <span class="keyword">new</span> GenericClass(<span class="string">"orange"</span>);</span><br><span class="line">System.out.println(genericClass.get().getClass().getName());  <span class="comment">// 输出：java.lang.String</span></span><br><span class="line">genericClass.set(<span class="number">123</span>);</span><br><span class="line">System.out.println(genericClass.get().getClass().getName());  <span class="comment">// 输出：java.lang.Integer</span></span><br></pre></td></tr></table></figure><p> <strong>注意：</strong></p><ul><li>泛型的类型参数只能是类类型，不能是简单类型。</li><li>不能对确切的泛型类型使用instanceof操作。如下面的操作是非法的，编译时会出错。</li></ul><p>　　<code>if(ex_num instanceof Generic&lt;Number&gt;){ }</code></p><h2 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h2><p>泛型接口与泛型类的定义及使用基本相同</p><p>泛型接口的最基本写法：</p><p><code>interface 接口名称 &lt;泛型标识&gt;</code></p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个泛型接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GenericInterface</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">getMsg</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于实现泛型接口的类：</p><ul><li>未传入泛型实参时，与泛型类的定义相同，在声明类的时候，需将泛型的声明也一起加到类中；如果不声明泛型，如：<code>class FruitGenerator implements Generator&lt;T&gt;</code>，编译器会报错：<code>Unknown class</code></li><li>传入泛型实参时，则所有使用泛型的地方都要替换成传入的实参类型</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 未传入泛型实参时，申明类时要加入泛型声明</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GeneralClass</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">GenericInterface</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T msg;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GeneralClass</span> <span class="params">(T msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getMsg</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        System.out.println(<span class="string">"GeneralClass get message "</span> + msg);</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传入泛型实参时</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GeneralClass</span> <span class="keyword">implements</span> <span class="title">GenericInterface</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String msg = <span class="string">"orange"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMsg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"GeneralClass get message "</span> + msg);</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><p>泛型类，是在实例化类的时候指明泛型的具体类型；</p><p>泛型方法，是在调用方法的时候指明泛型的具体类型 </p><p>泛型方法的最基本写法：</p><p><code>访问控制符 &lt;泛型标识&gt; 返回类型 方法名(形参...)</code></p><ul><li>访问控制符 与 返回值中间的<code>泛型标识&lt;T&gt;</code>非常重要，可以理解为声明此方法为泛型方法。<u>只有声明了泛型标识<code>&lt;T&gt;</code>的方法才是泛型方法，泛型类中的使用了泛型的成员方法并不是泛型方法</u></li><li><code>泛型标识&lt;T&gt;</code>表明该方法将使用泛型类型T，此时才可以在方法中使用泛型类型T</li><li>如果静态方法要使用泛型的话，必须将静态方法也定义成泛型方法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericMethod</span>&lt;<span class="title">T</span>&gt;</span>&#123;     </span><br><span class="line">   <span class="keyword">private</span> T key;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Generic</span><span class="params">(T key)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.key = key;</span><br><span class="line">   &#125;</span><br><span class="line">      </span><br><span class="line">   <span class="comment">//虽然在方法中使用了泛型，但是这并不是一个泛型方法。只是类中一个普通的成员方法，只不过他的返回值是在声明泛型类已经声明过的泛型。</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> T <span class="title">getKey</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">   &#125;</span><br><span class="line">            </span><br><span class="line">   <span class="comment">//这也不是一个泛型方法，这就是一个普通的方法，只是使用了Generic&lt;Number&gt;这个泛型类做形参而已。</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showKeyValue1</span><span class="params">(Generic&lt;Number&gt; obj)</span></span>&#123;</span><br><span class="line">        Log.d(<span class="string">"泛型测试"</span>,<span class="string">"key value is "</span> + obj.getKey());</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="comment">//这也不是一个泛型方法，这也是一个普通的方法，只不过使用了泛型通配符?</span></span><br><span class="line">   <span class="comment">//同时这也印证了泛型通配符章节所描述的，?是一种类型实参，可以看做为Number等所有类的父类</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showKeyValue2</span><span class="params">(Generic&lt;?&gt; obj)</span></span>&#123;</span><br><span class="line">        Log.d(<span class="string">"泛型测试"</span>,<span class="string">"key value is "</span> + obj.getKey());</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 泛型方法</span></span><br><span class="line">   <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"GenericMethod print "</span> + t);</span><br><span class="line">   &#125;</span><br><span class="line">          </span><br><span class="line">      </span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 这个方法是有问题的，编译器会为我们提示错误信息："UnKnown class 'E' "</span></span><br><span class="line"><span class="comment">   * 虽然我们声明了&lt;T&gt;,也表明了这是一个可以处理泛型的类型的泛型方法。</span></span><br><span class="line"><span class="comment">   * 但是只声明了泛型类型T，并未声明泛型类型E，因此编译器并不知道该如何处理E这个类型 </span></span><br><span class="line"><span class="comment">   public &lt;T&gt; T showKeyName(Generic&lt;E&gt; container)&#123;</span></span><br><span class="line"><span class="comment">        ...</span></span><br><span class="line"><span class="comment">   &#125;</span></span><br><span class="line"><span class="comment">   * 这个方法也是有问题的，编译器会为我们提示错误信息："UnKnown class 'T' "</span></span><br><span class="line"><span class="comment">   * 对于编译器来说T这个类型并未项目中声明过，因此编译也不知道该如何编译这个类。</span></span><br><span class="line"><span class="comment">   * 所以这也不是一个正确的泛型方法声明</span></span><br><span class="line"><span class="comment">   public void showkey(T genericObj)&#123;</span></span><br><span class="line"><span class="comment">      ...</span></span><br><span class="line"><span class="comment">   &#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="类中的泛型方法"><a href="#类中的泛型方法" class="headerlink" title="类中的泛型方法"></a>类中的泛型方法</h3><p>当然这并不是泛型方法的全部，泛型方法可以出现杂任何地方和任何场景中使用。但是有一种情况是非常特殊的，当泛型方法出现在泛型类中时，我们再通过一个例子看一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenerateTest</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show_1</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">System.out.println(t.toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在泛型类中声明了一个泛型方法，使用泛型E，这种泛型E可以为任意类型。可以类型与T相同，也可以不同。</span></span><br><span class="line"><span class="comment">//由于泛型方法在声明的时候会声明泛型&lt;E&gt;，因此即使在泛型类中并未声明泛型，编译器也能够正确识别泛型方法中识别的泛型。</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">show_3</span><span class="params">(E t)</span></span>&#123;</span><br><span class="line">System.out.println(t.toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在泛型类中声明了一个泛型方法，使用泛型T，注意这个T是一种全新的类型，可以与泛型类中声明的T不是同一种类型。</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">show_2</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">System.out.println(t.toString());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="静态方法与泛型"><a href="#静态方法与泛型" class="headerlink" title="静态方法与泛型"></a>静态方法与泛型</h3><p>静态方法有一种情况需要注意一下，那就是在类中的静态方法使用泛型：<u>静态方法无法访问类上定义的泛型</u>；如果静态方法操作的引用数据类型不确定的时候，必须要将泛型定义在方法上。</p><p>即：如果静态方法要使用泛型的话，必须将静态方法也定义成泛型方法 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class StaticGenerator&lt;T&gt; &#123;</span><br><span class="line">    ....</span><br><span class="line">    ....</span><br><span class="line">    /**</span><br><span class="line">     * 如果在类中定义使用泛型的静态方法，需要添加额外的泛型声明（将这个方法定义成泛型方法）</span><br><span class="line">     * 即使静态方法要使用泛型类中已经声明过的泛型也不可以。</span><br><span class="line">     * 如：public static void show(T t)&#123;..&#125;,此时编译器会提示错误信息：</span><br><span class="line">          &quot;StaticGenerator cannot be refrenced from static context&quot;</span><br><span class="line">     */</span><br><span class="line">    public static &lt;T&gt; void show(T t)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="泛型方法总结"><a href="#泛型方法总结" class="headerlink" title="泛型方法总结"></a>泛型方法总结</h3><p>泛型方法能使方法独立于类而产生变化，以下是一个基本的指导原则：</p><p><u>无论何时，如果你能做到，你就该尽量使用泛型方法。也就是说，如果使用泛型方法将整个类泛型化，那么就应该使用泛型方法</u></p><h2 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符"></a>泛型通配符</h2><p><code>Ingeter</code>是<code>Number</code>的一个子类，前面验证过<code>Generic&lt;Ingeter&gt;</code>与<code>Generic&lt;Number&gt;</code>实际上是相同的一种基本类型。但在使用<code>Generic&lt;Number&gt;</code>作为形参的方法中，不能使用<code>Generic&lt;Ingeter&gt;</code>的实例传入，测试案例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void showKeyValue1(Generic&lt;Number&gt; obj)&#123;</span><br><span class="line">    Log.d(&quot;泛型测试&quot;,&quot;key value is &quot; + obj.getKey());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Generic&lt;Integer&gt; gInteger = new Generic&lt;Integer&gt;(123);</span><br><span class="line">Generic&lt;Number&gt; gNumber = new Generic&lt;Number&gt;(456);</span><br><span class="line"></span><br><span class="line">showKeyValue(gNumber);</span><br><span class="line"></span><br><span class="line">// showKeyValue这个方法编译器会为我们报错：Generic&lt;java.lang.Integer&gt; </span><br><span class="line">// cannot be applied to Generic&lt;java.lang.Number&gt;</span><br><span class="line">// showKeyValue(gInteger);</span><br></pre></td></tr></table></figure><p>通过提示信息我们可以看到<code>Generic&lt;Integer&gt;</code>不能被看作为<code>`Generic&lt;Number&gt;</code>的子类。由此可以看出:同一种泛型可以对应多个版本（因为参数类型是不确定的），不同版本的泛型类实例是不兼容的。</p><p>这时可使用类型通配符<code>?</code>表示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void showKeyValue1(Generic&lt;?&gt; obj)&#123;</span><br><span class="line">    Log.d(&quot;泛型测试&quot;,&quot;key value is &quot; + obj.getKey());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类型通配符一般是使用<code>?</code>代替具体的类型实参，注意了，此处<code>?</code>是类型实参，而不是类型形参 。此处的<code>?</code>和Number、String、Integer一样都是一种实际的类型，可以把<code>?</code>看成所有类型的父类。是一种真实的类型。</p><p>可以解决当具体类型不确定的时候，这个通配符就是<code>?</code>。当操作类型时，不需要使用类型的具体功能时，只使用Object类中的功能。那么可以用<code>?</code>通配符来表未知类型。</p><h2 id="泛型上下边界"><a href="#泛型上下边界" class="headerlink" title="泛型上下边界"></a>泛型上下边界</h2><p>在使用泛型的时候，我们还可以为传入的泛型类型实参进行上下边界的限制，如：</p><p>类型实参只准传入某种类型的父类<code>&lt;? super 类名&gt;</code></p><p>类型实参只准传入某种类型的子类<code>&lt;? extends 类名&gt;</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public void showKeyValue1(Generic&lt;? extends Number&gt; obj)&#123;</span><br><span class="line">    Log.d(&quot;泛型测试&quot;,&quot;key value is &quot; + obj.getKey());</span><br><span class="line">&#125;</span><br><span class="line">Generic&lt;String&gt; generic1 = new Generic&lt;String&gt;(&quot;11111&quot;);</span><br><span class="line">Generic&lt;Integer&gt; generic2 = new Generic&lt;Integer&gt;(2222);</span><br><span class="line">Generic&lt;Float&gt; generic3 = new Generic&lt;Float&gt;(2.4f);</span><br><span class="line">Generic&lt;Double&gt; generic4 = new Generic&lt;Double&gt;(2.56);</span><br><span class="line"></span><br><span class="line">//这一行代码编译器会提示错误，因为String类型并不是Number类型的子类</span><br><span class="line">//showKeyValue1(generic1);</span><br><span class="line"></span><br><span class="line">showKeyValue1(generic2);</span><br><span class="line">showKeyValue1(generic3);</span><br><span class="line">showKeyValue1(generic4);</span><br></pre></td></tr></table></figure><p>注意：在泛型方法中添加上下边界限制的时候，必须在权限声明与返回值之间的<t>上添加上下边界，即在泛型声明的时候添加</t></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//public &lt;T&gt; T showKeyName(Generic&lt;T extends Number&gt; container)，编译器会报错：&quot;Unexpected bound&quot;</span><br><span class="line">public &lt;T extends Number&gt; T showKeyName(Generic&lt;T&gt; container)&#123;</span><br><span class="line">    System.out.println(&quot;container key :&quot; + container.getKey());</span><br><span class="line">    T test = container.getKey();</span><br><span class="line">    return test;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的两个例子可以看出：泛型的上下边界添加，必须与泛型的声明在一起 。</p><p>转载整理至：<a href="https://blog.csdn.net/s10461/article/details/53941091" target="_blank" rel="noopener">https://blog.csdn.net/s10461/article/details/53941091</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 反射 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java程序的运行过程</title>
      <link href="/2021/02/19/Java/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/Java%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B/"/>
      <url>/2021/02/19/Java/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/Java%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p><img alt="类加载示意图" data-src="//orangesching.github.io/2021/02/19/Java/Java虚拟机/Java程序的运行过程/v2-4face8109e0d52ef5894c41c69e4ec6b_720w.jpg" class="lazyload"></p><p>首先我们了解一下JVM，什么是JVM，Java的虚拟机，java之所以能跨平台就是因为这个东西，你可以理解成一个进程，程序，只不过他的作用是用来跑你的代码的。上图是java的内存模型，我们关注的点，一个方法区，一个栈，一个堆，初学的时候老师不深入的话只告诉你java的内存分为堆和栈，易懂点吧！</p><p>假如你写了一段代码：Object o=new Object();</p><p>运行了起来！</p><p>首先JVM会启动，你的代码会编译成一个.class文件，然后被类加载器加载进jvm的内存中，你的类Object加载到方法区中，创建了Object类的class对象到堆中，注意这个不是new出来的对象，而是类的类型对象，每个类只有一个class对象，作为方法区类的数据结构的接口。jvm创建对象前，会先检查类是否加载，寻找类对应的class对象，若加载好，则为你的对象分配内存，初始化也就是代码:new Object()。</p><p>上面的流程就是你自己写好的代码扔给jvm去跑，跑完就over了，jvm关闭，你的程序也停止了。</p><p>为什么要讲这个呢？因为要理解反射必须知道它在什么场景下使用。</p><p>题主想想上面的程序对象是自己new的，程序相当于写死了给jvm去跑。假如一个服务器上突然遇到某个请求哦要用到某个类，哎呀但没加载进jvm，是不是要停下来自己写段代码，new一下，哦启动一下服务器，（脑残）！</p><p>  反射是什么呢？当我们的程序在运行时，需要动态的加载一些类这些类可能之前用不到所以不用加载到jvm，而是在运行时根据需要才加载，这样的好处对于服务器来说不言而喻，举个例子我们的项目底层有时是用mysql，有时用oracle，需要动态地根据实际情况加载驱动类，这个时候反射就有用了，假设 com.java.dbtest.myqlConnection，com.java.dbtest.oracleConnection这两个类我们要用，这时候我们的程序就写得比较动态化，通过Class tc = Class.forName(“com.java.dbtest.TestConnection”);通过类的全类名让jvm在服务器中找到并加载这个类，而如果是oracle则传入的参数就变成另一个了。这时候就可以看到反射的好处了，这个动态性就体现出java的特性了！举多个例子，大家如果接触过spring，会发现当你配置各种各样的bean时，是以配置文件的形式配置的，你需要用到哪些bean就配哪些，spring容器就会根据你的需求去动态加载，你的程序就能健壮地运行。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 类加载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2021/02/08/%E5%BC%80%E5%8F%91%E7%BB%8F%E9%AA%8C%E5%8F%8A%E5%8A%9F%E8%83%BD%E7%82%B9%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E5%99%A8/"/>
      <url>/2021/02/08/%E5%BC%80%E5%8F%91%E7%BB%8F%E9%AA%8C%E5%8F%8A%E5%8A%9F%E8%83%BD%E7%82%B9%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E5%99%A8/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>安全问题</title>
      <link href="/2021/02/08/%E5%BC%80%E5%8F%91%E7%BB%8F%E9%AA%8C%E5%8F%8A%E5%8A%9F%E8%83%BD%E7%82%B9%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/"/>
      <url>/2021/02/08/%E5%BC%80%E5%8F%91%E7%BB%8F%E9%AA%8C%E5%8F%8A%E5%8A%9F%E8%83%BD%E7%82%B9%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="地址暴露问题"><a href="#地址暴露问题" class="headerlink" title="地址暴露问题"></a>地址暴露问题</h1><h1 id="接口限流防刷"><a href="#接口限流防刷" class="headerlink" title="接口限流防刷"></a>接口限流防刷</h1><p><strong>常见的限流算法：</strong><br>最常用限流算法的就是使用令牌桶或者漏斗桶算法</p><p><strong>常见的实现方式：</strong><br>（1）在网关上做限流。比如在nginx上写lua脚本来实现<br>（2）在应用上做单机限流。使用诸如基于Guava的RateLimiter令牌桶的方式。<br>（3）在应用上做分布式限流。比如redisson提供了个基于redis的RateLimiter：<br><a href="https://github.com/redisson/redisson/wiki/6.-distributed-objects#612-ratelimiter" target="_blank" rel="noopener">https://github.com/redisson/redisson/wiki/6.-distributed-objects#612-ratelimiter</a><br>（4）如果是SpringCloud项目，可用的就更多了，比如SpringCloud Gateway，Sentinel等等。</p><h1 id="验证码"><a href="#验证码" class="headerlink" title="验证码"></a>验证码</h1>]]></content>
      
      
      <categories>
          
          <category> 开发经验及功能点开发记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>秒杀功能开发</title>
      <link href="/2021/02/08/%E5%BC%80%E5%8F%91%E7%BB%8F%E9%AA%8C%E5%8F%8A%E5%8A%9F%E8%83%BD%E7%82%B9%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/%E7%A7%92%E6%9D%80/"/>
      <url>/2021/02/08/%E5%BC%80%E5%8F%91%E7%BB%8F%E9%AA%8C%E5%8F%8A%E5%8A%9F%E8%83%BD%E7%82%B9%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/%E7%A7%92%E6%9D%80/</url>
      
        <content type="html"><![CDATA[<h1 id="问题点"><a href="#问题点" class="headerlink" title="问题点"></a>问题点</h1><p><strong>1. 如何保证不卖超</strong><br>有两种情况可能会导致卖超：（1）一个用户同时发出了多个请求，如果库存足够，没加限制，用户就可以下多个订单。（2）减库存的sql上没有加库存数量的判断，并发的时候也会导致把库存减成负数。<br>我们的解决办法：<br>对于（1）：前端加验证码，防止用户同时发出多个请求，在后端的miaosha_order表中，对user_id和goods_id加唯一索引，确保一个用户对一个商品绝对不会生成两个订单。<br>对于（2）：我们的减库存的sql上应该加上库存数量的判断：<br><img alt="图片描述" data-src="//orangesching.github.io/2021/02/08/开发经验及功能点开发记录/秒杀/OrangeBlog\source\_posts\开发经验及功能点开发记录\秒杀\601cf23e09085e3607000140.png" class="lazyload"><br>数据库更新记录的时候会加锁，实际上是串行的执行update的，因此绝对不会卖超！</p><p><strong>2. Redis中的库存如何与DB中的库存保持一致？</strong><br>Redis中的数量不是库存，它的作用仅仅时候只是为了阻挡多余的请求透传到db，起到一个保护DB的作用。因为秒杀商品的数量是有限的，比如只有10个，让1万个请求去访问DB是没有意义的，因为最多只有10个请求会下单成功，剩余的9990个请求都是无效的，是可以不用去访问db而直接失败的。<br>因此，这是一个伪问题，我们是不需要保持一致的。</p><p><strong>3. Redis预减成功，DB扣减库存失败怎么办？</strong><br>两大类情况可导致redis预减成功而DB扣减失败：<br>（1） 如果一个用户发出了多个请求（不管何种手段），而这些所有的请求比所有其他用的请求都更快的到达了服务器，这个时候如果库存足够，就会出现redis预减多次，而只能下单成功一次（前提是：这个用户的多个请求比网站的其他用户的请求都更快的到达服务器，这在网络环境不可知的情况下，基本不可能）<br>（2） 还有就是在生成订单的过程中发生了不可预料的异常，也会导致redis扣减成功，而db扣减失败（如果是DB出现了异常，可能所有的订单都无法生成，但是只要存在redis预减，活动就可以正常结束）<br>因此，在初始化的时候，redis中的数量可以多于db的库存数量。<br>出现这种情况的后果是什么？<br>（1） 对用户而言，秒杀不中是正常现象，秒杀中才是意外，单个用户能否秒杀中本来就是小概率事件，出现这种情况对用户而言是没有任何影响的。<br>（2） 对商户而言，本来就是为了做活动拉流量拉人气的，卖不完还可以省一部分费用，但是活动还是正常参与了，也是没有任何影响<br>（3） 对网站而言，网站最重要的是用户体验，只要网站不崩，用户不骂娘，对网站也没有任何影响。<br>所以，卖不完是完全允许的，但是卖超是绝对不允许的！卖超的这部分钱商家是不会出的，需要网站自己来出。</p><p><strong>4. 为什么Redis中的数量会减成负数？</strong><br><img alt="图片描述" data-src="//orangesching.github.io/2021/02/08/开发经验及功能点开发记录/秒杀/OrangeBlog\source\_posts\开发经验及功能点开发记录\秒杀\601cf263091ad06a08190181.png" class="lazyload"><br>假如redis中的数量是1，这个时候同时过来100个请求，大家一起去执行decr,数量就会减成-99，这是正常的。</p><p><strong>5. 为什么要单独维护一个秒杀结束的标志？</strong><br>（1） 前面也提过，所有的秒杀相关的接口都要加上活动是否结束的标志，如果结束就直接返回了，包括轮询的接口，防止一直轮询没法结束。<br>（2） 管理后台也可以手动的更改这个标志，防止出现活动开始以后就没法结束这种意外的发生。</p><p><strong>6. 如果用户秒杀成成功了，但是没有付款怎么办？</strong><br>一般网站都会有下单30分钟不支付订单自动取消这样的操作，此时就需要把库存再加回去，因此又叫回仓。<br>可以在创建订单以后，把订单写入到延迟队列里面（RabbitMQ、RocketMQ都支持），如果在有效期之内用户做了付款，则从队列删除，否则等延迟队列数据出队的时候，再去查询数据库订单的状态，如果是未支付则需要回仓。回仓无非就是重置redis和mysql的数据，包括一些秒杀结束的状态等等。</p>]]></content>
      
      
      <categories>
          
          <category> 开发经验及功能点开发记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 秒杀 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>登录功能开发</title>
      <link href="/2021/02/08/%E5%BC%80%E5%8F%91%E7%BB%8F%E9%AA%8C%E5%8F%8A%E5%8A%9F%E8%83%BD%E7%82%B9%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/%E7%99%BB%E5%BD%95/"/>
      <url>/2021/02/08/%E5%BC%80%E5%8F%91%E7%BB%8F%E9%AA%8C%E5%8F%8A%E5%8A%9F%E8%83%BD%E7%82%B9%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/%E7%99%BB%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Token、Cookie管理问题"><a href="#Token、Cookie管理问题" class="headerlink" title="Token、Cookie管理问题"></a>Token、Cookie管理问题</h1><h1 id="密码安全性问题"><a href="#密码安全性问题" class="headerlink" title="密码安全性问题"></a>密码安全性问题</h1><h2 id="方案一：两次MD5加密法"><a href="#方案一：两次MD5加密法" class="headerlink" title="方案一：两次MD5加密法"></a>方案一：两次MD5加密法</h2><p>第一次加密在前端，第二次加密在后端，存入数据库的密码为两次MD5加密后的密码</p><h2 id="方案二：使用HTTPS"><a href="#方案二：使用HTTPS" class="headerlink" title="方案二：使用HTTPS"></a>方案二：使用HTTPS</h2><h2 id="方案三：使用浏览器插件"><a href="#方案三：使用浏览器插件" class="headerlink" title="方案三：使用浏览器插件"></a>方案三：使用浏览器插件</h2><p>如：ActiveX、网银安全控件等</p>]]></content>
      
      
      <categories>
          
          <category> 开发经验及功能点开发记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 登录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库ID生成算法——雪花算法snowflake</title>
      <link href="/2021/01/25/Java/Java%E5%BA%94%E7%94%A8/%E6%95%B0%E6%8D%AE%E5%BA%93ID%E7%94%9F%E6%88%90%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95snowflake/"/>
      <url>/2021/01/25/Java/Java%E5%BA%94%E7%94%A8/%E6%95%B0%E6%8D%AE%E5%BA%93ID%E7%94%9F%E6%88%90%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95snowflake/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Java应用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>踩坑记录</title>
      <link href="/2021/01/04/Java/JavaWeb/JAVA%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93/MyBatis-plus/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"/>
      <url>/2021/01/04/Java/JavaWeb/JAVA%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93/MyBatis-plus/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="映射为NULL的问题"><a href="#映射为NULL的问题" class="headerlink" title="映射为NULL的问题"></a>映射为NULL的问题</h1><ol><li>数据库为下划线命名例如：<code>enable_type</code>，当<code>MyBatis-plus</code>设置了<code>map-underscore-to-camel-case: true</code>时，JAVA对象应命名为<code>enableType</code>，否则会映射不到</li><li>当<code>MyBatis-plus</code>设置了<code>type-enums-package:</code>时，会自动映射到枚举类，当枚举类的值为<code>Integer</code>，但数据库该字段的类型为<code>Tinyint(1)</code>时，会映射失败。因为java在获取<code>Tinyint(1)</code>类型的表对象时会转化为<code>Boolean</code>。可将该字段类型改为<code>Tinyint(4)</code>，或将枚举类型的值改为<code>Boolean</code></li></ol>]]></content>
      
      
      <categories>
          
          <category> JavaWeb </category>
          
          <category> JAVA与数据库 </category>
          
          <category> MyBatis-plus </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis-plus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划——背包问题</title>
      <link href="/2020/12/22/%E7%AE%97%E6%B3%95/%E4%BC%A0%E7%BB%9F%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E2%80%94%E2%80%94%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
      <url>/2020/12/22/%E7%AE%97%E6%B3%95/%E4%BC%A0%E7%BB%9F%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E2%80%94%E2%80%94%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="0-1背包"><a href="#0-1背包" class="headerlink" title="0/1背包"></a>0/1背包</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p><strong>有n个不同物品，它们有各自的体积和价值，现有给定容量的背包，如何让背包里装入的物品具有最大的价值总和？</strong></p><p>为方便讲解和理解，下面讲述的例子均先用具体的数字代入，即：eg：number＝4，capacity＝8</p><div class="table-container"><table><thead><tr><th>i(物品编号)</th><th>1</th><th>2</th><th>3</th><th>4</th></tr></thead><tbody><tr><td>w(体积)</td><td>2</td><td>3</td><td>4</td><td>5</td></tr><tr><td>v(价值)</td><td>3</td><td>4</td><td>5</td><td>6</td></tr></tbody></table></div><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>根据动态规划解题步骤（问题抽象化、建立模型、寻找约束条件、判断是否满足最优性原理、找大问题与小问题的递推关系式、填表、寻找解组成）找出01背包问题的最优解以及解组成，然后编写代码实现。</p><p>在解决问题之前，为描述方便，首先定义一些变量：<strong>Vi表示第 i 个物品的价值，Wi表示第 i 个物品的体积，定义V(i,j)：当前背包容量 j，前 i 个物品最佳组合对应的价值</strong>，同时背包问题抽象化（X1，X2，…，Xn，其中 Xi 取0或1，表示第 i 个物品选或不选）。</p><p><em>1、建立模型，即求max(V1X1+V2X2+…+VnXn)；</em></p><p><em>2、寻找约束条件，W1X1+W2X2+…+WnXn&lt;capacity；</em></p><p><em>3、寻找递推关系式，面对当前商品有两种可能性：</em></p><ul><li><strong>包的容量比该商品体积小，装不下，此时的价值与前i-1个的价值是一样的，即V(i,j)=V(i-1,j)；</strong></li><li><strong>还有足够的容量可以装该商品，但装了也不一定达到当前最优价值，所以在装与不装之间选择最优的一个，即V(i,j)=max｛V(i-1,j)，V(i-1,j-w(i))+v(i)｝。</strong></li></ul><hr><p>其中V(i-1,j)表示不装，V(i-1,j-w(i))+v(i) 表示装了第i个商品，背包容量减少w(i)，但价值增加了v(i)；</p><p>由此可以得出递推关系式：</p><ul><li>j&lt;w(i) V(i,j)=V(i-1,j)</li><li>j&gt;=w(i) V(i,j)=max｛V(i-1,j)，V(i-1,j-w(i))+v(i)｝</li></ul><hr><p>这里需要解释一下，为什么能装的情况下，需要这样求解（这才是本问题的关键所在！）：</p><p>可以这么理解，<strong>如果要到达V(i,j)这一个状态有几种方式</strong>？</p><p><strong>肯定是两种，第一种是第i件商品没有装进去，第二种是第i件商品装进去了</strong>。没有装进去很好理解，就是V(i-1,j)；装进去了怎么理解呢？如果装进去第i件商品，那么装入之前是什么状态，肯定是V(i-1,j-w(i))。由于最优性原理（上文讲到），V(i-1,j-w(i))就是前面决策造成的一种状态，后面的决策就要构成最优策略。两种情况进行比较，得出最优。</p><p>4、填表，首先初始化边界条件，V(0,j)=V(i,0)=0；</p><p><img alt="示意图" data-src="//orangesching.github.io/2020/12/22/算法/传统算法/动态规划——背包问题/20190810165633366.png" class="lazyload"></p><p>然后一行一行的填表：</p><ul><li>如，i=1，j=1，w(1)=2，v(1)=3，有j&lt;w(1)，故V(1,1)=V(1-1,1)=0；</li><li>又如i=1，j=2，w(1)=2，v(1)=3，有j=w(1),故V(1,2)=max｛<br>V(1-1,2)，V(1-1,2-w(1))+v(1) ｝=max｛0，0+3｝=3；</li><li>如此下去，填到最后一个，i=4，j=8，w(4)=5，v(4)=6，有j&gt;w(4)，故V(4,8)=max｛<br>V(4-1,8)，V(4-1,8-w(4))+v(4) ｝=max｛9，4+6｝=10……</li></ul><hr><p>所以填完表如下图：</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190810165740701.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3NzY3NDU1,size_16,color_FFFFFF,t_70" class="lazyload"></p><p>5、表格填完，最优解即是V(number,capacity)=V(4,8)=10。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>为了和之前的动态规划图可以进行对比，尽管只有4个商品，但是我们创建的数组元素由5个。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> w[<span class="number">5</span>] = &#123; <span class="number">0</span> , <span class="number">2</span> , <span class="number">3</span> , <span class="number">4</span> , <span class="number">5</span> &#125;;<span class="comment">//商品的体积2、3、4、5</span></span><br><span class="line"><span class="keyword">int</span> v[<span class="number">5</span>] = &#123; <span class="number">0</span> , <span class="number">3</span> , <span class="number">4</span> , <span class="number">5</span> , <span class="number">6</span> &#125;;<span class="comment">//商品的价值3、4、5、6</span></span><br><span class="line"><span class="keyword">int</span> bagV = <span class="number">8</span>;        <span class="comment">//背包大小</span></span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">5</span>][<span class="number">9</span>] = &#123; &#123; <span class="number">0</span> &#125; &#125;;        <span class="comment">//动态规划表</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">4</span>; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= bagV; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (j &lt; w[i])</span><br><span class="line">dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - w[i]] + v[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//动态规划表的输出</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; dp[i][j] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415161718192021222324252627282930</span></span><br></pre></td></tr></table></figure><h2 id="最优解回溯"><a href="#最优解回溯" class="headerlink" title="最优解回溯"></a>最优解回溯</h2><p>通过上面的方法可以求出背包问题的最优解，但还不知道这个最优解由哪些商品组成，故要根据最优解回溯找出解的组成，根据填表的原理可以有如下的寻解方式：</p><ul><li>V(i,j)=V(i-1,j)时，说明没有选择第i 个商品，则回到V(i-1,j)；</li><li>V(i,j)=V(i-1,j-w(i))+v(i)时，说明装了第i个商品，该商品是最优解组成的一部分，随后我们得回到装该商品之前，即回到V(i-1,j-w(i))；</li><li>一直遍历到i＝0结束为止，所有解的组成都会找到。</li></ul><hr><p>就拿上面的例子来说吧：</p><ul><li>最优解为V(4,8)=10，而V(4,8)!=V(3,8)却有V(4,8)=V(3,8-w(4))+v(4)=V(3,3)+6=4+6=10，所以第4件商品被选中，并且回到V(3,8-w(4))=V(3,3)；</li><li>有V(3,3)=V(2,3)=4，所以第3件商品没被选择，回到V(2,3)；</li><li>而V(2,3)!=V(1,3)却有V(2,3)=V(1,3-w(2))+v(2)=V(1,0)+4=0+4=4，所以第2件商品被选中，并且回到V(1,3-w(2))=V(1,0)；</li><li>有V(1,0)=V(0,0)=0，所以第1件商品没被选择。</li></ul><hr><p><img alt="结果回溯" data-src="//orangesching.github.io/2020/12/22/算法/传统算法/动态规划——背包问题/20190810170345606.png" class="lazyload"></p><h1 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h1><h2 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h2><p><strong>有n种物品，每种物品都有无限个，它们有各自的体积和价值，现有给定容量的背包，如何让背包里装入的物品具有最大的价值总和？</strong></p><p>为方便讲解和理解，下面讲述的例子均先用具体的数字代入，即：eg：number＝4，capacity = 12</p><div class="table-container"><table><thead><tr><th>i(物品编号)</th><th>1</th><th>2</th><th>3</th><th>4</th></tr></thead><tbody><tr><td>w(体积)</td><td>2</td><td>3</td><td>4</td><td>5</td></tr><tr><td>v(价值)</td><td>1</td><td>2</td><td>2</td><td>4</td></tr></tbody></table></div><h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><p>根据动态规划解题步骤（问题抽象化、建立模型、寻找约束条件、判断是否满足最优性原理、找大问题与小问题的递推关系式、填表、寻找解组成）找出01背包问题的最优解以及解组成，然后编写代码实现。</p><p>在解决问题之前，为描述方便，首先定义一些变量：<strong>Vi表示第 i 个物品的价值，Wi表示第 i 个物品的体积，定义V(i,j)：当前背包容量 j，前 i 个物品最佳组合对应的价值</strong>，同时背包问题抽象化（k1，k2，…，kn，其中 ki 取任意整数，表示第 i 个物品选选几件）。</p><p>1、建立模型，即求max(k1V1X1+k2V2X2+…+knVnXn)；</p><p>2、寻找约束条件，k1W+k2W2+…+knWn&lt;=capacity；</p><p>3、寻找递推关系式，面对当前商品有需要选择的是：</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式</title>
      <link href="/2020/11/23/%E5%85%B6%E4%BB%96/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2020/11/23/%E5%85%B6%E4%BB%96/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="正则表达式语法"><a href="#正则表达式语法" class="headerlink" title="正则表达式语法"></a>正则表达式语法</h1><h2 id="匹配内容限定"><a href="#匹配内容限定" class="headerlink" title="匹配内容限定"></a>匹配内容限定</h2><h3 id="常见字符匹配"><a href="#常见字符匹配" class="headerlink" title="常见字符匹配"></a>常见字符匹配</h3><div class="table-container"><table><thead><tr><th>语法</th><th>说明</th><th>例子</th></tr></thead><tbody><tr><td><code>.</code></td><td>匹配除换行符 \n 之外的任何单字符</td><td></td></tr><tr><td><code>\w</code></td><td>匹配字母、数字、下划线</td><td></td></tr><tr><td><code>\s</code></td><td>匹配所有空白符，包括换行、空格、制表符、换页符等等</td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td><code>\d</code></td><td>匹配数字</td><td>匹配4位数字：<code>^\d\d\d\d$</code></td></tr><tr><td><code>\b</code></td><td>匹配单词的开始或结束</td><td>以abc开头的字符串：<code>\babc</code></td></tr><tr><td><code>^</code></td><td>匹配字符串的开头</td><td>以abc开头的字符串：<code>^abc</code></td></tr><tr><td><code>$</code></td><td>匹配字符串的结束</td><td></td></tr><tr><td><code>\u4e00-\u9fa5a</code></td><td>匹配中文</td><td></td></tr><tr><td><code>\f</code></td><td>匹配一个换页符</td><td></td></tr><tr><td><code>\n</code></td><td>匹配一个换行符</td><td></td></tr><tr><td><code>\r</code></td><td>匹配一个回车符</td><td></td></tr><tr><td><code>\t</code></td><td>匹配一个制表符</td><td></td></tr><tr><td><code>\v</code></td><td>匹配一个垂直制表符</td></tr></tbody></table></div><h3 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h3><p>当正则表达式语法中的符号真实出现需匹配时 可转义成普通的字符，即在要转义的字符前面加个斜杠<code>\</code><br>如：要匹配以<code>(ab)</code>开头的字符串：<code>^(\(ab\))*</code></p><h3 id="反义"><a href="#反义" class="headerlink" title="反义"></a>反义</h3><p>前面说到元字符的都是要匹配什么什么，当然如果你想反着来，不想匹配某些字符，正则也提供了一些常用的反义元字符：</p><div class="table-container"><table><thead><tr><th>语法</th><th>说明</th><th></th></tr></thead><tbody><tr><td><code>\W</code></td><td>匹配不是字母、数字、下划线、汉字的字符</td><td></td></tr><tr><td><code>\S</code></td><td>匹配非空白符，包括换行</td><td></td></tr><tr><td><code>\D</code></td><td>匹配任意非数字的字符</td><td></td></tr><tr><td><code>\B</code></td><td>匹配不是单词开头或结束的位置</td><td></td></tr><tr><td><code>[^x]</code></td><td>匹配除x以外的任意字符</td><td><code>[^aeiou]</code>匹配除aeiou几个字母外的任意字符</td></tr></tbody></table></div><h2 id="匹配内容位置限定"><a href="#匹配内容位置限定" class="headerlink" title="匹配内容位置限定"></a>匹配内容位置限定</h2><div class="table-container"><table><thead><tr><th>语法</th><th>说明</th><th>例子</th></tr></thead><tbody><tr><td><code>^</code></td><td>匹配字符串的开头</td><td>以abc开头的字符串：<code>^abc</code></td></tr><tr><td><code>$</code></td><td>匹配字符串的结束</td><td></td></tr><tr><td><code>\b</code></td><td>匹配单词的开始或结束</td><td>以abc开头的字符串：<code>\babc</code></td></tr><tr><td><code>\B</code></td><td>非单词边界匹配</td></tr></tbody></table></div><h2 id="匹配内容重复次数限定——限定符"><a href="#匹配内容重复次数限定——限定符" class="headerlink" title="匹配内容重复次数限定——限定符"></a>匹配内容重复次数限定——限定符</h2><p>匹配重复次数加在内容限定的后面，限定符作用在与他左边最近的一个字符，默认是贪婪匹配（尽可能多的匹配文字），在后面加上一个<code>?</code>就可实现非贪婪匹配</p><div class="table-container"><table><thead><tr><th>语法</th><th>说明</th><th>例子</th></tr></thead><tbody><tr><td><code>*</code></td><td>重复零次或更多次</td><td></td></tr><tr><td><code>+</code></td><td>重复一次或更多次</td><td></td></tr><tr><td><code>?</code></td><td>重复零次或一次</td><td></td></tr><tr><td><code>{n}</code></td><td>重复n次</td><td>匹配4位数字：<code>^\d{4}$</code></td></tr><tr><td><code>{n,}</code></td><td>重复n次或更多次</td><td></td></tr><tr><td><code>{n,m}</code></td><td>重复n到m次</td></tr></tbody></table></div><blockquote><p><strong>贪婪匹配</strong></p><p>当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能多的字符，这匹配方式叫做贪婪匹配。<br>特性：一次性读入整个字符串进行匹配，每当不匹配就舍弃最右边一个字符，继续匹配，依次匹配和舍弃（这种匹配-舍弃的方式也叫做回溯），直到匹配成功或者把整个字符串舍弃完为止，因此它是一种最大化的数据返回，能多不会少。</p><p><strong>懒惰匹配</strong></p><p>当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能少的字符，这匹配方式叫做懒惰匹配。<br>特性：从左到右，从字符串的最左边开始匹配，每次试图不读入字符匹配，匹配成功，则完成匹配，否则读入一个字符再匹配，依此循环（读入字符、匹配）直到匹配成功或者把字符串的字符匹配完为止。</p><p>如：<code>*?</code>、<code>+?</code>、<code>??</code>、<code>{n,m}?</code></p></blockquote><h2 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h2><p>正则表达式中用小括号<code>()</code>来做分组，也就是括号中的内容作为一个整体。</p><p>如：匹配字符串中包含0到多个ab开头：<code>^(ab)*</code></p><h2 id="条件或"><a href="#条件或" class="headerlink" title="条件或"></a>条件或</h2><p>正则用符号<code>|</code> 来表示或，也叫做分支条件，当满足正则里的分支条件的任何一种条件时，都会当成是匹配成功</p><p>例如：匹配一个联通的号码（130/131/132/155/156/185/186/145/176等号段）<br>           可写为<code>^(130|131|132|155|156|185|186|145|176)\d{8}$</code></p><h2 id="区间"><a href="#区间" class="headerlink" title="区间"></a>区间</h2><p>正则提供一个元字符中括号<code>[]</code>来表示区间条件。</p><p>例如：</p><ul><li>限定0到9 可以写成<code>[0-9]</code></li><li>限定A-Z 写成<code>[A-Z]</code></li><li>限定某些数字<code>[165]</code></li><li><code>^(130|131|132|155|156|185|186|145|176)\d{8}$</code>可写为<code>^((13[0-2])|(15[56])|(18[5-6])|145|176)\d{8}$</code></li></ul><h1 id="正则进阶知识点"><a href="#正则进阶知识点" class="headerlink" title="正则进阶知识点"></a>正则进阶知识点</h1><h2 id="零宽断言"><a href="#零宽断言" class="headerlink" title="零宽断言"></a>零宽断言</h2><blockquote><p>无论是零宽还是断言，听起来都古古怪怪的，<br>那先解释一下这两个词。</p></blockquote><ol><li>断言：俗话的断言就是“我断定什么什么”，而正则中的断言，就是说正则可以指明在指定的内容的前面或后面会出现满足指定规则的内容，<br>意思正则也可以像人类那样断定什么什么，比如”ss1aa2bb3”,正则可以用断言找出aa2前面有bb3，也可以找出aa2后面有ss1.</li><li>零宽：就是没有宽度，在正则中，断言只是匹配位置，不占字符，也就是说，匹配结果里是不会返回断言本身。</li></ol><p>意思是讲明白了，那他有什么用呢？<br>我们来举个栗子：<br>假设我们要用爬虫抓取csdn里的文章阅读量。通过查看源代码可以看到文章阅读量这个内容是这样的结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1   &quot;&lt;span class=&quot;read-count&quot;&gt;阅读数：641&lt;/span&gt;&quot;</span><br></pre></td></tr></table></figure><p>其中也就‘641’这个是变量，也就是说不同文章不同的值，当我们拿到这个字符串时，需要获得这里边的‘641’有很多种办法，但如果正则应该怎么匹配呢？</p><p>下面先来讲几种类型的断言：</p><ol><li>正向先行断言（正前瞻）：</li></ol><ul><li>语法：（?=pattern）</li><li>作用：匹配pattern表达式的前面内容，不返回本身。</li></ul><p>这样子说，还是一脸懵逼，好吧，回归刚才那个栗子，要取到阅读量，在正则表达式中就意味着要能匹配到‘&lt;/span&gt;’前面的数字内容<br>按照上所说的正向先行断言可以匹配表达式前面的内容，那意思就是:(?=&lt;/span&gt;) 就可以匹配到前面的内容了。<br>匹配什么内容呢？如果要所有内容那就是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span>   String reg=<span class="string">".+(?=&lt;/span&gt;)"</span>;</span><br><span class="line"> <span class="number">2</span></span><br><span class="line"> <span class="number">3</span>   String test = <span class="string">"&lt;span class=\"read-count\"&gt;阅读数：641&lt;/span&gt;"</span>;</span><br><span class="line"> <span class="number">4</span>   Pattern pattern = Pattern.compile(reg);</span><br><span class="line"> <span class="number">5</span>   Matcher mc=    pattern.matcher(test);</span><br><span class="line"> <span class="number">6</span>   <span class="keyword">while</span>(mc.find())&#123;</span><br><span class="line"> <span class="number">7</span>    System.out.println(<span class="string">"匹配结果："</span>)</span><br><span class="line"> <span class="number">8</span>    System.out.println(mc.group());</span><br><span class="line"> <span class="number">9</span>   &#125;</span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">11</span>   <span class="comment">//匹配结果：</span></span><br><span class="line"><span class="number">12</span>   <span class="comment">//&lt;span class="read-count"&gt;阅读数：641</span></span><br></pre></td></tr></table></figure><p>可是老哥我们要的只是前面的数字呀，那也简单咯，匹配数字 \d,那可以改成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>   String reg=<span class="string">"\\d+(?=&lt;/span&gt;)"</span>;</span><br><span class="line"><span class="number">2</span>   String test = <span class="string">"&lt;span class=\"read-count\"&gt;阅读数：641&lt;/span&gt;"</span>;</span><br><span class="line"><span class="number">3</span>   Pattern pattern = Pattern.compile(reg);</span><br><span class="line"><span class="number">4</span>   Matcher mc=    pattern.matcher(test);</span><br><span class="line"><span class="number">5</span>   <span class="keyword">while</span>(mc.find())&#123;</span><br><span class="line"><span class="number">6</span>     System.out.println(mc.group());</span><br><span class="line"><span class="number">7</span>   &#125;</span><br><span class="line"><span class="number">8</span>   <span class="comment">//匹配结果：</span></span><br><span class="line"><span class="number">9</span>   <span class="comment">//641</span></span><br></pre></td></tr></table></figure><p>大功告成！</p><p>\2. 正向后行断言（正后顾）:</p><ul><li>语法：（?&lt;=pattern）</li><li>作用：匹配pattern表达式的后面的内容，不返回本身。</li></ul><p>有先行就有后行，先行是匹配前面的内容，那后行就是匹配后面的内容啦。<br>上面的栗子，我们也可以用后行断言来处理.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span>   <span class="comment">//(?&lt;=&lt;span class="read-count"&gt;阅读数：)\d+</span></span><br><span class="line"> <span class="number">2</span>   String reg=<span class="string">"(?&lt;=&lt;span class=\"read-count\"&gt;阅读数：)\\d+"</span>;</span><br><span class="line"> <span class="number">3</span></span><br><span class="line"> <span class="number">4</span>   String test = <span class="string">"&lt;span class=\"read-count\"&gt;阅读数：641&lt;/span&gt;"</span>;</span><br><span class="line"> <span class="number">5</span>   Pattern pattern = Pattern.compile(reg);</span><br><span class="line"> <span class="number">6</span>   Matcher mc=    pattern.matcher(test);</span><br><span class="line"> <span class="number">7</span>        <span class="keyword">while</span>(mc.find())&#123;</span><br><span class="line"> <span class="number">8</span>          System.out.println(mc.group());</span><br><span class="line"> <span class="number">9</span>        &#125;</span><br><span class="line"><span class="number">10</span>   <span class="comment">//匹配结果：</span></span><br><span class="line"><span class="number">11</span>   <span class="comment">//641</span></span><br></pre></td></tr></table></figure><p>就这么简单。</p><p>\3. 负向先行断言（负前瞻）</p><ul><li>语法：(?!pattern)</li><li>作用：匹配非pattern表达式的前面内容，不返回本身。</li></ul><p>有正向也有负向，负向在这里其实就是非的意思。<br>举个栗子：比如有一句 “我爱祖国，我是祖国的花朵”<br>现在要找到不是’的花朵’前面的祖国<br>用正则就可以这样写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>   祖国(?!的花朵)</span><br></pre></td></tr></table></figure><p>\4. 负向后行断言（负后顾）</p><ul><li>语法：(?&lt;!pattern)</li><li>作用：匹配非pattern表达式的后面内容，不返回本身。</li></ul><h2 id="捕获和非捕获"><a href="#捕获和非捕获" class="headerlink" title="捕获和非捕获"></a>捕获和非捕获</h2><p>单纯说到捕获，他的意思是匹配表达式，但捕获通常和分组联系在一起，也就是“捕获组”</p><blockquote><p>捕获组：匹配子表达式的内容，把匹配结果保存到内存中中数字编号或显示命名的组里，以深度优先进行编号，之后可以通过序号或名称来使用这些匹配结果。</p></blockquote><p>而根据命名方式的不同，又可以分为两种组：</p><p>\1. 数字编号捕获组：<br>语法：(exp)<br>解释：从表达式左侧开始，每出现一个左括号和它对应的右括号之间的内容为一个分组，在分组中，第0组为整个表达式，第一组开始为分组。<br>比如固定电话的：020-85653333<br>他的正则表达式为：(0\d{2})-(\d{8})<br>按照左括号的顺序，这个表达式有如下分组：</p><p><img alt="img" data-src="https://pic4.zhimg.com/50/v2-fcb6eb2d9b164a269dd938fcd0a3554b_hd.jpg?source=1940ef5c" class="lazyload"><img alt="img" data-src="https://pic4.zhimg.com/80/v2-fcb6eb2d9b164a269dd938fcd0a3554b_720w.jpg?source=1940ef5c" class="lazyload"></p><p>我们用Java来验证一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span>   String test = <span class="string">"020-85653333"</span>;</span><br><span class="line"> <span class="number">2</span>        String reg=<span class="string">"(0\\d&#123;2&#125;)-(\\d&#123;8&#125;)"</span>;</span><br><span class="line"> <span class="number">3</span>        Pattern pattern = Pattern.compile(reg);</span><br><span class="line"> <span class="number">4</span>        Matcher mc= pattern.matcher(test);</span><br><span class="line"> <span class="number">5</span>        <span class="keyword">if</span>(mc.find())&#123;</span><br><span class="line"> <span class="number">6</span>          System.out.println(<span class="string">"分组的个数有："</span>+mc.groupCount());</span><br><span class="line"> <span class="number">7</span>            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=mc.groupCount();i++)&#123;</span><br><span class="line"> <span class="number">8</span>                System.out.println(<span class="string">"第"</span>+i+<span class="string">"个分组为："</span>+mc.group(i));</span><br><span class="line"> <span class="number">9</span>            &#125;</span><br><span class="line"><span class="number">10</span>        &#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>   分组的个数有：<span class="number">2</span></span><br><span class="line"><span class="number">2</span>   第<span class="number">0</span>个分组为：<span class="number">020</span>-<span class="number">85653333</span></span><br><span class="line"><span class="number">3</span>   第<span class="number">1</span>个分组为：<span class="number">020</span></span><br><span class="line"><span class="number">4</span>   第<span class="number">2</span>个分组为：<span class="number">85653333</span></span><br></pre></td></tr></table></figure><p>可见，分组个数是2，但是因为第0个为整个表达式本身，因此也一起输出了。</p><p>\2. 命名编号捕获组：<br>语法：(?<name>exp)<br>解释：分组的命名由表达式中的name指定<br>比如区号也可以这样写:(?<quhao>\0\d{2})-(?<haoma>\d{8})<br>按照左括号的顺序，这个表达式有如下分组：</haoma></quhao></name></p><p><img alt="img" data-src="https://pic1.zhimg.com/50/v2-96796c22cd8306f6f0d7ad8204720166_hd.jpg?source=1940ef5c" class="lazyload"><img alt="img" data-src="https://pic1.zhimg.com/80/v2-96796c22cd8306f6f0d7ad8204720166_720w.jpg?source=1940ef5c" class="lazyload"></p><p>用代码来验证一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>   String test = <span class="string">"020-85653333"</span>;</span><br><span class="line"><span class="number">2</span>        String reg=<span class="string">"(?&lt;quhao&gt;0\\d&#123;2&#125;)-(?&lt;haoma&gt;\\d&#123;8&#125;)"</span>;</span><br><span class="line"><span class="number">3</span>        Pattern pattern = Pattern.compile(reg);</span><br><span class="line"><span class="number">4</span>        Matcher mc= pattern.matcher(test);</span><br><span class="line"><span class="number">5</span>        <span class="keyword">if</span>(mc.find())&#123;</span><br><span class="line"><span class="number">6</span>            System.out.println(<span class="string">"分组的个数有："</span>+mc.groupCount());</span><br><span class="line"><span class="number">7</span>            System.out.println(mc.group(<span class="string">"quhao"</span>));</span><br><span class="line"><span class="number">8</span>            System.out.println(mc.group(<span class="string">"haoma"</span>));</span><br><span class="line"><span class="number">9</span>        &#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>   分组的个数有：<span class="number">2</span></span><br><span class="line"><span class="number">2</span>   分组名称为:quhao,匹配内容为：<span class="number">020</span></span><br><span class="line"><span class="number">3</span>   分组名称为:haoma,匹配内容为：<span class="number">85653333</span></span><br></pre></td></tr></table></figure><p>\3. 非捕获组：<br>语法：(?:exp)<br>解释：和捕获组刚好相反，它用来标识那些不需要捕获的分组，说的通俗一点，就是你可以根据需要去保存你的分组。</p><p>比如上面的正则表达式，程序不需要用到第一个分组，那就可以这样写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>   (?:\<span class="number">0</span>\d&#123;<span class="number">2</span>&#125;)-(\d&#123;<span class="number">8</span>&#125;)</span><br></pre></td></tr></table></figure><p><img alt="img" data-src="https://pic1.zhimg.com/50/v2-a875e9e70cd3bfc4457fece7e947edb9_hd.jpg?source=1940ef5c" class="lazyload"><img alt="img" data-src="https://pic1.zhimg.com/80/v2-a875e9e70cd3bfc4457fece7e947edb9_720w.jpg?source=1940ef5c" class="lazyload"></p><p>验证一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span>   String test = <span class="string">"020-85653333"</span>;</span><br><span class="line"> <span class="number">2</span>        String reg=<span class="string">"(?:0\\d&#123;2&#125;)-(\\d&#123;8&#125;)"</span>;</span><br><span class="line"> <span class="number">3</span>        Pattern pattern = Pattern.compile(reg);</span><br><span class="line"> <span class="number">4</span>        Matcher mc= pattern.matcher(test);</span><br><span class="line"> <span class="number">5</span>        <span class="keyword">if</span>(mc.find())&#123;</span><br><span class="line"> <span class="number">6</span>                System.out.println(<span class="string">"分组的个数有："</span>+mc.groupCount());</span><br><span class="line"> <span class="number">7</span>                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=mc.groupCount();i++)&#123;</span><br><span class="line"> <span class="number">8</span>                    System.out.println(<span class="string">"第"</span>+i+<span class="string">"个分组为："</span>+mc.group(i));</span><br><span class="line"> <span class="number">9</span>                &#125;</span><br><span class="line"><span class="number">10</span>        &#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>   分组的个数有：<span class="number">1</span></span><br><span class="line"><span class="number">2</span>   第<span class="number">0</span>个分组为：<span class="number">020</span>-<span class="number">85653333</span></span><br><span class="line"><span class="number">3</span>   第<span class="number">1</span>个分组为：<span class="number">85653333</span></span><br></pre></td></tr></table></figure><h2 id="反向引用"><a href="#反向引用" class="headerlink" title="反向引用"></a>反向引用</h2><p>上面讲到捕获，我们知道：<strong><em>捕获会返回一个捕获组，这个分组是保存在内存中，不仅可以在正则表达式外部通过程序进行引用，也可以在正则表达式内部进行引用，这种引用方式就是反向引用</em></strong>。</p><p>根据捕获组的命名规则，反向引用可分为：</p><ol><li>数字编号组反向引用：\k<br>或\number</li><li>命名编号组反向引用：\k<br>或者\’name’</li></ol><p>好了 讲完了，懂吗？不懂！！！<br>可能连前面讲的捕获有什么用都还不懂吧？<br>其实只是看完捕获不懂不会用是很正常的！<br>因为捕获组通常是和反向引用一起使用的</p><p>上面说到捕获组是匹配子表达式的内容按序号或者命名保存起来以便使用<br>注意两个字眼：“内容” 和 “使用”<br>这里所说的“内容”，是匹配结果，而不是子表达式本身，强调这个有什么用？嗯，先记住<br>那这里所说的“使用”是怎样使用呢？</p><p>因为它的作用主要是用来查找一些重复的内容或者做替换指定字符。</p><p>还是举栗子吧：<br>比如要查找一串字母”aabbbbgbddesddfiid”里成对的字母<br>如果按照我们之前学到的正则，什么区间啊限定啊断言啊可能是办不到的，<br>现在我们先用程序思维理一下思路：</p><ul><li>1）匹配到一个字母</li><li>2）匹配第下一个字母，检查是否和上一个字母是否一样</li><li>3）如果一样，则匹配成功，否则失败</li></ul><p>这里的思路2中匹配下一个字母时，需要用到上一个字母，那怎么记住上一个字母呢？？？<br>这下子捕获就有用处啦，我们可以利用捕获把上一个匹配成功的内容用来作为本次匹配的条件<br>好了，有思路就要实践<br>首先匹配一个字母：\w<br>我们需要做成分组才能捕获，因此写成这样：(\w)</p><p>那这个表达式就有一个捕获组：（\w）<br>然后我们要用这个捕获组作为条件，那就可以：(\w)\1<br>这样就大功告成了<br>可能有人不明白了，\1是什么意思呢？<br>还记得捕获组有两种命名方式吗，<strong>一种是是根据捕获分组顺序命名，一种是自定义命名来作为捕获组的命名</strong><br><strong><em>在默认情况下都是以数字来命名，而且数字命名的顺序是从1开始的\</em></strong><br>因此要引用第一个捕获组，根据反向引用的数字命名规则 就需要 \k<1>或者\1<br>当然，通常都是是后者。<br>我们来测试一下：</1></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>   String test = <span class="string">"aabbbbgbddesddfiid"</span>;</span><br><span class="line"><span class="number">2</span>        Pattern pattern = Pattern.compile(<span class="string">"(\\w)\\1"</span>);</span><br><span class="line"><span class="number">3</span>        Matcher mc= pattern.matcher(test);</span><br><span class="line"><span class="number">4</span>        <span class="keyword">while</span>(mc.find())&#123;</span><br><span class="line"><span class="number">5</span>            System.out.println(mc.group());</span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span>        &#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>   aa</span><br><span class="line"><span class="number">2</span>   bb</span><br><span class="line"><span class="number">3</span>   bb</span><br><span class="line"><span class="number">4</span>   dd</span><br><span class="line"><span class="number">5</span>   dd</span><br><span class="line"><span class="number">6</span>   ii</span><br></pre></td></tr></table></figure><p>嗯，这就是我们想要的了。</p><p>在举个替换的例子，假如想要把字符串中abc换成a</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>   String test = <span class="string">"abcbbabcbcgbddesddfiid"</span>;</span><br><span class="line"><span class="number">2</span>   String reg=<span class="string">"(a)(b)c"</span>;</span><br><span class="line"><span class="number">3</span>   System.out.println(test.replaceAll(reg, <span class="string">"$1"</span>));;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>   abbabcgbddesddfiid</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 正则表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据存储引擎及索引方式</title>
      <link href="/2020/11/19/%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E5%8F%8A%E7%B4%A2%E5%BC%95/"/>
      <url>/2020/11/19/%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E5%8F%8A%E7%B4%A2%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<p>哈希索引<br>     key-value数据   数据存储：追加式文件(顺序写入，按插入顺序排序)<br>     哈希索引（内存中使用哈希表记录每个键到数据文件中特定的字节偏移量）<br>     案例：Riak的默认存储引擎Bitcask</p><p>SSTables和LSM-Tree<br>     key-value数据   数据存储：追加式文件（顺序写入，按键排序）<br>     内存表索引（内存中使用平衡树数据结构记录某些键到数据文件中特定的字节偏移量，可以是稀疏的），后台进程周期性的执行段合并与压缩<br>     基于合并和压缩排序文件原理的存储引擎通常被称为LSM存储引擎<br>     案例：LevelDB、RocksDB、Cassandra、HBase、Elasticsearch和Solr的全文搜索系统的索引引擎Lucene</p><p>B-Tree</p>]]></content>
      
      
      <categories>
          
          <category> 数据系统理论 </category>
          
          <category> 数据系统基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 存储引擎 </tag>
            
            <tag> 索引 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis、MySQL、MongoDB、Memcached对比</title>
      <link href="/2020/11/10/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis%E3%80%81MySQL%E3%80%81MongoDB%E3%80%81Memcached%E5%AF%B9%E6%AF%94/"/>
      <url>/2020/11/10/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis%E3%80%81MySQL%E3%80%81MongoDB%E3%80%81Memcached%E5%AF%B9%E6%AF%94/</url>
      
        <content type="html"><![CDATA[<h1 id="四个数据库特点"><a href="#四个数据库特点" class="headerlink" title="四个数据库特点"></a>四个数据库特点</h1><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><ul><li>关系型数据库</li><li>数据存储在硬盘中，功能强大，主要用于存放持久化数据</li><li>读取速度较慢</li><li>以表的形式存放数据</li><li>支持多种存储引擎</li><li>支持多线程，充分利用CPU资源</li><li>提供TCP/IP、ODBC和JDBC等多种数据库连接途径</li></ul><h2 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h2><ul><li>非关系型数据库,“存储数据”的系统，增删改查可以添加很多条件，就像SQL数据库一样灵活</li><li>存储在内存中依赖系统虚拟内存管理，可存储大量数据</li><li>模式自由：可以把不同结构的文档存储在同一个数据库里</li><li>面向集合的存储：适合存储JSON风格文件的形式</li><li>完整的索引支持，对任何属性可索引</li><li>复制和高可用性：多种可选机制</li><li>不支持事务，靠客户端自身保证</li></ul><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><ul><li>非关系型数据库，也是缓存数据库</li><li>数据存储在内存中，其“缓存”的性质远大于其“数据存储“的性质</li><li>读取速度快，性能极高-读的速度是110000次/s，写的速度是81000次/s</li><li>Key-Value形式存放数据，同时还提供list，set，在set，hash等数据结构的存储</li><li>单线程模式，性能受限于CPU性能</li><li>支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。</li><li>支持master-slave模式的数据备份</li><li>所有操作都是原子性的</li><li>丰富的特性 - 支持publish/subscribe,通知，key过期等等特性。</li></ul><h2 id="Memcached"><a href="#Memcached" class="headerlink" title="Memcached"></a>Memcached</h2><ul><li>非关系型数据库，缓存数据库</li><li>支持多核</li><li>只支持简单key-value数据结构，无丰富数据类型</li><li>不支持持久化，重启后数据全部丢失</li><li>不支持数据同步</li></ul><h1 id="MySQL、Redis、Memcache和MongoDB的区别"><a href="#MySQL、Redis、Memcache和MongoDB的区别" class="headerlink" title="MySQL、Redis、Memcache和MongoDB的区别"></a>MySQL、Redis、Memcache和MongoDB的区别</h1><div class="table-container"><table><thead><tr><th></th><th>MySQL</th><th>MongoDB</th><th>Memcache</th><th>Redis</th></tr></thead><tbody><tr><td>类型</td><td>关系型数据库</td><td>非关系型数据库</td><td>非关系型数据库</td><td>非关系型数据库</td></tr><tr><td>存储</td><td>表：硬盘存储</td><td>面向集合的存储：基于内存，依赖操作系统VM做内存管理</td><td>Key-value：无虚拟内存</td><td>Key-value：有虚拟内存</td></tr><tr><td>多核支持</td><td>支持</td><td>支持</td><td>支持</td><td>不支持</td></tr><tr><td>数据类型</td><td>丰富</td><td>丰富</td><td>单一</td><td>五大数据类型</td></tr><tr><td>TPS</td><td>一般</td><td>较高</td><td>很高</td><td>很高</td></tr><tr><td>可用性</td><td>支持多种机制</td><td>支持master-slave,replicaset,auto sharding机制</td><td>无</td><td>主从复制</td></tr><tr><td>持久化</td><td>天然支持</td><td>采用binlog方式</td><td>不支持</td><td>依赖快照</td></tr><tr><td>事务支持</td><td>支持</td><td>不支持</td><td>在并发场景下，用cas保证一致性</td><td>事务支持比较弱，只能保证事务中的每个操作连续执行</td></tr><tr><td>数据分析</td><td>支持</td><td>支持</td><td>不支持</td><td>不支持</td></tr><tr><td>适用场景</td><td>结构化查询</td><td>非结构化数据，海量数据读取</td><td>用于在动态系统中减少数据库负载，提升性能</td><td>数据量较小的性能及运算</td></tr></tbody></table></div><h1 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h1><h2 id="MongoDB适用于"><a href="#MongoDB适用于" class="headerlink" title="MongoDB适用于"></a>MongoDB适用于</h2><ol><li>网站数据：适合实时的插入，更新与查询，并具备网站实时数据存储所需对的复制及高度伸缩性；</li><li>缓存：由于性能很高，也适合作为信息基础设施的缓存层，在系统重启之后，搭建的持久化缓存可以避免下层的数据源过载；</li><li>大尺寸、低价值的数据也是MongoDB的最佳选择，使用传统的关系数据库存储一些数据时可能会比较贵，再次之前很多程序员往往会选择传统的文件进行存储</li><li>高伸缩的场景，非常是个由数十或者数百台服务器组成的数据库</li><li>用于对象及json数据的存储，MongoDB的bson数据格式非常适合文档格式化的存储及查询。</li></ol><h2 id="Mysql更加适用于"><a href="#Mysql更加适用于" class="headerlink" title="Mysql更加适用于"></a>Mysql更加适用于</h2><ol><li>高度事务性的系统。例如银行或者会计系统，传统的关系型数据库目前还是更实用于需要大量原子性复杂事务的应用程序</li><li>传统的商业智能应用，针对特定问题的BI数据库会对产生高度优化的查询方式，对于此类应用，数据仓库可能是更合适的选择</li></ol><h2 id="Redis适用于"><a href="#Redis适用于" class="headerlink" title="Redis适用于"></a>Redis适用于</h2><ol><li>用来做缓存-redis的所有数据时放在内存中的</li><li>可以在某些特定应用场景下替代传统数据库—比如社交类的应用</li><li>在一些大型系统中，巧妙的实现一些特定的功能：session共享、购物车</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> 非关系型数据库 </category>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 缓存 </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis基础之二：Redis安装及管理指令</title>
      <link href="/2020/11/10/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E5%9F%BA%E7%A1%80%E4%B9%8B%E4%BA%8C%EF%BC%9ARedis%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%A1%E7%90%86%E6%8C%87%E4%BB%A4/"/>
      <url>/2020/11/10/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E5%9F%BA%E7%A1%80%E4%B9%8B%E4%BA%8C%EF%BC%9ARedis%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%A1%E7%90%86%E6%8C%87%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="Windows安装"><a href="#Windows安装" class="headerlink" title="Windows安装"></a>Windows安装</h1><h2 id="下载Redis"><a href="#下载Redis" class="headerlink" title="下载Redis"></a>下载Redis</h2><p><strong>下载地址：</strong><a href="https://github.com/tporadowski/redis/releases。" target="_blank" rel="noopener">https://github.com/tporadowski/redis/releases。</a></p><p>Redis 支持 32 位和 64 位。这个需要根据你系统平台的实际情况选择，这里我们下载 <strong>Redis-x64-xxx.msi</strong></p><p><img alt="Redis安装" data-src="//orangesching.github.io/2020/11/10/数据库/非关系型数据库/Redis/Redis基础之二：Redis安装及管理指令/Redis安装.png" class="lazyload"></p><p>打开msi文件开始安装，期间注意<strong>勾选添加环境变量</strong>，端口号可保持默认的6379，并选择防火墙例外，从而保证外部可以正常访问Redis服务</p><p>安装后的Redis根目录内容如下：</p><p><img alt="Redis文件结构" data-src="//orangesching.github.io/2020/11/10/数据库/非关系型数据库/Redis/Redis基础之二：Redis安装及管理指令/Redis文件结构.png" class="lazyload"></p><h2 id="配置redis"><a href="#配置redis" class="headerlink" title="配置redis"></a>配置redis</h2><p>打开Redis服务配置文件。通常为redis.windows-service.conf，而不是redis.windows.conf。后者是以非系统服务方式启动程序使用的配置文件</p><p><img alt="配置文件" data-src="//orangesching.github.io/2020/11/10/数据库/非关系型数据库/Redis/Redis基础之二：Redis安装及管理指令/配置文件.png" class="lazyload"></p><p>找到含有requirepass字样的地方，追加一行，输入requirepass 123456。这是访问Redis时所需的密码，一般测试情况下可以不用设定密码。</p><p><img alt="设置密码" data-src="//orangesching.github.io/2020/11/10/数据库/非关系型数据库/Redis/Redis基础之二：Redis安装及管理指令/设置密码.png" class="lazyload"></p><h2 id="启动redis-server"><a href="#启动redis-server" class="headerlink" title="启动redis-server"></a>启动redis-server</h2><p>打开任务管理器中的服务找到Redis，如果修改了配置文件需重启，显示正在运行则表示服务已启动</p><p><img alt="查看启动" data-src="//orangesching.github.io/2020/11/10/数据库/非关系型数据库/Redis/Redis基础之二：Redis安装及管理指令/查看启动.png" class="lazyload"></p><h2 id="启动redis-client"><a href="#启动redis-client" class="headerlink" title="启动redis-client"></a>启动redis-client</h2><p>打开 cmd 窗口，打开redis-client，输入<code>redis-cli</code>会以默认端口号6379连接本地Redis服务，若需连接远程Redis服务，则输入以下命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h IP地址 -p 端口号</span><br></pre></td></tr></table></figure><p>若设置了密码则需要密码授权登录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auth 密码</span><br></pre></td></tr></table></figure><h2 id="测试安装"><a href="#测试安装" class="headerlink" title="测试安装"></a>测试安装</h2><p>设置键值对:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set hello redis</span><br></pre></td></tr></table></figure><p>取出键值对:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get hello</span><br></pre></td></tr></table></figure><p><img alt="测试安装" data-src="//orangesching.github.io/2020/11/10/数据库/非关系型数据库/Redis/Redis基础之二：Redis安装及管理指令/测试安装.png" class="lazyload"></p><h1 id="Unbuntu安装"><a href="#Unbuntu安装" class="headerlink" title="Unbuntu安装"></a>Unbuntu安装</h1><h1 id="管理指令"><a href="#管理指令" class="headerlink" title="管理指令"></a>管理指令</h1><h2 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h2><p>连接本地Redis服务器 ：<code>redis-cli</code></p><p>连接远程服务器的Redis服务器：<code>redis-cli -h host -p port -a password</code></p><p>连接默认端口号：6379</p><p>如有密码输入密码登录：<code>auth password</code></p><p>检测 redis 服务是否启动：<code>PING</code></p><h2 id="服务器配置"><a href="#服务器配置" class="headerlink" title="服务器配置"></a>服务器配置</h2><p>编辑配置：  <code>CONFIG SET CONFIG_SETTING_NAME NEW_CONFIG_VALUE</code></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> 非关系型数据库 </category>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 缓存 </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis基础之三：Redis数据结构及指令</title>
      <link href="/2020/11/10/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E5%9F%BA%E7%A1%80%E4%B9%8B%E4%B8%89%EF%BC%9ARedis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E6%8C%87%E4%BB%A4/"/>
      <url>/2020/11/10/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E5%9F%BA%E7%A1%80%E4%B9%8B%E4%B8%89%EF%BC%9ARedis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E6%8C%87%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Redis适用key-value方式存储，key统一为String类型，以下所述数据类型均为value的类型</p><p>数据类型分为：字符串类型、散列类型、列表类型、集合类型、有序集合类型。</p><p><img alt="数据类型架构" data-src="//orangesching.github.io/2020/11/10/数据库/非关系型数据库/Redis/Redis基础之三：Redis数据结构及指令/redis-data-structure-types.jpeg" class="lazyload"></p><p><strong>五大数据结构对比</strong></p><div class="table-container"><table><thead><tr><th style="text-align:left">类型</th><th style="text-align:left">简介</th><th style="text-align:left">特性</th><th style="text-align:left">场景</th></tr></thead><tbody><tr><td style="text-align:left">String(字符串)</td><td style="text-align:left">二进制安全，最基本类型</td><td style="text-align:left">可以包含任何数据,比如jpg图片或者序列化的对象,一个键最大能存储512M</td><td style="text-align:left">—-</td></tr><tr><td style="text-align:left">Hash(字典)</td><td style="text-align:left">键值对集合,即编程语言中的Map类型</td><td style="text-align:left">适合存储对象,并且可以像数据库中update一个属性一样只修改某一项属性值(Memcached中需要取出整个字符串反序列化成对象修改完再序列化存回去)</td><td style="text-align:left">存储、读取、修改用户属性</td></tr><tr><td style="text-align:left">List(列表)</td><td style="text-align:left">链表(双向链表)</td><td style="text-align:left">增删快,提供了操作某一段元素的API</td><td style="text-align:left">1、最新消息排行等功能(比如朋友圈的时间线) <br>2、消息队列</td></tr><tr><td style="text-align:left">Set(集合)</td><td style="text-align:left">哈希表实现,元素不重复</td><td style="text-align:left">1、添加、删除,查找的复杂度都是O(1) <br>2、为集合提供了求交集、并集、差集等操作</td><td style="text-align:left">1、共同好友 <br>2、利用唯一性,统计访问网站的所有独立ip <br>3、好友推荐时,根据tag求交集,大于某个阈值就可以推荐</td></tr><tr><td style="text-align:left">Sorted Set(有序集合)</td><td style="text-align:left">将Set中的元素增加一个权重参数score,元素按score有序排列</td><td style="text-align:left">数据插入集合时,已经进行天然排序</td><td style="text-align:left">1、排行榜<br>2、带权重的消息队列</td></tr></tbody></table></div><h1 id="Key指令"><a href="#Key指令" class="headerlink" title="Key指令"></a>Key指令</h1><h2 id="查看Key"><a href="#查看Key" class="headerlink" title="查看Key"></a>查看Key</h2><p><code>EXISTS key [key1...]</code><br>        判断Key是否存在，返回存在的键个数，可跟多个Key值<br><code>TYPE key</code><br>        返回Key对应的Value类型，只能跟一个Key。如果对应的Key不存在，返回为none<br><code>KEYS pattern</code></p><h2 id="删除-重命名Key"><a href="#删除-重命名Key" class="headerlink" title="删除/重命名Key"></a>删除/重命名Key</h2><p><code>DEL key [key1...]</code><br>    删除Key，返回删除键的个数，可跟多个Key值。key中的内容也一并删除<br><code>RENAME key newkey</code><br>    将 key 改名为 newkey ，当 key 和 newkey 相同，或者 key 不存在时，返回一个错误。</p><h2 id="失效时间"><a href="#失效时间" class="headerlink" title="失效时间"></a>失效时间</h2><p><code>EXPIRE key seconds</code> / <code>PEXPIRE key milliseconds</code><br>    为给定 key 设置生存时间，当 key 过期时(生存时间为 0 )，它会被自动删除。返回1成功，0设置失败或不存在Key<br>    只有key被DEL、 SET 、 GETSET 命令删除或覆写时才可移除生存时间，ALTER修改命令不行<br>    可对已经带有生存时间的 key 执行 EXPIRE 命令来取代旧的生存时间<br><code>PERSIST key</code><br>    取消Key的失效时间，取消成功则返回1，失败则返回0（Key本身就是永久的或者Key不存在）<br><code>TTL key</code>  /  <code>PTTL key</code><br>    查看Key的有效时间(秒)，只能跟一个Key。Key不存在返回-2；Key没有使用EXPIRE设置时间返回-1</p><h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><p>一个键最大能存储512M</p><h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><h3 id="增"><a href="#增" class="headerlink" title="增"></a>增</h3><p><code>SET Key Value</code><br>        设置Key-Value<br>        如果 key 已经持有其他值， SET 就覆写旧值，无视类型<br><code>MSET Key Value [Key1 value1]</code><br>        一次性设置多个，key-value要成对出现</p><h3 id="删"><a href="#删" class="headerlink" title="删"></a>删</h3><p><code>DEL key</code></p><h3 id="改"><a href="#改" class="headerlink" title="改"></a>改</h3><p><code>APPEND key</code><br>    向字符串尾部追加字符串，追加的Key不存在，这个指令相当于SET指令。返回字符串长度<br>    如果 key 已经持有其他值， SET 就覆写旧值，无视类型</p><p><code>INCR key</code><br>        字符串形式的整数+1 ，如果Key不存在，进行了set操作</p><p><code>DECR key</code><br>        字符串形式的整数值-1，如果Key不存在，进行了set操作</p><p><code>INCRBY key increment</code><br>        key中的value增指定值</p><p><code>DECRBY key decrement</code><br>        key中的value减指定值</p><p><code>INCRBYFLOAT key increment</code><br>        增加浮点数，如果Key不存在返回-1</p><h3 id="查"><a href="#查" class="headerlink" title="查"></a>查</h3><p><code>GET Key</code><br>        获取Key对应的Value</p><p><code>MGET key [key1 key2]</code><br>        一次性获取多个</p><p><code>STRLEN Key</code><br>    获取字符串长度，不存在的Key会返回0</p><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><ol><li>简单的 KV 缓存</li><li>参赛者又获得了十票</li><li>redis对于KV的操作效率很高，可以直接用作计数器。例如，统计在线人数等等，另外string类型是二进制存储安全的，所以也可以使用它来存储图片，甚至是视频等。</li></ol><h1 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h1><p>键值对集合,即编程语言中的Map类型</p><h2 id="指令-1"><a href="#指令-1" class="headerlink" title="指令"></a>指令</h2><h3 id="增-1"><a href="#增-1" class="headerlink" title="增"></a>增</h3><p><code>HSET key field value</code><br>    设置field-value<br>    <strong>会覆盖</strong>哈希表中已存在的域<br>    插入新的Key-Value返回的是1，如果是修改旧的Value，返回是0<br>    如果 key 不存在，一个空哈希表被创建并执行 <code>HMSET</code> 操作</p><p><code>HMSET key field value [field1 value1]</code><br>    设置多个field-value，一定要成对</p><p><code>HSETNX key field value</code><br>    在Map的Key不存在时执行HSET操作<br>    当Map的Key存在时，<strong>不会覆盖</strong>哈希表中已存在的域<br>    可以看做<code>HSET NOT EXISTS</code>的缩写</p><h3 id="删-1"><a href="#删-1" class="headerlink" title="删"></a>删</h3><p><code>HDEL key field [field1]</code><br>    可删除多个field-value</p><h3 id="改-1"><a href="#改-1" class="headerlink" title="改"></a>改</h3><p><code>HSET key field value</code><br>    已经存在于哈希表中，旧值将被覆盖</p><p><code>HINCRBY key field num</code><br>    域 field 增加num，会在对应的Key不存在时执行SET操作</p><h3 id="查-1"><a href="#查-1" class="headerlink" title="查"></a>查</h3><p><code>HGET Key field</code><br>    获取Key中field对应的Value</p><p><code>HMGET key [key1 key2]</code><br>    一次性获取多个</p><p><code>HGETALL key</code><br>    获取key中所有field-value<br>    单行为Key，双行为Value<br>    这个指令是将Map遍历然后转换成List类型呈现</p><p><code>HKEYS key</code><br>    获取key中所有field</p><p><code>HVALS key</code><br>    返回 key 中所有域的值</p><p><code>HLEN key</code><br>    获取MAP的field-value对数</p><p><code>HEXISTS key field</code><br>    判断key中是否存在指定field</p><h2 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a>适用场景</h2><p>存放键值对，一般可以用来存某个对象的基本属性信息，例如，用户信息，商品信息等，另外，由于hash的大小在小于配置的大小的时候使用的是ziplist结构，比较节约内存，所以针对大量的数据存储可以考虑使用hash来分段存储来达到压缩数据量，节约内存的目的，例如，对于大批量的商品对应的图片地址名称。比如：商品编码固定是10位，可以选取前7位做为hash的key,后三位作为field，图片地址作为value。这样每个hash表都不超过999个，只要把redis.conf中的hash-max-ziplist-entries改为1024，即可。</p><h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><p>链表(双向链表)</p><h2 id="指令-2"><a href="#指令-2" class="headerlink" title="指令"></a>指令</h2><h3 id="增-2"><a href="#增-2" class="headerlink" title="增"></a>增</h3><p><code>LPUSH key value [value1 value2]</code><br>    将一个或多个值 value 插入到列表 key 的表头(最左边)</p><p><code>RPUSH key value [value1 value2]</code><br>    将一个或多个值 value 插入到列表 key 的表尾(最右边)</p><p><code>LINSERT key BEFORE|AFTER target value</code><br>    在target值前/后插入value值</p><p><code>RPOPLPUSH source des</code><br>    使用RPOP弹出source中的一个元素，然后使用LPUSH添加到des中</p><h3 id="删-2"><a href="#删-2" class="headerlink" title="删"></a>删</h3><p><code>LPOP key</code><br>    移除并返回列表的头元素，key不存在返回nil</p><p><code>RPOP key</code><br>    移除并返回列表的尾元素，key不存在返回nil</p><p><code>LREM key count value</code><br>    返回值为删除元素的个数<br>    count=0删除全部，count&gt;0删除表尾(右)count个，count&lt;0删除表头(左)count个</p><h3 id="改-2"><a href="#改-2" class="headerlink" title="改"></a>改</h3><p><code>LSET key index newValue</code><br>    设置索引值，调整value位置</p><p><code>LTRIM key start end</code><br>    保留指定片段，范围外的片段丢弃</p><h3 id="查-2"><a href="#查-2" class="headerlink" title="查"></a>查</h3><p><code>LRANGE key start stop</code><br>    List的索引是从0开始的，支持负索引，-1代表最右边第一个元素，范围是包含关系[]</p><p><code>LINDEX key index</code><br>        获取索引位置的value</p><h2 id="适用场景-2"><a href="#适用场景-2" class="headerlink" title="适用场景"></a>适用场景</h2><ol><li>存储一些列表型的数据结构，类似粉丝列表、文章的评论列表之类的东西</li><li>基于 list 实现分页查询，类似微博那种下拉不断分页的东西</li><li>实现简单的消息队列</li></ol><h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><p>哈希表实现,元素不重复</p><h2 id="指令-3"><a href="#指令-3" class="headerlink" title="指令"></a>指令</h2><h3 id="增-3"><a href="#增-3" class="headerlink" title="增"></a>增</h3><p><code>SADD key value1 value2 value3....</code><br>    不会插入重复元素</p><h3 id="删-3"><a href="#删-3" class="headerlink" title="删"></a>删</h3><p><code>SREM key value1 value2 value3...</code><br>    删除某个值或者多个值</p><p><code>SPOP key num</code><br>    随机获取一个或者多个(num)集合中的元素<br>    获取的元素会从集合中移除</p><h3 id="改-3"><a href="#改-3" class="headerlink" title="改"></a>改</h3><p><code>SMOVE key1 key2 value</code><br>    将value元素从key1集合移动到 key2集合<br>    原子性操作</p><h3 id="查-3"><a href="#查-3" class="headerlink" title="查"></a>查</h3><p><code>SMEMBERS key</code><br>    获取全部值，以插入顺序无重复</p><p><code>SISMEMBER key value</code><br>    查看值是否存在</p><p><code>SCARD key</code><br>    获取集合中元素的个数</p><p><code>SRANDMEMBER key num</code><br>    获取的元素不会移除<br>    随机获取一个或者多个(num)集合中的元素</p><h3 id="集合运算"><a href="#集合运算" class="headerlink" title="集合运算"></a>集合运算</h3><h4 id="求差集"><a href="#求差集" class="headerlink" title="求差集"></a>求差集</h4><p><code>SDIFF set1 set2 set3</code><br>    返回差集</p><p><code>SDIFFSTORE set1 set2 set3</code><br>    将运算结果存放在第一个Set中，且第一个集合不会参与运算，并且如果第一个集合有元素会被清空</p><h4 id="求交集"><a href="#求交集" class="headerlink" title="求交集"></a>求交集</h4><p><code>SINTER set1 set2 set3</code><br>    返回交集</p><p><code>SINTERSTORE set1 set2 set3</code><br>    将运算结果存放在第一个Set中，且第一个集合不会参与运算，并且如果第一个集合有元素会被清空</p><h4 id="求并集"><a href="#求并集" class="headerlink" title="求并集"></a>求并集</h4><p><code>SUNION set1 set2 set3</code><br>    返回并集</p><p><code>SUNIONSTORE set1 set2 set3</code><br>    将运算结果存放在第一个Set中，且第一个集合不会参与运算，并且如果第一个集合有元素会被清空</p><h2 id="适用场景-3"><a href="#适用场景-3" class="headerlink" title="适用场景"></a>适用场景</h2><ol><li>基于 Redis 进行全局的 set 去重</li><li>利用集合操作，查找共同好友</li><li>适合用来给人、事物贴标签</li></ol><h1 id="SortedSet"><a href="#SortedSet" class="headerlink" title="SortedSet"></a>SortedSet</h1><p>将Set中的元素增加一个权重参数score,元素按score有序排列</p><h2 id="指令-4"><a href="#指令-4" class="headerlink" title="指令"></a>指令</h2><h3 id="增-4"><a href="#增-4" class="headerlink" title="增"></a>增</h3><p><code>ZADD key score member [[score member] [score member] ...]</code><br>    将一个或多个 member 元素及其 score 值加入到有序集 key 当中</p><h3 id="删-4"><a href="#删-4" class="headerlink" title="删"></a>删</h3><p><code>ZREM key member [member...]</code><br>    删除有序集合中一个或多个成员</p><p><code>ZREMRANGEBYLEX key min max</code><br>    移除有序集合中给定的字典区间的所有成员</p><p><code>ZREMRANGEBYRANK key start stop</code><br>    移除有序集合中给定的排名区间的所有成员</p><p><code>ZREMRANGEBYSCORE key min max</code><br>    移除有序集合中给定的分数区间的所有成员</p><h3 id="查-4"><a href="#查-4" class="headerlink" title="查"></a>查</h3><p><code>ZCARD key</code><br>​    获取有序集合中成员的个数</p><p><code>​ZCOUNT key min max</code><br>​    计算在有序集合中指定区间分数的成员数</p><p><code>​ZRANK/ZREVRANK key member</code><br>​    返回有序集 key 中成员 member 的排名。其中有序集成员按 score 值递增(从小到大/从大到小)顺序排列</p><p><code>​ZSCORE key member</code><br>​    返回有序集中，成员的分数值</p><p><code>​ZRANGE key start stop</code><br>​    通过索引区间返回有序集合指定区间内的成员</p><p><code>​ZREVRANGE key start stop [WITHSCORES]</code><br>​    返回有序集中指定区间内的成员，通过索引，分数从高到低</p><p><code>​ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]</code><br>​    通过分数返回有序集合指定区间内的成员，min 和 max 可以是 -inf 和 +inf</p><p><code>​ZREVRANGEBYSCORE key max min [WITHSCORES]</code><br>​    返回有序集中指定分数区间内的成员，分数从高到低排序</p><p><code>ZINCRBY key increment member</code><br>    返回有序集合中指定成员的索引</p><h3 id="集合运算-1"><a href="#集合运算-1" class="headerlink" title="集合运算"></a>集合运算</h3><h4 id="求并集-1"><a href="#求并集-1" class="headerlink" title="求并集"></a>求并集</h4><p><code>ZUNIONSTORE destination numkeys key [key ...]</code><br>    计算给定的一个或多个有序集的并集，并存储在新的 key 中</p><h4 id="求交集-1"><a href="#求交集-1" class="headerlink" title="求交集"></a>求交集</h4><p><code>ZINTERSTORE destination numkeys key [key...]</code><br>    计算给定的一个或多个有序集的交集，其中给定 key 的数量必须以 numkeys 参数指定，并将该交集(结果集)储存到 destination</p><h2 id="适用场景-4"><a href="#适用场景-4" class="headerlink" title="适用场景"></a>适用场景</h2><p>适合做需要得到排名的场景需求，比如某场线上文章比赛，举办方通过谁的文章点赞更多，谁就能获得更高的排名</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> 非关系型数据库 </category>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 缓存 </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RPC与REST：原理、区别</title>
      <link href="/2020/09/21/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/RPC/RPC%E4%B8%8EREST%EF%BC%9A%E5%8E%9F%E7%90%86%E3%80%81%E5%8C%BA%E5%88%AB/"/>
      <url>/2020/09/21/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/RPC/RPC%E4%B8%8EREST%EF%BC%9A%E5%8E%9F%E7%90%86%E3%80%81%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="RPC原理"><a href="#RPC原理" class="headerlink" title="RPC原理"></a>RPC原理</h1><p><strong>本地过程调用</strong></p><p>RPC就是要像调用本地的函数一样去调远程函数。在研究RPC前，我们先看看本地调用是怎么调的。假设我们要调用函数Multiply来计算lvalue * rvalue的结果:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="function"><span class="keyword">int</span> <span class="title">Multiply</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="number">2</span>    <span class="keyword">int</span> y = l * r;</span><br><span class="line"><span class="number">3</span>    <span class="keyword">return</span> y;</span><br><span class="line"><span class="number">4</span> &#125;</span><br><span class="line"><span class="number">5</span> </span><br><span class="line"><span class="number">6</span> <span class="keyword">int</span> lvalue = <span class="number">10</span>;</span><br><span class="line"><span class="number">7</span> <span class="keyword">int</span> rvalue = <span class="number">20</span>;</span><br><span class="line"><span class="number">8</span> <span class="keyword">int</span> l_times_r = Multiply(lvalue, rvalue);</span><br></pre></td></tr></table></figure><p>那么在第8行时，我们实际上执行了以下操作：</p><ol><li>将 lvalue 和 rvalue 的值压栈</li><li>进入Multiply函数，取出栈中的值10 和 20，将其赋予 l 和 r</li><li>执行第2行代码，计算 l * r ，并将结果存在 y</li><li>将 y 的值压栈，然后从Multiply返回</li><li>第8行，从栈中取出返回值 200 ，并赋值给 l_times_r</li></ol><p>以上5步就是执行本地调用的过程。（20190116注：以上步骤只是为了说明原理。事实上编译器经常会做优化，对于参数和返回值少的情况会直接将其存放在寄存器，而不需要压栈弹栈的过程，甚至都不需要调用call，而直接做inline操作。仅就原理来说，这5步是没有问题的。）</p><p><strong>远程过程调用带来的新问题</strong></p><p>在远程调用时，我们需要执行的函数体是在远程的机器上的，也就是说，Multiply是在另一个进程中执行的。这就带来了几个新问题：</p><ol><li><strong>Call ID映射</strong>。我们怎么告诉远程机器我们要调用Multiply，而不是Add或者FooBar呢？在本地调用中，函数体是直接通过函数指针来指定的，我们调用Multiply，编译器就自动帮我们调用它相应的函数指针。但是在远程调用中，函数指针是不行的，因为两个进程的地址空间是完全不一样的。所以，在RPC中，所有的函数都必须有自己的一个ID。这个ID在所有进程中都是唯一确定的。客户端在做远程过程调用时，必须附上这个ID。然后我们还需要在客户端和服务端分别维护一个 {函数 &lt;—&gt; Call ID} 的对应表。两者的表不一定需要完全相同，但相同的函数对应的Call ID必须相同。当客户端需要进行远程调用时，它就查一下这个表，找出相应的Call ID，然后把它传给服务端，服务端也通过查表，来确定客户端需要调用的函数，然后执行相应函数的代码。</li><li><strong>序列化和反序列化</strong>。客户端怎么把参数值传给远程的函数呢？在本地调用中，我们只需要把参数压到栈里，然后让函数自己去栈里读就行。但是在远程过程调用时，客户端跟服务端是不同的进程，不能通过内存来传递参数。甚至有时候客户端和服务端使用的都不是同一种语言（比如服务端用C++，客户端用Java或者Python）。这时候就需要客户端把参数先转成一个字节流，传给服务端后，再把字节流转成自己能读取的格式。这个过程叫序列化和反序列化。同理，从服务端返回的值也需要序列化反序列化的过程。</li><li><strong>网络传输</strong>。远程调用往往用在网络上，客户端和服务端是通过网络连接的。所有的数据都需要通过网络传输，因此就需要有一个网络传输层。网络传输层需要把Call ID和序列化后的参数字节流传给服务端，然后再把序列化后的调用结果传回客户端。只要能完成这两者的，都可以作为传输层使用。因此，它所使用的协议其实是不限的，能完成传输就行。尽管大部分RPC框架都使用TCP协议，但其实UDP也可以，而gRPC干脆就用了HTTP2。Java的Netty也属于这层的东西。</li></ol><p>有了这三个机制，就能实现RPC了，具体过程如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Client端 </span></span><br><span class="line"><span class="number">1.</span> 将这个调用映射为Call ID。这里假设用最简单的字符串当Call ID的方法</span><br><span class="line"><span class="number">2.</span> 将Call ID，lvalue和rvalue序列化。可以直接将它们的值以二进制形式打包</span><br><span class="line"><span class="number">3.</span> 把<span class="number">2</span>中得到的数据包发送给ServerAddr，这需要使用网络传输层</span><br><span class="line"><span class="number">4.</span> 等待服务器返回结果</span><br><span class="line"><span class="number">5.</span> 如果服务器调用成功，那么就将结果反序列化，并赋给l_times_r</span><br><span class="line"></span><br><span class="line"><span class="comment">// Server端</span></span><br><span class="line"><span class="number">1.</span> 在本地维护一个Call ID到函数指针的映射call_id_map，可以用<span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::function&lt;&gt;&gt;</span><br><span class="line"><span class="number">2.</span> 等待请求</span><br><span class="line"><span class="number">3.</span> 得到一个请求后，将其数据包反序列化，得到Call ID</span><br><span class="line"><span class="number">4.</span> 通过在call_id_map中查找，得到相应的函数指针</span><br><span class="line"><span class="number">5.</span> 将lvalue和rvalue反序列化后，在本地调用Multiply函数，得到结果</span><br><span class="line"><span class="number">6.</span> 将结果序列化后通过网络返回给Client</span><br></pre></td></tr></table></figure><p>所以要实现一个RPC框架，其实只需要按以上流程实现就基本完成了。</p><p>其中：</p><ul><li>Call ID映射可以直接使用函数字符串，也可以使用整数ID。映射表一般就是一个哈希表。</li><li>序列化反序列化可以自己写，也可以使用Protobuf或者FlatBuffers之类的。</li><li>网络传输库可以自己写socket，或者用asio，ZeroMQ，Netty之类。</li></ul><p>当然，这里面还有一些细节可以填充，比如如何处理网络错误，如何防止攻击，如何做流量控制，等等。但有了以上的架构，这些都可以持续加进去。</p><p>参考：<a href="https://www.zhihu.com/question/25536695/answer/221638079" target="_blank" rel="noopener">https://www.zhihu.com/question/25536695/answer/221638079</a></p>]]></content>
      
      
      <categories>
          
          <category> 分布式系统架构 </category>
          
          <category> RPC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RPC </tag>
            
            <tag> REST </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>中间件的概念及分类</title>
      <link href="/2020/09/15/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/%E4%B8%AD%E9%97%B4%E4%BB%B6/%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%88%86%E7%B1%BB/"/>
      <url>/2020/09/15/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/%E4%B8%AD%E9%97%B4%E4%BB%B6/%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%88%86%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="中间件的概念"><a href="#中间件的概念" class="headerlink" title="中间件的概念"></a>中间件的概念</h1><p>中间件就是处于中间的软件。但这种不是从功能，或者特性来定义的概念，而是用位置来定义的名字，就容易被不同的人从不同角度赋予其不同的含义</p><p>IDC曾经给中间件下的定义是中间件是一种独立的系统软件或服务程序，分布式应用软件借助这种软件在不同的技术之间共享资源，中间件位于客户机服务器的操作系统之上，管理计算资源和网络通信。</p><p>我国学术界一般认可的定义是中间件是指网络环境下处于操作系统、数据库等系统软件和应用软件之间的一种起连接作用的分布式软件，主要解决异构网络环境下分布式应用软件的互连与互操作问题，提供标准接口、协议，屏蔽实现细节，提高应用系统易移植性（北京大学梅宏）。</p><p>中科院软件所研究员仲萃豪形象地把中间件定义为平台＋通信。这个定义限定了只有用于分布式系统中的此类软件才能被称为中间件，同时此定义还可以把中间件与支撑软件和实用软件区分开来。</p><p>中间件处于操作系统软件与用户的应用软件的中间。中间件在操作系统、网络和数据库之上，应用软件的下层，总的作用是为处于自己上层的应用软件提供运行与开发的环境，帮助用户灵活、高效地开发和集成复杂的应用软件。形象地说就是上下之间的中间。</p><p>中间件主要为网络分布式计算环境提供通信服务、交换服务、语义互操作服务等系统之间的协同集成服务，解决系统之间的互连互通问题。形象地说就是所谓左右之间的中间。</p><h1 id="中间件的分类"><a href="#中间件的分类" class="headerlink" title="中间件的分类"></a>中间件的分类</h1><p>根据中间件在软件支撑和架构的定位来看，基本上可以分为三大类产品：应用服务类中间件、应用集成类中间件、业务架构类中间件。</p><h2 id="应用服务类中间件"><a href="#应用服务类中间件" class="headerlink" title="应用服务类中间件"></a>应用服务类中间件</h2><p>　　为应用系统提供一个综合的计算环境和支撑平台，包括<strong>对象请求代理（ORB）中间件、事务监控交易中间件、JAVA应用服务器中间件</strong>等。</p><p>　　随着对象技术与分布式计算技术的发展，两者相互结合形成了分布对象计算，并发展为当今软件技术的主流方向。1990年底，对象管理组织OMG首次推出对象管理结构OMA(Object Management Architecture)，对象请求代理（Object Request Broker）是这个模型的核心组件。它的作用在于提供一个通信框架，透明地在异构的分布计算环境中传递对象请求。CORBA规范包括了ORB的所有标准接口，是对象请求代理的典型代表。</p><p>　　随着分布计算技术的发展，分布应用系统对大规模的事务处理提出了需求，比如商业活动中大量的关键事务处理。事务处理监控界于Client和Server之间，进行事务管理与协调、负载平衡、失败恢复等，以提高系统的整体性能。它可以被看作是事务处理应用程序的操作系统。这类被称为交易中间件，适用于联机交易处理系统，主要功能是管理分布于不同计算机上的数据的一致性，保障系统处理能力的效率与均衡负载。交易中间件所遵循的主要标准是X/open DTP模型，典型的产品是Tuxedo。</p><p>　　JAVA从2.0企业版之后，不仅仅是一种编程语言，而且演变为一个完整的计算环境和企业架构。为JAVA应用提供组件容器，用来构造Internet应用和其它分布式构件应用，是企业实施电子商务的基础设施，这种应用服务器中间件发展到为企业应用提供数据访问、部署、远程对象调用、消息通信、安全服务、监控服务、集群服务等强化应用支撑的服务。使得JAVA应用服务器成为了事实上的应用服务器工业标准。由于它的开放性，使得交易中间件和对象请求代理逐渐融合到应用服务器之中。典型的应用服务器产品包括IBM Websphere Application Server、Oracle Weblogic Application Server和金蝶Apusic Application Server等。</p><h2 id="应用集成类中间件"><a href="#应用集成类中间件" class="headerlink" title="应用集成类中间件"></a>应用集成类中间件</h2><p>　　应用集成类中间件是提供各种不同网络应用系统之间的消息通信、服务集成和数据集成的功能，包括常见的<strong>消息中间件、企业集成EAI、企业服务总线以及相配套的适配器</strong>等。</p><p>　　消息中间件指的是利用高效可靠的消息传递机制进行平台无关的数据交流，并基于数据通信来进行分布式系统的集成。通过提供消息传递和消息排队模型，它可在分布环境下扩展进程间的通信，并支持多通讯协议、语言、应用程序、硬件和软件平台，实现应用系统之间的可靠异步消息通信，能够保障数据在复杂的网络中高效、稳定、安全、可靠的传输，并确保传输的数据不错、不重、不漏、不丢。目前流行的消息中间件产品有IBM的MQSeries、 BEA的MessageQ、金蝶Apusic MQ等。</p><p>　　企业应用整合，仅指企业内部不同应用系统之间的互连，以期通过应用整合实现数据在多个系统之间的同步和共享。这种类似集线器的架构模式是在基于消息的基础上，引入了前置机-服务器的概念，使用一种集线器/插头（hub-and-spoke）的架构，将消息路由信息的管理和维护从前置机迁移到了服务器上，巧妙的把集成逻辑和业务逻辑分离开来，大大增加了系统弹性。由于前置机和服务器之间不再直接通信，每个前置机只通过消息和服务器之间通信，将复杂的网状结构变成了简单的星型结构。典型的企业应用集成EAI的产品包括Tibico和Informatica等公司产品。</p><p>　　随着SOA思想和技术的逐渐成熟，EAI发展到透过业务服务的概念来提供IT的各项基本应用功能，让这些服务可以自由地被排列组合、融会贯通，以便在未来能随时弹性配合新的需求而调整。Web Services是SOA的一种具体实现方式，SOA的世界是由服务提供者（Service Provider）、服务请求者（Service Requester） 以及服务代理者（Service Broker）所组成，目标是将所有具备价值的IT资源，不论是旧的或新的，通通都能够透过Web Services的包装，成为随取即用的IT资产，并可将各种服务快速汇整，开发出组合式应用，达到整合即开发的目的。SOA的架构只是实现和解决了服务模块间调用的互操作问题，为了更好的服务于企业应用，引入了企业服务总线的应用架构（Enterprise Service Bus，ESB）。这一构架是基于消息通信、智能路由、数据转换等技术实现的。ESB提供了一个基于标准的松散应用耦合模式，这就是企业服务总线中间件，是一种综合的企业集成中间件。典型的ESB产品包括IBM Websphere ESB、Oracle公司的Weblogic ESB以及金蝶Apusic ESB等。</p><h2 id="业务架构类中间件"><a href="#业务架构类中间件" class="headerlink" title="业务架构类中间件"></a>业务架构类中间件</h2><p>　　作为共性的凝练，中间件不仅要从底层的技术入手，将共性技术的特征抽象进中间层，还要更多地把目光投向到业务层面上来，根据业务的需要，驱动自身能力的不断演进，即，不断出现的新的业务需要驱动了应用模式和信息系统能力的不断演进，进而要求中间件不断地凝练更多的业务共性，提供针对性支撑机制。近年来，这一需求趋势愈发明显，越来越多的业务和应用模式被不断地抽象进入中间件的层次，如业务流程流、业务模型、业务规则、交互应用等等，其结果是中间件凝练的共性功能越来越多，中间件的业务化和领域化的趋势非常明显。</p><p>　　业务架构类中间件包括业务流程、业务管理和业务交互等几个业务领域的中间件。</p><p>　　业务流程是处理业务模型的非常重要方法。管理流程与各职能部门和业务单元有密切关系，须藉各部门间的紧密协调，以达到企业运营和管理功能的目标。在业务流程支持方面，从早期的WfMC定义的工作流，到基于服务的业务流程规范BPEL，由业务流程的支撑，逐渐形成了完整的业务流程架构模型，包括流程建模、流程引擎、流程执行、流程监控和流程分析等。有名的业务流程中间件包括基于工作流的IBM Lotus Workflow，基于BPEL的IBM Webshpere Process Server以及同时支持工作流和BPEL的金蝶Apusic BPM等。</p><p>　　业务管理就是对业务对象的建模和业务规则的定义、运行和监控的中间件平台。策略管理员和开发人员将业务逻辑捕获为业务规则。使用规则管理器可以将规则轻松地嵌入 Web、现有应用程序和后台办公应用程序。常见的业务管理中间件包括<strong>IBM Websphere ILOG 业务规则管理系统，金蝶BOS</strong>等。</p><p>　　业务交互的中间件平台提供组织的合作伙伴、员工和客户通过WEB和移动设备等交互工具，实现基于角色、上下文、操作、位置、偏好和团队协作需求的个性化的用户体验。这种门户服务器软件基于标准Portlet组合的应用程序访问框架，实现用户集成和交互集成，构建灵活、基于 SOA 的应用架构。典型的门户中间件有IBM Websphere Portal Server和金蝶Apusic Portal Server等。</p><h1 id="常见中间件用例"><a href="#常见中间件用例" class="headerlink" title="常见中间件用例"></a>常见中间件用例</h1><p>从广义上讲，中间件涵盖了从 Web 服务器，到身份验证系统，再到消息传递工具等一切内容。以下是现代化开发中一些常见的中间件用例。</p><div class="table-container"><table><thead><tr><th>分类</th><th>示意图</th></tr></thead><tbody><tr><td><strong>新应用开发</strong><br>中间件可支持各种用例的现代常用运行时环境。开发人员和架构师可以采用以下基本运行时、框架和编程语言，跨平台灵活地开展工作。此外，中间件还可以提供一些常用功能，例如 Web 服务器、单点登录（SSO）、消息传递和内存中缓存。</td><td><img alt="新应用开发" data-src="//orangesching.github.io/2020/09/15/系统架构/分布式系统架构/中间件/中间件的概念及分类/新应用开发.png" class="lazyload"></td></tr><tr><td><strong>优化现有应用</strong><br>中间件可帮助开发人员将传统单体式应用转换为云原生应用，从而以更高的性能和更强的可移植性让有价值的工具焕发新生。</td><td><img alt="优化现有应用" data-src="//orangesching.github.io/2020/09/15/系统架构/分布式系统架构/中间件/中间件的概念及分类/优化现有应用.png" class="lazyload"></td></tr><tr><td><strong>全面集成</strong><br>中间件集成工具连接了关键的内部和外部系统。转换、连接、组合和企业消息传递等集成功能与 SSO 身份验证相结合，使开发人员可以更轻松地在不同应用之间扩展功能。</td><td><img alt="全面集成" data-src="//orangesching.github.io/2020/09/15/系统架构/分布式系统架构/中间件/中间件的概念及分类/全面集成.png" class="lazyload"></td></tr><tr><td><strong>应用编程接口（API）</strong><br>许多中间件服务都是通过API访问的，API 是一组允许应用之间相互通信的工具、定义和协议的集合。正是借助 API，才有可能通过公共层连接完全不同的产品和服务。</td><td><img alt="应用编程接口" data-src="//orangesching.github.io/2020/09/15/系统架构/分布式系统架构/中间件/中间件的概念及分类/应用编程接口.png" class="lazyload"></td></tr><tr><td><strong>数据流</strong><br>API 是在应用之间共享数据的方法之一，另一种方法是异步数据流。这种方法是在中间存储中复制数据集，其中的数据可在多个应用之间共享。Apache Kafka是一款常见的用于实时数据流的开源中间件工具。</td><td><img alt="数据流" data-src="//orangesching.github.io/2020/09/15/系统架构/分布式系统架构/中间件/中间件的概念及分类/数据流.png" class="lazyload"></td></tr><tr><td><strong>智能业务自动化</strong><br>中间件可以帮助开发人员、架构师、IT 和业务主管将手动决策自动化。自动化可以改善资源管理和整体效率。</td><td><img alt="智能业务自动化" data-src="//orangesching.github.io/2020/09/15/系统架构/分布式系统架构/中间件/中间件的概念及分类/智能业务自动化.png" class="lazyload"></td></tr></tbody></table></div><h1 id="Java中间件的定义"><a href="#Java中间件的定义" class="headerlink" title="Java中间件的定义"></a>Java中间件的定义</h1><p>在Java web开发的演进与进化中，我们对于消息系统，数据库，服务化接口的抽象等，涉及数据分离的过程中，在分离过程中，就会涉及到分离后系统间，数据库间的交互。java中间件就是处理我们数据间交互，连接数据分离后两个系统间的通信，中间件不属于任何一个开发项目，就是让我们对应系统间或者数据库间数据流通无感知。有点像Linux下的管道。</p><h1 id="JAVA中间件应用的基本领域与代表"><a href="#JAVA中间件应用的基本领域与代表" class="headerlink" title="JAVA中间件应用的基本领域与代表"></a>JAVA中间件应用的基本领域与代表</h1><p>远程过程调用和对象访问中间件<br>主要解决分布式环境下应用的互相访问问题，这也是支撑应用服务化功能的基础；<br>例如：RPC：Remote Process Call（远程过程调用中间件）<br>消息中间件：解决应用之间的消息传递、解耦、异步的问题。<br>例如：ActiveMQ 是Apache出品，最流行的，能力强劲的开源消息总线。ActiveMQ 是一个完全支持JMS1.1和J2EE 1.4规范的 JMS Provider实现。</p><p>数据访问中间件<br>主要解决应用访问数据库的共性问题的组件<br>例如：数据访问中间间就是我们使用数据库指定的数据驱动，例如：ODBC JDBC，以 JDBC 为例，数据库本地维护了一个数据访问中间件，我们在访问数据库的时候，配置的地址其实是直接连接到JDBC这个数据访问中间件，如果我们执行查询数据，或者对数据库的操作都是通过JDBC来连接数据库，然后通过JDBC查询完成数据库以后再返回给我们应用程序。作为中间件，查询过程对于我们是不可知的。</p><p>参考：<a href="https://blog.csdn.net/u012422446/article/details/51683525" target="_blank" rel="noopener">https://blog.csdn.net/u012422446/article/details/51683525</a></p><p><a href="https://www.cnblogs.com/lyrand/p/8138394.html" target="_blank" rel="noopener">https://www.cnblogs.com/lyrand/p/8138394.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 分布式系统架构 </category>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中间件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ性能及异常讨论</title>
      <link href="/2020/09/15/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RabbitMQ/RabbitMQ%E6%80%A7%E8%83%BD%E5%8F%8A%E5%BC%82%E5%B8%B8%E8%AE%A8%E8%AE%BA/"/>
      <url>/2020/09/15/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RabbitMQ/RabbitMQ%E6%80%A7%E8%83%BD%E5%8F%8A%E5%BC%82%E5%B8%B8%E8%AE%A8%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="性能讨论"><a href="#性能讨论" class="headerlink" title="性能讨论"></a>性能讨论</h1><h2 id="如何创建队列"><a href="#如何创建队列" class="headerlink" title="如何创建队列"></a>如何创建队列</h2><ul><li>队列影响QPS，交换器不影响</li><li>预先分配创建资源的静态方式</li><li>动态创建方式</li></ul>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
          <category> RabbitMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RabbitMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息队列概述</title>
      <link href="/2020/09/15/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%BB%BC%E8%BF%B0/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%A6%82%E8%BF%B0/"/>
      <url>/2020/09/15/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%BB%BC%E8%BF%B0/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="消息队列的使用场景"><a href="#消息队列的使用场景" class="headerlink" title="消息队列的使用场景"></a>消息队列的使用场景</h1><p>消息队列常见的使用场景有很多，但是比较核心的有 3 个：<strong>解耦</strong>、<strong>异步</strong>、<strong>削峰</strong>。</p><h2 id="解耦"><a href="#解耦" class="headerlink" title="解耦"></a>解耦</h2><p>看这么个场景。A 系统发送数据到 BCD 三个系统，通过接口调用发送。如果 E 系统也要这个数据呢？那如果 C 系统现在不需要了呢？A 系统负责人几乎崩溃……</p><p><img alt="mq-1" data-src="https://doocs.github.io/advanced-java/docs/high-concurrency/images/mq-1.png" class="lazyload"></p><p>在这个场景中，A 系统跟其它各种乱七八糟的系统严重耦合，A 系统产生一条比较关键的数据，很多系统都需要 A 系统将这个数据发送过来。A 系统要时时刻刻考虑 BCDE 四个系统如果挂了该咋办？要不要重发，要不要把消息存起来？头发都白了啊！</p><p>如果使用 MQ，A 系统产生一条数据，发送到 MQ 里面去，哪个系统需要数据自己去 MQ 里面消费。如果新系统需要数据，直接从 MQ 里消费即可；如果某个系统不需要这条数据了，就取消对 MQ 消息的消费即可。这样下来，A 系统压根儿不需要去考虑要给谁发送数据，不需要维护这个代码，也不需要考虑人家是否调用成功、失败超时等情况。</p><p><img alt="mq-2" data-src="https://doocs.github.io/advanced-java/docs/high-concurrency/images/mq-2.png" class="lazyload"></p><p><strong>总结</strong>：通过一个 MQ，Pub/Sub 发布订阅消息这么一个模型，A 系统就跟其它系统彻底解耦了。</p><blockquote><p>你需要去考虑一下你负责的系统中是否有类似的场景，就是一个系统或者一个模块，调用了多个系统或者模块，互相之间的调用很复杂，维护起来很麻烦。但是其实这个调用是不需要直接同步调用接口的，如果用 MQ 给它异步化解耦，也是可以的，你就需要去考虑在你的项目里，是不是可以运用这个 MQ 去进行系统的解耦。</p></blockquote><h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><p>再来看一个场景，A 系统接收一个请求，需要在自己本地写库，还需要在 BCD 三个系统写库，自己本地写库要 3ms，BCD 三个系统分别写库要 300ms、450ms、200ms。最终请求总延时是 3 + 300 + 450 + 200 = 953ms，接近 1s，用户感觉搞个什么东西，慢死了慢死了。用户通过浏览器发起请求，等待个 1s，这几乎是不可接受的。</p><p><img alt="mq-3" data-src="https://doocs.github.io/advanced-java/docs/high-concurrency/images/mq-3.png" class="lazyload"></p><p>一般互联网类的企业，对于用户直接的操作，一般要求是每个请求都必须在 200 ms 以内完成，对用户几乎是无感知的。</p><p>如果使用 MQ，那么 A 系统连续发送 3 条消息到 MQ 队列中，假如耗时 5ms，A 系统从接受一个请求到返回响应给用户，总时长是 3 + 5 = 8ms，对于用户而言，其实感觉上就是点个按钮，8ms 以后就直接返回了，爽！网站做得真好，真快！</p><p><img alt="mq-4" data-src="https://doocs.github.io/advanced-java/docs/high-concurrency/images/mq-4.png" class="lazyload"></p><h2 id="削峰"><a href="#削峰" class="headerlink" title="削峰"></a>削峰</h2><p>每天 0:00 到 12:00，A 系统风平浪静，每秒并发请求数量就 50 个。结果每次一到 12:00 ~ 13:00 ，每秒并发请求数量突然会暴增到 5k+ 条。但是系统是直接基于 MySQL 的，大量的请求涌入 MySQL，每秒钟对 MySQL 执行约 5k 条 SQL。</p><p>一般的 MySQL，扛到每秒 2k 个请求就差不多了，如果每秒请求到 5k 的话，可能就直接把 MySQL 给打死了，导致系统崩溃，用户也就没法再使用系统了。</p><p>但是高峰期一过，到了下午的时候，就成了低峰期，可能也就 1w 的用户同时在网站上操作，每秒中的请求数量可能也就 50 个请求，对整个系统几乎没有任何的压力。</p><p><img alt="mq-5" data-src="https://doocs.github.io/advanced-java/docs/high-concurrency/images/mq-5.png" class="lazyload"></p><p>如果使用 MQ，每秒 5k 个请求写入 MQ，A 系统每秒钟最多处理 2k 个请求，因为 MySQL 每秒钟最多处理 2k 个。A 系统从 MQ 中慢慢拉取请求，每秒钟就拉取 2k 个请求，不要超过自己每秒能处理的最大请求数量就 ok，这样下来，哪怕是高峰期的时候，A 系统也绝对不会挂掉。而 MQ 每秒钟 5k 个请求进来，就 2k 个请求出去，结果就导致在中午高峰期（1 个小时），可能有几十万甚至几百万的请求积压在 MQ 中。</p><p><img alt="mq-6" data-src="https://doocs.github.io/advanced-java/docs/high-concurrency/images/mq-6.png" class="lazyload"></p><p>这个短暂的高峰期积压是 ok 的，因为高峰期过了之后，每秒钟就 50 个请求进 MQ，但是 A 系统依然会按照每秒 2k 个请求的速度在处理。所以说，只要高峰期一过，A 系统就会快速将积压的消息给解决掉。</p><h1 id="消息队列的优缺点"><a href="#消息队列的优缺点" class="headerlink" title="消息队列的优缺点"></a>消息队列的优缺点</h1><p>优点：解耦、异步、削峰。</p><p>缺点有以下几个：</p><ul><li>系统可用性降低</li></ul><p>系统引入的外部依赖越多，越容易挂掉。本来你就是 A 系统调用 BCD 三个系统的接口就好了，ABCD 四个系统还好好的，没啥问题，你偏加个 MQ 进来，万一 MQ 挂了咋整？MQ 一挂，整套系统崩溃，你不就完了？如何保证消息队列的高可用，可以<a href="https://doocs.github.io/advanced-java/#/docs/high-concurrency/how-to-ensure-high-availability-of-message-queues" target="_blank" rel="noopener">点击这里查看</a>。</p><ul><li>系统复杂度提高</li></ul><p>硬生生加个 MQ 进来，你怎么<a href="https://doocs.github.io/advanced-java/#/docs/high-concurrency/how-to-ensure-that-messages-are-not-repeatedly-consumed" target="_blank" rel="noopener">保证消息没有重复消费</a>？怎么<a href="https://doocs.github.io/advanced-java/#/docs/high-concurrency/how-to-ensure-the-reliable-transmission-of-messages" target="_blank" rel="noopener">处理消息丢失的情况</a>？怎么保证消息传递的顺序性？头大头大，问题一大堆，痛苦不已。</p><ul><li>一致性问题</li></ul><p>A 系统处理完了直接返回成功了，人都以为你这个请求就成功了；但是问题是，要是 BCD 三个系统那里，BD 两个系统写库成功了，结果 C 系统写库失败了，咋整？你这数据就不一致了。</p><p>所以消息队列实际是一种非常复杂的架构，你引入它有很多好处，但是也得针对它带来的坏处做各种额外的技术方案和架构来规避掉，做好之后，你会发现，妈呀，系统复杂度提升了一个数量级，也许是复杂了 10 倍。但是关键时刻，用，还是得用的。</p><h1 id="如何选择合适的MQ"><a href="#如何选择合适的MQ" class="headerlink" title="如何选择合适的MQ"></a>如何选择合适的MQ</h1><p>各种MQ的优缺点对比如下：</p><div class="table-container"><table><thead><tr><th>特性</th><th>ActiveMQ</th><th>RabbitMQ</th><th>RocketMQ</th><th>Kafka</th></tr></thead><tbody><tr><td>单机吞吐量</td><td>万级，比 RocketMQ、Kafka 低一个数量级</td><td>同 ActiveMQ</td><td>10 万级，支撑高吞吐</td><td>10 万级，高吞吐，一般配合大数据类的系统来进行实时数据计算、日志采集等场景</td></tr><tr><td>topic 数量对吞吐量的影响</td><td></td><td></td><td>topic 可以达到几百/几千的级别，吞吐量会有较小幅度的下降，这是 RocketMQ 的一大优势，在同等机器下，可以支撑大量的 topic</td><td>topic 从几十到几百个时候，吞吐量会大幅度下降，在同等机器下，Kafka 尽量保证 topic 数量不要过多，如果要支撑大规模的 topic，需要增加更多的机器资源</td></tr><tr><td>时效性</td><td>ms 级</td><td>微秒级，这是 RabbitMQ 的一大特点，延迟最低</td><td>ms 级</td><td>延迟在 ms 级以内</td></tr><tr><td>可用性</td><td>高，基于主从架构实现高可用</td><td>同 ActiveMQ</td><td>非常高，分布式架构</td><td>非常高，分布式，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用</td></tr><tr><td>消息可靠性</td><td>有较低的概率丢失数据</td><td>基本不丢</td><td>经过参数优化配置，可以做到 0 丢失</td><td>同 RocketMQ</td></tr><tr><td>功能支持</td><td>MQ 领域的功能极其完备</td><td>基于 erlang 开发，并发能力很强，性能极好，延时很低</td><td>MQ 功能较为完善，还是分布式的，扩展性好</td><td>功能较为简单，主要支持简单的 MQ 功能，在大数据领域的实时计算以及日志采集被大规模使用</td></tr></tbody></table></div><p>综上，各种对比之后，有如下建议：</p><p>一般的业务系统要引入 MQ，最早大家都用 ActiveMQ，但是现在确实大家用的不多了，没经过大规模吞吐量场景的验证，社区也不是很活跃，所以大家还是算了吧，我个人不推荐用这个了；</p><p>后来大家开始用 RabbitMQ，但是确实 erlang 语言阻止了大量的 Java 工程师去深入研究和掌控它，对公司而言，几乎处于不可控的状态，但是确实人家是开源的，比较稳定的支持，活跃度也高；</p><p>不过现在确实越来越多的公司会去用 RocketMQ，确实很不错，毕竟是阿里出品，但社区可能有突然黄掉的风险（目前 RocketMQ 已捐给Apache，但 GitHub 上的活跃度其实不算高）对自己公司技术实力有绝对自信的，推荐用 RocketMQ，否则回去老老实实用 RabbitMQ 吧，人家有活跃的开源社区，绝对不会黄。</p><ul><li>中小型公司，技术实力较为一般，技术挑战不是特别高，用 RabbitMQ 是不错的选择</li><li>大型公司，基础架构研发实力较强，用 RocketMQ 是很好的选择。</li><li>大数据领域的实时计算、日志采集等场景，用 Kafka 是业内标准的，绝对没问题，社区活跃度很高，绝对不会黄，何况几乎是全世界这个领域的事实性规范。</li></ul><p>综合转载：<a href="https://doocs.github.io/advanced-java/#/./docs/high-concurrency/why-mq" target="_blank" rel="noopener">https://doocs.github.io/advanced-java/#/./docs/high-concurrency/why-mq</a></p>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
          <category> 消息队列综述 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RabbitMQ </tag>
            
            <tag> 消息队列 </tag>
            
            <tag> 中间件 </tag>
            
            <tag> ActiveMQ </tag>
            
            <tag> RocketMQ </tag>
            
            <tag> Kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ的原理</title>
      <link href="/2020/09/15/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RabbitMQ/RabbitMQ%E7%9A%84%E5%8E%9F%E7%90%86/"/>
      <url>/2020/09/15/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RabbitMQ/RabbitMQ%E7%9A%84%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
          <category> RabbitMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RabbitMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ的使用</title>
      <link href="/2020/09/15/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RabbitMQ/RabbitMQ%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2020/09/15/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RabbitMQ/RabbitMQ%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="模型架构概念"><a href="#模型架构概念" class="headerlink" title="模型架构概念"></a>模型架构概念</h2><ul><li>生产者</li><li><p>消息中间件的服务节点(Broker)</p><ul><li>交换器</li><li>队列</li><li>消息</li></ul></li><li><p>消费者</p></li></ul><h2 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h2><ul><li><p>连接（connection）</p><ul><li>TCP连接</li><li>生产者、消费者分别与Broker建立连接</li></ul></li><li><p>信道（channel）</p><ul><li>AMQP 信道</li><li>connection上的虚拟连接，实体是TCP连接</li><li>每个信道唯一ID</li></ul></li></ul><h2 id="AMQP"><a href="#AMQP" class="headerlink" title="AMQP"></a>AMQP</h2><ul><li><p>高级消息队列协议</p><ul><li>应用层协议</li></ul></li><li><p>协议层次</p><ul><li><p>Module Layer</p><ul><li>提供客户端调用命令</li></ul></li><li><p>Session Layer</p><ul><li>客户端与服务器之间的通信，传输客户端命令等</li></ul></li><li><p>Transport Layer</p><ul><li>传输二进制数据流</li></ul></li></ul></li><li><p>rabbitMQ是AMQP协议的一种实现</p><ul><li>rabbitMQ客户端方法都对应了Module Layer中的AMQP命令</li><li>对高层来说，AMQP是通过协议命令进行交互的，可以看作一系列结构化命令的集合</li></ul></li></ul><h1 id="RabbitMQ服务器常用指令"><a href="#RabbitMQ服务器常用指令" class="headerlink" title="RabbitMQ服务器常用指令"></a>RabbitMQ服务器常用指令</h1><h2 id="打开可视化界面"><a href="#打开可视化界面" class="headerlink" title="打开可视化界面"></a>打开可视化界面</h2><ul><li>rabbitmq-plugins enable rabbitmq_management</li><li><a href="http://127.0.0.1:15672/" target="_blank" rel="noopener">http://127.0.0.1:15672/</a></li><li>默认用户名密码guest</li></ul><h2 id="启动关闭"><a href="#启动关闭" class="headerlink" title="启动关闭"></a>启动关闭</h2><ul><li><p>以应用方式启动</p><ul><li>rabbitmq-server -detached 后台启动</li><li>Rabbitmq-server 直接启动，如果你关闭窗口或者需要在改窗口使用其他命令时应用就会停止</li><li>关闭:rabbitmqctl stop</li></ul></li><li><p>以服务方式启动（安装完之后在任务管理器中服务一栏能看到RabbtiMq）</p><ul><li>rabbitmq-service install 安装服务</li><li>rabbitmq-service start 开始服务</li><li>Rabbitmq-service stop  停止服务</li><li>Rabbitmq-service enable 使服务有效</li><li>Rabbitmq-service disable 使服务无效</li></ul></li></ul><h1 id="生产者-消费者常用操作"><a href="#生产者-消费者常用操作" class="headerlink" title="生产者/消费者常用操作"></a>生产者/消费者常用操作</h1><ol><li>生存者和消费者与RabbitMQ服务器建立连接</li><li>生产者/消费者创建交换器和队列</li><li>生产者生产数据</li><li>消费者消费数据</li></ol><h2 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h2><ul><li><p>生成工厂</p><p><code>ConnectionFactory factory = new ConnectionFactory()</code></p></li><li><p>设置用户名密码</p><p><code>factory.setUsername(&quot;A&quot;)</code><br><code>factory.setPassword(&quot;123&quot;)</code></p></li><li><p>设置虚拟主机（类似命名空间或权限，不同虚拟主机broker、队列等不共享）</p><p><code>facotry.setVirtualHost(virtualHost)</code></p></li><li><p>设置Borker IP和端口号</p><p><code>factory.setHost(IP)</code><br><code>factory.setPort(PORT)</code></p></li><li><p>生产(建立)连接</p><p><code>Connection conn = factory.newConnection()</code></p></li></ul><h2 id="创建交换器与队列"><a href="#创建交换器与队列" class="headerlink" title="创建交换器与队列"></a>创建交换器与队列</h2><h3 id="声明交换器-exchangDeclare"><a href="#声明交换器-exchangDeclare" class="headerlink" title="声明交换器 exchangDeclare"></a>声明交换器 exchangDeclare</h3><p><code>Exchange.DeclareOk exchangeDeclare(交换器名 , 交换器类型 , 是否持久化=true ,是否自动删除=true , 是否内置=true ,Map&lt;String, Object&gt; 其他参数) throws IOException ;</code></p><ul><li>持久化<br>保存到硬盘</li><li>自动删除<br>有队列或者交换器绑定了本交换器，然后所有队列或交换器都与本交换器解除绑定，此交换器就会被自动删除</li><li>内置<br>客户端程序无法直接发送消息到这个交换器中，只能通过交换器路由发送到交换器</li></ul><h3 id="声明队列-queueDeclare"><a href="#声明队列-queueDeclare" class="headerlink" title="声明队列 queueDeclare"></a>声明队列 queueDeclare</h3><p><code>Queue.DeclareOk queueDeclare (队列名 ,  是否持久化=true , 是否排他=true , 是否自动删除=true , Map&lt;String, Object&gt; 其他参数) throws IOException;</code></p><ul><li>持久化：保存到硬盘</li><li>排他：针对连接可见，只要是当前connection下的信道都可以访问<br>一旦该队列被声明，其他连接无法声明相同名称的排他队列。<br>队列即使显示声明为durable，连接断开时（注意不是信道断开）也会被自动删除<br>这种队列适用于一个客户端同时发送和读取消息的应用场景</li><li>自动删除<br>至少有一个消费者连接到这个队列，之后所有与这个队列连接的消费者都断开时，才会自动删除</li></ul><blockquote><p>不带任何参数的queueDeclare 方法默认创建一个由RabbitMQ 命名的(类似这种amq.gen-LhQzlgv3GhDOv8PIDabOXA 名称，这种队列也称之为匿名队列〉、排他的、自动删除的、非持久化的队列</p></blockquote><h3 id="绑定队列-queueBind"><a href="#绑定队列-queueBind" class="headerlink" title="绑定队列 queueBind"></a>绑定队列 queueBind</h3><p><code>Queue.BindOk queueBind(队列名 , 交换器名 , 绑定键, Map&lt;String, Object&gt; 其他参数) throws IOException;</code></p><h3 id="解绑队列-queueUnbind"><a href="#解绑队列-queueUnbind" class="headerlink" title="解绑队列 queueUnbind"></a>解绑队列 queueUnbind</h3><p><code>Queue. UnbindOk queueUnbind(队列名 , 交换器名 , 绑定键, Map&lt;String, Object&gt; 其他参数)  throws IOException;</code></p><h3 id="绑定交换器-exchangBind"><a href="#绑定交换器-exchangBind" class="headerlink" title="绑定交换器 exchangBind"></a>绑定交换器 exchangBind</h3><p><code>Exchange . BindOk exchangeBind(目标交换器 , 源交换器, 绑定键, Map&lt;String , Object&gt; 其他参数) throws IOException</code></p><h2 id="生产消息"><a href="#生产消息" class="headerlink" title="生产消息"></a>生产消息</h2><p>basicPublish<br><code>void basicPublish(交换器名, 路由键, mandatory, immediate , BasicProperties 消息的基本属性集 , byte[] 消息体) throws IOException ;</code></p><p><strong>消息的14个基本属性集</strong></p><ul><li>contentType </li><li>content Encoding </li><li>headers ( Map<string ， object>)</string></li><li>deliveryMode </li><li>priority </li><li>correlationld </li><li>replyTo</li><li>expiration</li><li>messageld</li><li>immediate</li><li>type</li><li>userld</li><li>appld</li><li>clusterId</li></ul><p>属性集构造方法</p><p><code>new AMQP.BasicPropertieS.Builder().headers(headers).contentType( &quot; text/plain&quot; ).build()</code></p><ul><li>mandatory：不可达时是否返回生产者</li><li>immediate：队列不存在消费之时是否放入队列</li></ul><h2 id="消费消息"><a href="#消费消息" class="headerlink" title="消费消息"></a>消费消息</h2><h3 id="接收"><a href="#接收" class="headerlink" title="接收"></a>接收</h3><p><strong>推</strong></p><p>接收消息一般通过实现Consumer 接口或者继承DefaultConsumer 类来实现。<br><code>String basicConsume(队列名 , 是否自动确认autoAck, 消费者标签同channel唯一,boolean noLocal , 是否排他, Map&lt;String ， Object&gt; 其他参数 , Consumer callback) throws IOException ;</code></p><ul><li><p>autoAck：为true则RabbitMQ 会等待消费者显式地回复确认信号后才从内存(或者磁盘)中移去消息(实质上是先打上删除标记，之后再删除)</p></li><li><p>nolocal：不能将同一个Connectio口中生产者发送的消息传送给这个Connection 中的消费者:</p></li><li><p>Consumer callback：设置消费者的回调函数。用来处理Rabb itMQ 推送过来的消息，比如DefaultConsumer ， 使用时需要客户端重写(override) 其中的方法,可重写方法很多，重写handleDelivery方便</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>订阅某一个队列中的消息,channel会自动在处理完上一条消息之后，接收下一条消息。（同一个channel消息处理是串行的）。除非关闭channel或者取消订阅，否则客户端将会一直接收队列的消息。</p></blockquote><p><strong>拉</strong></p><p><code>GetResponse basicGet(队列名 , 是否自动确认) throws IOException;</code></p><ul><li>basicGet不阻塞，如果没消息不判断就用会抛出空指针异常。要加上message==null的判空操作</li><li>basic.get RabbitMQ在实际执行的时候，是首先consume某一个队列，然后检索第一条消息，然后再取消订阅。</li></ul><p><strong>区别</strong></p><ul><li>consume是只要队列里面还有消息就一直取。</li><li>get是只取了队列里面的第一条消息。</li><li>因为get开销大，如果需要从一个队列取消息的话，首选consume方式，慎用循环get方式。</li></ul><h3 id="拒绝"><a href="#拒绝" class="headerlink" title="拒绝"></a>拒绝</h3><p><strong>拒绝一条</strong></p><p><code>void basicReject(long 消息的编号, boolean requeue) throws IOException;</code></p><ul><li>requeue：为true则会重新存回队列中</li></ul><p><strong>批量拒绝</strong></p><p><code>void basicNack(long deliveryTag, boolean multiple , boolean requeue) throws IOException;</code></p><ul><li>multiple：为true 则表示拒绝deliveryTag 编号之前所有未被当前消费者确认的消息；为false，则等于basicReject</li></ul><h2 id="关闭连接"><a href="#关闭连接" class="headerlink" title="关闭连接"></a>关闭连接</h2><ul><li>channel.close();</li><li>conn.close() ;</li></ul><h1 id="交换器类型"><a href="#交换器类型" class="headerlink" title="交换器类型"></a>交换器类型</h1><h2 id="fanout"><a href="#fanout" class="headerlink" title="fanout"></a>fanout</h2><p>交换器广播（与两键无关）<br>交换器将收到的消息全部发送给所有与之绑定的队列</p><h2 id="direct"><a href="#direct" class="headerlink" title="direct"></a>direct</h2><p>绑定键=路由键<br>将消息发送到路由键能与队列绑定键匹配的队列中</p><h2 id="topic"><a href="#topic" class="headerlink" title="topic"></a>topic</h2><p>模糊匹配绑定键与路由键</p><ul><li>direct模式的扩展，两键使用word1.word2.word3模式</li><li>路由键中加入通配符<em>和#，</em>用于匹配一个word，#用于匹配多个。如com.*可匹配绑定键位com.ABC的队列</li></ul><h2 id="headers"><a href="#headers" class="headerlink" title="headers"></a>headers</h2><ul><li>根据消息内容中的headers属性与绑定键匹配</li><li>性能差，不常见</li></ul><h2 id="system"><a href="#system" class="headerlink" title="system"></a>system</h2><h2 id="自定义"><a href="#自定义" class="headerlink" title="自定义"></a>自定义</h2><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><ul><li>一个connection可创建多个channel，多线程共享channel实例是非线程安全的不推荐使用channel和connection中的isOpen()</li><li>推荐捕获异常com.rabbitmq.client.ShutdownSignalException，该异常会在关闭状态抛出试着捕获IOExceptio口或者SocketException ，防止Connection 意外关闭。</li><li>生产者和消费者都能够使用queueDeclare 来声明一个队列，但是如果消费者在同一个信道上订阅了另一个队列，就无法再声明队列了。必须先取消订阅，然后将信道置为”传输”</li></ul>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
          <category> RabbitMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RabbitMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Canal的原理及使用</title>
      <link href="/2020/09/10/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E4%B8%8E%E4%BC%98%E5%8C%96/Canal%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BD%BF%E7%94%A8/"/>
      <url>/2020/09/10/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E4%B8%8E%E4%BC%98%E5%8C%96/Canal%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><img alt="架构" data-src="//orangesching.github.io/2020/09/10/数据库/关系型数据库/性能分析与优化/Canal的原理及使用/架构.png" class="lazyload"></p><p>canal，译意为水道/管道/沟渠，主要用途是基于 MySQL 数据库增量日志解析，提供增量数据订阅和消费</p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><ul><li>canal 模拟 MySQL slave 的交互协议，伪装自己为 MySQL slave ，向 MySQL master 发送 dump 协议</li><li>MySQL master 收到 dump 请求，开始推送 binary log 给 slave (即 canal )</li><li>canal 解析 binary log 对象(原始为 byte 流)</li></ul><blockquote><p><strong>主从复制的流程</strong></p><p><img alt="原理" data-src="//orangesching.github.io/2020/09/10/数据库/关系型数据库/性能分析与优化/Canal的原理及使用/原理.png" class="lazyload"></p><p>复制遵循三步过程：</p><ol><li>主服务器将更改记录到binlog中（这些记录称为binlog事件，可以通过来查看<code>show binary events</code>）</li><li>从服务器将主服务器的二进制日志事件复制到其中继日志。</li><li>中继日志中的从服务器重做事件随后将更新其旧数据。</li></ol></blockquote><h1 id="初步使用"><a href="#初步使用" class="headerlink" title="初步使用"></a>初步使用</h1><h2 id="Server的搭建"><a href="#Server的搭建" class="headerlink" title="Server的搭建"></a>Server的搭建</h2><h3 id="MYSQL开启Binlog功能"><a href="#MYSQL开启Binlog功能" class="headerlink" title="MYSQL开启Binlog功能"></a>MYSQL开启Binlog功能</h3><ul><li><p>MySQL开启 Binlog 写入功能，配置 binlog-format 为 ROW 模式，my.ini(Windows)/my.cof(Linux) 中配置如下</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[mysqld]</span></span><br><span class="line"><span class="attr">log-bin</span>=mysql-bin <span class="comment"># 开启 binlog</span></span><br><span class="line"><span class="attr">binlog-format</span>=ROW <span class="comment"># 选择 ROW 模式</span></span><br><span class="line"><span class="attr">server_id</span>=<span class="number">1</span> <span class="comment"># 配置 MySQL replaction 需要定义，不要和 canal 的 slaveId 重复</span></span><br></pre></td></tr></table></figure></li><li><p>授权 canal 链接 MySQL 账号具有作为 MySQL slave 的权限, 如果已有账户可直接 grant</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> canal <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">'canal'</span>;  </span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span>, <span class="keyword">REPLICATION</span> <span class="keyword">SLAVE</span>, <span class="keyword">REPLICATION</span> <span class="keyword">CLIENT</span> <span class="keyword">ON</span> *.* <span class="keyword">TO</span> <span class="string">'canal'</span>@<span class="string">'%'</span>;</span><br><span class="line"><span class="comment">-- GRANT ALL PRIVILEGES ON *.* TO 'canal'@'%' ;</span></span><br><span class="line"><span class="keyword">FLUSH</span> <span class="keyword">PRIVILEGES</span>;</span><br></pre></td></tr></table></figure></li></ul><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><ul><li><p>下载 canal, 访问 <a href="https://github.com/alibaba/canal/releases" target="_blank" rel="noopener">release 页面</a> , 选择需要的包下载</p></li><li><p>Linux解压缩 / Windows直接解压</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir /tmp/canal</span><br><span class="line">tar zxvf canal.deployer-$version.tar.gz  -C /tmp/canal</span><br></pre></td></tr></table></figure></li><li><p>解压完成后，进入canal目录，可以看到如下结构</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">drwxr-xr-x 2 jianghang jianghang  136 2013-02-05 21:51 bin</span><br><span class="line">drwxr-xr-x 4 jianghang jianghang  160 2013-02-05 21:51 conf</span><br><span class="line">drwxr-xr-x 2 jianghang jianghang 1.3K 2013-02-05 21:51 lib</span><br><span class="line">drwxr-xr-x 2 jianghang jianghang   48 2013-02-05 21:29 logs</span><br></pre></td></tr></table></figure></li><li><p>修改配置</p><p>配置文件路径<code>conf/example/instance.properties</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">## mysql serverId</span><br><span class="line">canal.instance.mysql.slaveId = 1234</span><br><span class="line">#position info，需要改成自己的数据库信息</span><br><span class="line">canal.instance.master.address = 127.0.0.1:3306 </span><br><span class="line">canal.instance.master.journal.name = </span><br><span class="line">canal.instance.master.position = </span><br><span class="line">canal.instance.master.timestamp = </span><br><span class="line">#canal.instance.standby.address = </span><br><span class="line">#canal.instance.standby.journal.name =</span><br><span class="line">#canal.instance.standby.position = </span><br><span class="line">#canal.instance.standby.timestamp = </span><br><span class="line">#username/password，需要改成自己的数据库信息</span><br><span class="line">canal.instance.dbUsername = canal  </span><br><span class="line">canal.instance.dbPassword = canal</span><br><span class="line">canal.instance.defaultDatabaseName =</span><br><span class="line">canal.instance.connectionCharset = UTF-8  # 数据库的编码方式对应到 java 中的编码类型</span><br><span class="line">#table regex</span><br><span class="line">canal.instance.filter.regex = .\*\\\\..\*</span><br></pre></td></tr></table></figure></li><li><p>启动</p><p>Linux</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh bin/startup.sh</span><br></pre></td></tr></table></figure><p>Windows</p><p>直接打开bin/starup.bat</p><p><img alt="canal服务器启动" data-src="//orangesching.github.io/2020/09/10/数据库/关系型数据库/性能分析与优化/Canal的原理及使用/canal服务器启动.png" class="lazyload"></p></li><li><p>查看 server 日志</p><p>日志路径<code>logs/canal/canal.log</code></p><p><img alt="canal服务器启动后日志" data-src="//orangesching.github.io/2020/09/10/数据库/关系型数据库/性能分析与优化/Canal的原理及使用/canal服务器启动后日志.png" class="lazyload"></p></li><li><p>查看 instance 的日志</p><p>日志路径<code>logs/example/example.log</code></p><p><img alt="example日志" data-src="//orangesching.github.io/2020/09/10/数据库/关系型数据库/性能分析与优化/Canal的原理及使用/example日志.png" class="lazyload"></p></li><li><p>关闭</p><p>linux</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh bin/stop.sh</span><br></pre></td></tr></table></figure></li></ul><h2 id="使用Client开发"><a href="#使用Client开发" class="headerlink" title="使用Client开发"></a>使用Client开发</h2><h3 id="Jar包"><a href="#Jar包" class="headerlink" title="Jar包"></a>Jar包</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line"> &lt;groupId&gt;com.alibaba.otter&lt;/groupId&gt;</span><br><span class="line"> &lt;artifactId&gt;canal.client&lt;/artifactId&gt;</span><br><span class="line"> &lt;version&gt;1.1.3&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="监听并处理消息"><a href="#监听并处理消息" class="headerlink" title="监听并处理消息"></a>监听并处理消息</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CanalClient</span> <span class="keyword">implements</span> <span class="title">ApplicationRunner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(Message msg)</span></span>&#123;</span><br><span class="line">        CanalEntry.RowChange rowChange = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (CanalEntry.Entry entry : msg.getEntries()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                rowChange = CanalEntry.RowChange.parseFrom(entry.getStoreValue());</span><br><span class="line">                List&lt;CanalEntry.RowData&gt; rows = rowChange.getRowDatasList();</span><br><span class="line">                List&lt;FzTaskLog&gt; changePoolItemSubjectsLogs = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                <span class="keyword">switch</span> (rowChange.getEventType())&#123;</span><br><span class="line">                    <span class="keyword">case</span> DELETE:</span><br><span class="line">                        <span class="keyword">for</span> (CanalEntry.RowData row : rows) &#123;</span><br><span class="line">                            List&lt;CanalEntry.Column&gt; afterColumnsList = row.getAfterColumnsList();</span><br><span class="line">                            List&lt;CanalEntry.Column&gt; beforeColumnsList = row.getBeforeColumnsList();</span><br><span class="line">                            Map&lt;String, Object&gt; afterColumnsDataMap = transforListToMap(afterColumnsList);</span><br><span class="line">                            Map&lt;String, Object&gt; beforeColumnsDataMap = transforListToMap(beforeColumnsList);</span><br><span class="line">            System.out.println(afterColumnsDataMap.toString())</span><br><span class="line">                            System.out.println(beforeColumnsDataMap.toString())  </span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> UPDATE:</span><br><span class="line">                <span class="keyword">case</span> INSERT</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(ApplicationArguments args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//连接canal</span></span><br><span class="line">        CanalConnector connector = CanalConnectors.newSingleConnector(<span class="keyword">new</span> InetSocketAddress(AddressUtils.getHostIp(), <span class="number">11111</span>), <span class="string">"example"</span>, <span class="string">""</span>, <span class="string">""</span>);</span><br><span class="line">        connector.connect();</span><br><span class="line">        <span class="comment">//订阅 监控的 数据库.表</span></span><br><span class="line">        connector.subscribe(<span class="string">"orange_learning.item_subject"</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//一次取5条</span></span><br><span class="line">            Message msg = connector.getWithoutAck(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">long</span> batchId = msg.getId();</span><br><span class="line">            <span class="keyword">int</span> size = msg.getEntries().size();</span><br><span class="line">            <span class="keyword">if</span> (batchId &lt; <span class="number">0</span> || size == <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"没有消息，休眠5秒"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                handle(msg);</span><br><span class="line">                <span class="comment">//确认消息</span></span><br><span class="line">                connector.ack(batchId);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, Object&gt; <span class="title">transforListToMap</span><span class="params">(List&lt;CanalEntry.Column&gt; afterColumnsList)</span> </span>&#123;</span><br><span class="line">        Map map = <span class="keyword">new</span> HashMap();</span><br><span class="line">        <span class="keyword">if</span> (afterColumnsList != <span class="keyword">null</span> &amp;&amp; afterColumnsList.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (CanalEntry.Column column : afterColumnsList) &#123;</span><br><span class="line">                map.put(column.getName(), column.getValue());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Client-API"><a href="#Client-API" class="headerlink" title="Client-API"></a>Client-API</h1>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> 关系型数据库 </category>
          
          <category> 性能分析与优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cannal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xxl-job的使用</title>
      <link href="/2020/09/04/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E7%B3%BB%E7%BB%9F/xxl-job%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2020/09/04/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E7%B3%BB%E7%BB%9F/xxl-job%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h1><p>其实官网教程比较清楚了，为了自己梳理整理下</p><p><a href="http://www.xuxueli.com/xxl-job/#/" target="_blank" rel="noopener">中文文档</a></p><p><a href="http://www.xuxueli.com/xxl-job/en/#/" target="_blank" rel="noopener">英文文档</a></p><h2 id="1-下载项目源码并解压"><a href="#1-下载项目源码并解压" class="headerlink" title="1.下载项目源码并解压"></a>1.下载项目源码并解压</h2><p><a href="https://github.com/xuxueli/xxl-job/releases" target="_blank" rel="noopener">Github下载</a></p><p><a href="https://gitee.com/xuxueli0323/xxl-job}" target="_blank" rel="noopener">码云下载</a></p><h2 id="2-初始化调度数据库"><a href="#2-初始化调度数据库" class="headerlink" title="2.初始化调度数据库"></a>2.初始化调度数据库</h2><p>执行调度数据库初始化SQL脚本（位置<code>/xxl-job/doc/db/tables_xxl_job.sql</code>）</p><p><img alt="调度数据库" data-src="//orangesching.github.io/2020/09/04/系统架构/分布式系统架构/分布式任务调度系统/xxl-job的使用/调度数据库.png" class="lazyload"></p><p>执行后将生成一个<code>xxl_job</code>库，库中有八张表（有些博客说时16张，好像是新版没那么多，看最终生成的表数可以自己看SQL文件中的CreateTable语句有几条）</p><p>八张表的功能</p><ul><li>xxl_job_lock：任务调度锁表</li><li>xxl_job_group：执行器信息表，维护任务执行器信息</li><li>xxl_job_info：调度扩展信息表： 用于保存XXL-JOB调度任务的扩展信息，如任务分组、任务名、机器地址、执行器、执行入参和报警邮件等等</li><li>xxl_job_log：调度日志表： 用于保存XXL-JOB任务调度的历史信息，如调度结果、执行结果、调度入参、调度机器和执行器等等</li><li>xxl_job_log_report：调度日志报表：用户存储XXL-JOB任务调度日志的报表，调度中心报表功能页面会用到</li><li>xxl_job_logglue：任务GLUE日志：用于保存GLUE更新历史，用于支持GLUE的版本回溯功能</li><li>xxl_job_registry：执行器注册表，维护在线的执行器和调度中心机器地址信息</li><li>xxl_job_user：系统用户表</li></ul><h2 id="3-编译源码"><a href="#3-编译源码" class="headerlink" title="3.编译源码"></a>3.编译源码</h2><p>按照maven格式将源码导入IDE, 使用maven进行编译</p><p>解码后可看到整个项目结构如下</p><ul><li><p>xxl-job-admin：调度中心</p></li><li><p>xxl-job-core：公共依赖</p></li><li><p>xxl-job-executor-samples：执行器Sample示例（选择合适的版本执行器，可直接使用，也可以参考其并将现有项目改造成执行器）</p><ul><li><p>xxl-job-executor-sample-springboot：Springboot版本，通过Springboot管理执行器，推荐这种方式</p></li><li><p>xxl-job-executor-sample-spring：Spring版本，通过Spring容器管理执行器，比较通用</p></li><li><p>xxl-job-executor-sample-frameless：无框架版本</p></li><li><p>xxl-job-executor-sample-jfinal：JFinal版本，通过JFinal管理执行器</p></li><li><p>xxl-job-executor-sample-nutz：Nutz版本，通过Nutz管理执行器</p></li><li><p>xxl-job-executor-sample-jboot：jboot版本，通过jboot管理执行器；</p></li></ul></li></ul><h2 id="4-配置部署调度中心"><a href="#4-配置部署调度中心" class="headerlink" title="4.配置部署调度中心"></a>4.配置部署调度中心</h2><p>调度中心在源码中的项目名：xxl-job-admin</p><p>作用：统一管理任务调度平台上调度任务，负责触发调度执行，并且提供任务管理平台。</p><h3 id="调度中心配置"><a href="#调度中心配置" class="headerlink" title="调度中心配置"></a>调度中心配置</h3><p>修改调度中心配置文件(<code>/xxl-job/xxl-job-admin/src/main/resources/application.properties</code>)内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">### 调度中心JDBC链接：链接地址请保持和 2.1章节 所创建的调度数据库的地址一致spring.datasource.url=jdbc:mysql://127.0.0.1:3306/xxl_job?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;serverTimezone=Asia/Shanghai</span><br><span class="line">spring.datasource.username=root</span><br><span class="line">spring.datasource.password=root_pwd</span><br><span class="line">spring.datasource.driver-class-name=com.mysql.jdbc.Driver</span><br><span class="line"></span><br><span class="line">### 报警邮箱</span><br><span class="line">spring.mail.host=smtp.qq.com</span><br><span class="line">spring.mail.port=25</span><br><span class="line">spring.mail.username=xxx@qq.com</span><br><span class="line">spring.mail.password=xxx</span><br><span class="line">spring.mail.properties.mail.smtp.auth=true</span><br><span class="line">spring.mail.properties.mail.smtp.starttls.enable=true</span><br><span class="line">spring.mail.properties.mail.smtp.starttls.required=true</span><br><span class="line">spring.mail.properties.mail.smtp.socketFactory.class=javax.net.ssl.SSLSocketFactory</span><br><span class="line"></span><br><span class="line">### 调度中心通讯TOKEN [选填]：非空时启用；</span><br><span class="line">xxl.job.accessToken=</span><br><span class="line">### 调度中心国际化配置 [必填]:默认为&quot;zh_CN&quot;/中文简体, 可选&quot;zh_CN&quot;/中文简体,&quot;zh_TC&quot;/中文繁体and&quot;en&quot;/英文；</span><br><span class="line">xxl.job.i18n=zh_CN</span><br><span class="line">## 调度线程池最大线程配置【必填】</span><br><span class="line">xxl.job.triggerpool.fast.max=200</span><br><span class="line">xxl.job.triggerpool.slow.max=100</span><br><span class="line">### 调度中心日志表数据保存天数 [必填]：过期日志自动清理；限制大于等于7时生效，否则, 如-1，关闭自动清理功能；</span><br><span class="line">xxl.job.logretentiondays=30</span><br></pre></td></tr></table></figure><h3 id="部署项目"><a href="#部署项目" class="headerlink" title="部署项目"></a>部署项目</h3><p>该工程是一个springboot项目，配置后执行 <code>XxlJobAdminApplication</code>类即可运行该工程</p><p>调度中心访问地址：<a href="http://localhost:8080/xxl-job-admin" target="_blank" rel="noopener">http://localhost:8080/xxl-job-admin</a>  默认登录账号 “admin/123456”, 登录后运行界面如下图所示。</p><p><img alt="调度中心UI" data-src="//orangesching.github.io/2020/09/04/系统架构/分布式系统架构/分布式任务调度系统/xxl-job的使用/调度中心UI.png" class="lazyload"></p><p>出现该页面表示调度中心已经部署成功</p><h2 id="5-配置部署执行器"><a href="#5-配置部署执行器" class="headerlink" title="5.配置部署执行器"></a>5.配置部署执行器</h2><p>作者提供了各种执行器的例子在<code>/xxl-job/xxl-job-executor-samples/</code>中，下面是以<code>xxl-job-executor-samples-spring</code>为模板自己写执行器的过程。也可以直接运行提供的执行器。注意此处用的是2.2.0版本，移除了旧类注解<code>@JobHandler</code>，使用基于方法注解 <code>@XxlJob</code> 的方式进行任务开发。即之前用<code>@JobHandler</code>标注类，现在用<code>@XxlJob</code>标注方法，两个功能一致。</p><h3 id="maven依赖"><a href="#maven依赖" class="headerlink" title="maven依赖"></a>maven依赖</h3><p>确认pom文件中引入了 <code>xxl-job-core</code> 的maven依赖；</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--父级依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.orange<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>orange<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>orange<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">description</span>&gt;</span>orange learn java<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- MySql --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- xxl-rpc-core --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.xuxueli<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>xxl-job-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span>   <span class="comment">&lt;!--注意版本要和调度中心使用的xxl版本一致--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="执行器配置"><a href="#执行器配置" class="headerlink" title="执行器配置"></a>执行器配置</h3><p>作者提供的示例执行器配置文件地址：</p><p><code>xxl-job-executor-samples/xxl-job-executor-sample-springboot/src/main/resources/application.properties</code></p><p>执行器配置，配置内容说明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8082    # 一定要配置，不然会默认连接8080与调度中心端口号冲突</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: demo</span><br><span class="line">  profiles:</span><br><span class="line">    active: dev</span><br><span class="line">  # Mysql数据库配置</span><br><span class="line">  datasource:</span><br><span class="line">    url: jdbc:mysql://127.0.0.1:3306/orange_learning?useUnicode=true&amp;characterEncoding=UTF8&amp;useSSL=false</span><br><span class="line">    username: root</span><br><span class="line">    password: .a123456</span><br><span class="line"></span><br><span class="line"># xxl配置</span><br><span class="line">xxl:</span><br><span class="line">  job:</span><br><span class="line">    accessToken:</span><br><span class="line">    admin:</span><br><span class="line">      #调度中心部署跟地址：如调度中心集群部署存在多个地址则用逗号分隔。</span><br><span class="line">      #执行器将会使用该地址进行&quot;执行器心跳注册&quot;和&quot;任务结果回调&quot;。</span><br><span class="line">      addresses: http://127.0.0.1:8080/xxl-job-admin</span><br><span class="line"></span><br><span class="line">    #分别配置执行器的名称、ip地址、端口号</span><br><span class="line">    #注意：如果配置多个执行器时，防止端口冲突</span><br><span class="line">    executor:</span><br><span class="line">      appname: orangeDemo</span><br><span class="line">      ip:</span><br><span class="line">      address:</span><br><span class="line">      port: 9998</span><br><span class="line">      #执行器运行日志文件存储的磁盘位置，需要对该路径拥有读写权限</span><br><span class="line">      logpath: /data/applogs/xxl-job/jobhandler</span><br><span class="line">      #执行器Log文件定期清理功能，指定日志保存天数，日志文件过期自动删除。限制至少保持3天，否则功能不生效；</span><br><span class="line">      logretentiondays: 30</span><br></pre></td></tr></table></figure><h3 id="执行器组件配置"><a href="#执行器组件配置" class="headerlink" title="执行器组件配置"></a>执行器组件配置</h3><p>执行器组件，配置文件地址：</p><p><code>xxl-job-executor-sample-springboot/src/main/java/com/xxl/job/executor/core/config/XxlJobConfig.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XxlJobConfig</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(XxlJobConfig.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;xxl.job.admin.addresses&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String adminAddresses;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;xxl.job.accessToken&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String accessToken;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;xxl.job.executor.appname&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String appname;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;xxl.job.executor.address&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;xxl.job.executor.ip&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String ip;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;xxl.job.executor.port&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;xxl.job.executor.logpath&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String logPath;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;xxl.job.executor.logretentiondays&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> logRetentionDays;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> XxlJobSpringExecutor <span class="title">xxlJobExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job config init."</span>);</span><br><span class="line">        XxlJobSpringExecutor xxlJobSpringExecutor = <span class="keyword">new</span> XxlJobSpringExecutor();</span><br><span class="line">        xxlJobSpringExecutor.setAdminAddresses(adminAddresses);</span><br><span class="line">        xxlJobSpringExecutor.setAppname(appname);</span><br><span class="line">        xxlJobSpringExecutor.setAddress(address);</span><br><span class="line">        xxlJobSpringExecutor.setIp(ip);</span><br><span class="line">        xxlJobSpringExecutor.setPort(port);</span><br><span class="line">        xxlJobSpringExecutor.setAccessToken(accessToken);</span><br><span class="line">        xxlJobSpringExecutor.setLogPath(logPath);</span><br><span class="line">        xxlJobSpringExecutor.setLogRetentionDays(logRetentionDays);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> xxlJobSpringExecutor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="添加执行器"><a href="#添加执行器" class="headerlink" title="添加执行器"></a>添加执行器</h3><p>进入调度中心，选择执行器管理-&gt;新增来新增一个执行器信息。作者提供的范例默认添加了，无需这个步骤（可以看到执行器列表里面有xxl-job-executor-sample执行器，就是默认的范例）</p><p><img alt="新增执行器" data-src="//orangesching.github.io/2020/09/04/系统架构/分布式系统架构/分布式任务调度系统/xxl-job的使用/新增执行器.png" class="lazyload"></p><p><a href="#执行器属性详情">执行器属性详情</a></p><h3 id="部署执行器项目"><a href="#部署执行器项目" class="headerlink" title="部署执行器项目"></a>部署执行器项目</h3><p>配置后执行<code>XxlJobExecutorApplication</code>类/自己写的类</p><p>执行器运行后会向调度中心注册，在调度中心的UI上的执行器管理界面可以查看到机器地址，没有注册时是无</p><p><img alt="执行器运行展示" data-src="//orangesching.github.io/2020/09/04/系统架构/分布式系统架构/分布式任务调度系统/xxl-job的使用/执行器运行展示.png" class="lazyload"></p><h2 id="6-开发一个Bean模式任务"><a href="#6-开发一个Bean模式任务" class="headerlink" title="6.开发一个Bean模式任务"></a>6.开发一个Bean模式任务</h2><p>本示例以新建一个 <code>Bean模式</code>运行模式的任务为例。</p><h3 id="新建任务代码"><a href="#新建任务代码" class="headerlink" title="新建任务代码"></a>新建任务代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@XxlJob</span>(<span class="string">"orangeHandler"</span>)   <span class="comment">// 旧版用的JobHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ReturnT&lt;String&gt; <span class="title">demoJobHandler</span><span class="params">(String param)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        XxlJobLogger.log(<span class="string">"Orange, Hello World."</span>);</span><br><span class="line">        <span class="keyword">return</span> ReturnT.SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>旧版的写法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JobHandler</span>(value = <span class="string">"orangeHandler"</span>)</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoJobHandler</span> <span class="keyword">extends</span> <span class="title">IJobHandler</span> </span>&#123;   <span class="comment">// 要统一继承IJobHandler并重写execute方法</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ReturnT&lt;String&gt; <span class="title">execute</span><span class="params">(String param)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        XxlJobLogger.log(<span class="string">"Orange, Hello World."</span>);</span><br><span class="line">        <span class="keyword">return</span> ReturnT.SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="调度中心新建任务"><a href="#调度中心新建任务" class="headerlink" title="调度中心新建任务"></a>调度中心新建任务</h3><p>登录调度中心，点击下图所示“新建任务”按钮，新建示例任务。然后，参考下面截图中任务的参数配置，点击保存。</p><p><img alt="新建任务" data-src="//orangesching.github.io/2020/09/04/系统架构/分布式系统架构/分布式任务调度系统/xxl-job的使用/新建任务.png" class="lazyload"></p><p><img alt="新增任务信息" data-src="//orangesching.github.io/2020/09/04/系统架构/分布式系统架构/分布式任务调度系统/xxl-job的使用/新增任务信息.png" class="lazyload"></p><p><a href="#任务属性详情">任务属性详情</a></p><h2 id="6-开发一个GLUE模式任务"><a href="#6-开发一个GLUE模式任务" class="headerlink" title="6.开发一个GLUE模式任务"></a>6.开发一个GLUE模式任务</h2><h3 id="调度中心新建任务-1"><a href="#调度中心新建任务-1" class="headerlink" title="调度中心新建任务"></a>调度中心新建任务</h3><p>可以看到不需要JobHandler，因为GLUE模式(Java)运行模式的任务实际上是一段继承自IJobHandler的Java类代码，它在执行器项目中运行，代码由调度中心维护</p><p><img alt="image-20200907093834722" data-src="//orangesching.github.io/2020/09/04/系统架构/分布式系统架构/分布式任务调度系统/xxl-job的使用/新增任务信息2.png" class="lazyload"></p><h3 id="编辑任务代码"><a href="#编辑任务代码" class="headerlink" title="编辑任务代码"></a>编辑任务代码</h3><p>新增任务后，点击操作-&gt;GLUE IDE编辑具体任务代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xxl.job.service.handler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.xxl.job.core.log.XxlJobLogger;</span><br><span class="line"><span class="keyword">import</span> com.xxl.job.core.biz.model.ReturnT;</span><br><span class="line"><span class="keyword">import</span> com.xxl.job.core.handler.IJobHandler;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承IJboHandelr</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoGlueJobHandler</span> <span class="keyword">extends</span> <span class="title">IJobHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ReturnT&lt;String&gt; <span class="title">execute</span><span class="params">(String param)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">XxlJobLogger.log(<span class="string">"Orange, Hello World."</span>);</span><br><span class="line"><span class="keyword">return</span> ReturnT.SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-执行并查看结果"><a href="#7-执行并查看结果" class="headerlink" title="7.执行并查看结果"></a>7.执行并查看结果</h2><h3 id="触发执行"><a href="#触发执行" class="headerlink" title="触发执行"></a>触发执行</h3><p>点击任务右侧 操作-&gt;执行一次  按钮，可手动触发一次任务执行（通常情况下，点击启动后，通过配置Cron表达式进行任务调度触发）</p><h3 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h3><p>请点击任务右侧 操作-&gt;查询日志 按钮，可前往任务日志界面查看任务日志</p><p>在任务日志界面中，可查看该任务的历史调度记录以及每一次调度的任务调度信息、执行参数和执行信息。</p><p>运行中的任务点击右侧的 执行日志 按钮，可进入日志控制台查看实时执行日志。</p><p><img alt="查看日志" data-src="//orangesching.github.io/2020/09/04/系统架构/分布式系统架构/分布式任务调度系统/xxl-job的使用/查看日志.png" class="lazyload"></p><p>在日志控制台，可以Rolling方式实时查看任务在执行器一侧运行输出的日志信息，实时监控任务进度</p><p>最终可看到运行结果如下</p><p><img alt="最终运行结果" data-src="//orangesching.github.io/2020/09/04/系统架构/分布式系统架构/分布式任务调度系统/xxl-job的使用/最终运行结果.png" class="lazyload"></p><h1 id="任务配置属性"><a href="#任务配置属性" class="headerlink" title="任务配置属性"></a><span id="任务属性详情">任务配置属性</span></h1><p><img alt="新增任务信息" data-src="//orangesching.github.io/2020/09/04/系统架构/分布式系统架构/分布式任务调度系统/xxl-job的使用/新增任务信息.png" class="lazyload"></p><ul><li>执行器：任务的绑定的执行器，任务触发调度时将会自动发现注册成功的执行器, 实现任务自动发现功能; 另一方面也可以方便的进行任务分组。每个任务必须绑定一个执行器, 可在 “执行器管理” 进行设置;</li><li>JobHandler：运行模式为 “BEAN模式” 时生效，对应执行器中新开发的JobHandler类“@JobHandler”注解自定义的value值；</li><li>子任务：每个任务都拥有一个唯一的任务ID(任务ID可以从任务列表获取)，当本任务执行结束并且执行成功时，将会触发子任务ID所对应的任务的一次主动调度。</li><li>任务超时时间：支持自定义任务超时时间，任务运行超时将会主动中断任务；</li><li>失败重试次数；支持自定义任务失败重试次数，当任务失败时将会按照预设的失败重试次数主动进行重试；</li><li>报警邮件：任务调度失败时邮件通知的邮箱地址，支持配置多邮箱地址，配置多个邮箱地址时用逗号分隔；</li><li>执行参数：任务执行所需的参数；</li></ul><h2 id="Cron表达式"><a href="#Cron表达式" class="headerlink" title="Cron表达式"></a>Cron表达式</h2><p>Cron表达式是一个字符串，字符串以空格隔开，分为6或7个域，每一个域代表一个含义</p><p>Corn从左到右的域（用空格隔开）分别表示：秒 分 小时 日期 月份 星期 [年份(可选)]</p><p>各域的含义</p><div class="table-container"><table><thead><tr><th>域</th><th>允许值</th><th>允许的特殊字符</th></tr></thead><tbody><tr><td>秒（Seconds）</td><td>0~59的整数</td><td>, - * /   四个字符</td></tr><tr><td>分（<em>Minutes</em>）</td><td>0~59的整数</td><td>, - * /   四个字符</td></tr><tr><td>小时（<em>Hours</em>）</td><td>0~23的整数</td><td>, - * /   四个字符</td></tr><tr><td>日期（<em>DayofMonth</em>）</td><td>1~31的整数（但是你需要考虑你月的天数）</td><td>,- * ? / L W C   八个字符</td></tr><tr><td>月份（<em>Month</em>）</td><td>1~12的整数或者 JAN-DEC</td><td>, - * /   四个字符</td></tr><tr><td>星期（<em>DayofWeek</em>）</td><td>1~7的整数或者 SUN-SAT （1=SUN）</td><td>, - * ? / L C #   八个字符</td></tr><tr><td>年(可选，留空)（<em>Year</em>）</td><td>1970~2099</td><td>, - * /   四个字符</td></tr></tbody></table></div><p>特殊字符</p><div class="table-container"><table><thead><tr><th>符</th><th>详情</th><th></th></tr></thead><tbody><tr><td>*</td><td>任意值</td><td>Minutes=*,，意味着每分钟都会触发事件</td></tr><tr><td>?</td><td>任意值</td><td>DayofMonth=20 DayofWeek=?，意味着在每月的20日触发调度，不管20日到底是星期几</td></tr><tr><td>-</td><td>表范围</td><td>Minutes=5-20，意味着从5分到20分钟每分钟触发一次</td></tr><tr><td>/</td><td>表起始时间开始触发，每隔固定时间触发一次</td><td>Minutes=5/20，意味着5分开始触发，每隔20分钟触发一次</td></tr><tr><td>,</td><td>列出枚举值，枚举值用<code>,</code>隔开</td><td>Minutes=5,20，意味着在5和20分每分钟触发一次</td></tr><tr><td>L</td><td>表最后</td><td>DayofWeek=5L，意味着在最后的一个星期四触发</td></tr><tr><td>W</td><td>表有效工作日，系统将在离指定日期的最近的有效工作日触发事件，注意：W的最近寻找不会跨过月份</td><td>DayofMonth=5W，意味着如果5日是星期六，则将在最近的工作日：星期五，即4日触发。如果5日是星期天，则在6日(周一)触发</td></tr><tr><td>LW</td><td>表示在某月最后一个工作日，即最后一个星期五</td><td></td></tr><tr><td>#</td><td>每个月第几个星期几</td><td>DayofMonth=4#2，意味着某月的第二个星期三</td></tr></tbody></table></div><h2 id="路由策略"><a href="#路由策略" class="headerlink" title="路由策略"></a>路由策略</h2><p>当执行器集群部署时，提供丰富的路由策略：</p><ul><li><p>FIRST（第一个）：固定选择第一个机器</p></li><li><p>LAST（最后一个）：固定选择最后一个机器；</p></li><li>ROUND（轮询）：顺序循环的选择机器；</li><li>RANDOM（随机）：随机选择在线的机器；</li><li>CONSISTENT_HASH（一致性HASH）：每个任务按照Hash算法固定选择某一台机器，且所有任务均匀散列在不同机器上。</li><li>LEAST_FREQUENTLY_USED（最不经常使用）：使用频率最低的机器优先被选举；</li><li>LEAST_RECENTLY_USED（最近最久未使用）：最久未使用的机器优先被选举；</li><li>FAILOVER（故障转移）：按照顺序依次进行心跳检测，第一个心跳检测成功的机器选定为目标执行器并发起调度；</li><li>BUSYOVER（忙碌转移）：按照顺序依次进行空闲检测，第一个空闲检测成功的机器选定为目标执行器并发起调度；</li><li>SHARDING_BROADCAST(分片广播)：广播触发对应集群中所有机器执行一次任务，同时系统自动传递分片参数；可根据分片参数开发分片任务；</li></ul><h2 id="阻塞处理策略"><a href="#阻塞处理策略" class="headerlink" title="阻塞处理策略"></a>阻塞处理策略</h2><p>调度过于密集执行器来不及处理时的处理策略</p><ul><li><p>单机串行（默认）：调度请求进入单机执行器后，调度请求进入FIFO队列并以串行方式运行；</p></li><li><p>丢弃后续调度：调度请求进入单机执行器后，发现执行器存在运行的调度任务，本次请求将会被丢弃并标记为失败；</p></li><li>覆盖之前调度：调度请求进入单机执行器后，发现执行器存在运行的调度任务，将会终止运行中的调度任务并清空队列，然后运行本地调度任务；</li></ul><h2 id="运行模式"><a href="#运行模式" class="headerlink" title="运行模式"></a>运行模式</h2><ul><li><strong>BEAN模式</strong>：任务以JobHandler方式维护在执行器端；需要结合 <code>@JobHandler / @XxlJob</code>“属性匹配执行器中任务；</li><li><strong>GLUE模式(Java)</strong>：任务以源码方式维护在调度中心；该模式的任务实际上是一段继承自<code>IJobHandler</code>的Java类代码并 <code>groovy</code>源码方式维护，它在执行器项目中运行，可使用<code>@Resource / @Autowire</code>注入执行器里中的其他服务；</li><li><strong>GLUE模式(Shell)</strong>：任务以源码方式维护在调度中心；该模式的任务实际上是一段 “shell” 脚本；</li><li><strong>GLUE模式(Python)</strong>：任务以源码方式维护在调度中心；该模式的任务实际上是一段 “python” 脚本；</li><li><strong>GLUE模式(PHP)</strong>：任务以源码方式维护在调度中心；该模式的任务实际上是一段 “php” 脚本；</li><li><strong>GLUE模式(NodeJS)</strong>：任务以源码方式维护在调度中心；该模式的任务实际上是一段 “nodejs” 脚本；</li><li><strong>GLUE模式(PowerShell)</strong>：任务以源码方式维护在调度中心；该模式的任务实际上是一段 “PowerShell” 脚本；</li></ul><h1 id="执行器配置属性"><a href="#执行器配置属性" class="headerlink" title="执行器配置属性"></a><span id="执行器属性详情">执行器配置属性</span></h1><p><img alt="新增执行器" data-src="//orangesching.github.io/2020/09/04/系统架构/分布式系统架构/分布式任务调度系统/xxl-job的使用/新增执行器.png" class="lazyload"></p><ul><li>AppName: 是每个执行器集群的唯一标示AppName, 执行器会周期性以AppName为对象进行自动注册。可通过该配置自动发现注册成功的执行器, 供任务调度时使用</li><li>名称: 执行器的名称, 因为AppName限制字母数字等组成,可读性不强, 名称为了提高执行器的可读性</li><li>排序: 执行器的排序, 系统中需要执行器的地方,如任务新增, 将会按照该排序读取可用的执行器列表</li><li>注册方式：调度中心获取执行器地址的方式</li><li>自动注册：执行器自动进行执行器注册，调度中心通过底层注册表可以动态发现执行器机器地址</li><li>手动录入：人工手动录入执行器的地址信息，多地址逗号分隔，供调度中心使用</li><li>机器地址：”注册方式”为”手动录入”时有效，支持人工维护执行器的地址信息</li></ul><h1 id="一些错误的解决"><a href="#一些错误的解决" class="headerlink" title="一些错误的解决"></a>一些错误的解决</h1><h2 id="xxl-job-registry-error"><a href="#xxl-job-registry-error" class="headerlink" title="xxl-job registry error"></a>xxl-job registry error</h2><p><img alt="错误" data-src="//orangesching.github.io/2020/09/04/系统架构/分布式系统架构/分布式任务调度系统/xxl-job的使用/错误1.png" class="lazyload"></p><p>报错xxl-job registry error底下是302时，检查调度中心的xxl-job版本和执行器的一不一样</p><p>参考：</p><p><a href="https://www.cnblogs.com/daxiangfei/p/10219706.html" target="_blank" rel="noopener">https://www.cnblogs.com/daxiangfei/p/10219706.html</a></p><p><a href="https://www.xuxueli.com/xxl-job/" target="_blank" rel="noopener">https://www.xuxueli.com/xxl-job/</a></p><p><a href="https://www.jianshu.com/p/fa7186bea84b" target="_blank" rel="noopener">https://www.jianshu.com/p/fa7186bea84b</a></p>]]></content>
      
      
      <categories>
          
          <category> 分布式系统架构 </category>
          
          <category> 分布式任务调度系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xxl-job </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式任务调度系统概述</title>
      <link href="/2020/09/04/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"/>
      <url>/2020/09/04/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是分布式任务调度？"><a href="#什么是分布式任务调度？" class="headerlink" title="什么是分布式任务调度？"></a>什么是分布式任务调度？</h1><p>分布式任务调度，三个关键词：分布式、任务调度、配置中心。</p><ul><li><p>分布式：平台是分布式部署的，各个节点之间可以无状态和无限的水平扩展</p></li><li><p>任务调度：是指基于<strong>给定的时间点 / 给定的时间间隔 / 给定执行次数自动</strong>的执行任务。包括 任务状态管理、任务调度请求收发、具体任务的分配、任务的具体执行（分配到哪些机器上处理）。涉及到多线程并发、运行时间规则定制及解析、线程池的维护等诸多方面的工作</p></li><li><p>配置中心：可以感知整个集群的状态、任务信息的注册，解决一共要处理哪些任务、任务要分配到哪些机器上处理、任务分发的时候判断哪些机器可以用等问题</p></li></ul><p>一个分布式任务调度系统需要以下内容：</p><ul><li>Web模块：用来提供任务的信息，控制任务的状态、信息展示等</li><li>Server模块：负责接收web端传来的任务执行的信息，下发任务调度请求给Scheduler，会去注册中心进行注册</li><li>Scheduler模块：接收server端传来的调度请求，将任务进行更加细化的拆分然后下发，到注册中心进行注册，获取到可以干活的worker</li><li>Worker模块：负责具体的任务执行</li><li>注册中心</li></ul><h1 id="任务调度发展历史"><a href="#任务调度发展历史" class="headerlink" title="任务调度发展历史"></a>任务调度发展历史</h1><p>任务调度随着技术发展，从单线程调度到多线程调度，从单机部署到集群部署，从独立执行到多任务协同执行。</p><p><img alt="任务调度发展历史" data-src="//orangesching.github.io/2020/09/04/系统架构/分布式系统架构/分布式任务调度系统/分布式任务调度系统概述/任务调度发展历史.jpg" class="lazyload"></p><ul><li><p>第一阶段<br>单线程调度，在Java1.5之前，基于线程的等待(sleep或wait)机制定时执行，需要开发者实现调度逻辑，单个线程(Thread)处理单个任务有些浪费，但是一个线程(Timer)处理多个任务容易因为某个任务繁忙导致其他任务阻塞。</p></li><li><p>第二阶段<br>线程池调度，在Java1.5开始提供ScheduledExecutorService调度线程池，调度线程池支持固定的延时和固定间隔模式，对于需要在某天或者某月的时间点执行就不大方便，需要计算时间间隔，转换成启动延时和固定间隔，处理起来比较麻烦。</p></li><li><p>第三阶段<br>Spring任务调度，Spring简化了任务调度，通过@Scheduled注解支持将某个Bean的方法定时执行，除了支持固定延时和固定间隔模式外，还支持cron表达式，使得定时任务的开发变得极其简单。</p></li><li><p>第四阶段<br>Quartz任务调度，在任务服务集群部署下，Quartz通过数据库锁，实现任务的调度并发控制，避免同一个任务同时执行的情况。Quartz通过Scheduler提供了任务调度API，开发可以基于此开发自己的任务调度管理平台。</p></li><li><p>第五阶段<br>分布式任务平台，提供一个统一的平台，无需再去做和调度相关的开发，业务系统只需要实现具体的任务逻辑，自动注册到任务调度平台，在上面进行相关的配置就完成了定时任务的开发。</p></li></ul><h1 id="常见的任务调度框架"><a href="#常见的任务调度框架" class="headerlink" title="常见的任务调度框架"></a>常见的任务调度框架</h1><p>常见的分布式任务调度框架有：cronsun、Elastic-job、saturn、lts、TBSchedule、xxl-job等</p><h2 id="cronsun"><a href="#cronsun" class="headerlink" title="cronsun"></a>cronsun</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>cronsun是一个分布式任务系统，单个节点和Linux机器上的contab近似，是为了解决多台Linux机器上crontab任务管理不方便的问题，同时提供了任务高可用的支持（当某个节点死机的时候可以自动调整到正常的节点执行）。与此同时，它还支持界面管理机器上的任务，支持任务失败邮件提醒，安装简单，使用简便，是替换crontab的一个不错的选择。</p><blockquote><p><strong>crontab</strong>是Linux系统里面最简单易用的定时任务管理工具，在Linux上由crond来周期性的执行指令列表，执行的任务称为cron job。但是当crontab分布在多个服务器时带来一些问题：</p><ol><li>大量的crontab分散在各台服务器，带来了很高的维护成本；</li><li>任务没有按时执行，过了很长的时间才能发现，需要重试或者排查；</li><li>crontab分散在很多集群上，需要一台一台的去查看日志；</li><li>crontab存在单点问题，对于不能重复执行的定时任务很伤脑；</li></ol><p>因此非常需要一个集中管理定时任务的系统，于是就有了cronsun</p></blockquote><h3 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h3><p>cronsun中主要有三个组件，都是通过etcd通讯的。</p><ul><li>cronnode负责节点的分组及节点的状态</li><li>cronweb是用来管理任务的、任务的执行结果都可以在上面看</li></ul><p><img alt="cronsun三个组件" data-src="//orangesching.github.io/2020/09/04/系统架构/分布式系统架构/分布式任务调度系统/分布式任务调度系统概述/cronsun三个组件.png" class="lazyload"></p><blockquote><p>etcd是一个开源的、分布式的键值对数据存储系统，提供共享配置、服务的注册和发现。etcd内部采用raft协议作为一致性算法，是基于Go语言实现的。</p></blockquote><p>所有的任务都会存储在一个分布式etcd里，单个crond部署成一个服务，也就是图中所示的node.1、node.2、node.n等，然后再由web界面去管理。如果任务执行失败的话，会发送失败的邮件，当单个节点死机的时候，也会自动调整到正常的节点去执行任务。</p><p><img alt="cronsun架构" data-src="//orangesching.github.io/2020/09/04/系统架构/分布式系统架构/分布式任务调度系统/分布式任务调度系统概述/cronsun架构.png" class="lazyload"></p><h2 id="Quartz"><a href="#Quartz" class="headerlink" title="Quartz"></a>Quartz</h2><p>Quartz是OpenSymphony开源组织在任务调度领域的一个开源项目，完全基于java实现。</p><p>Quartz具有以下特点：强大的调度功能、灵活的应用方式、分布式和集群能力，另外作为spring默认的调度框架，很容易实现与Spring集成，实现灵活可配置的调度功能。</p><p>Quartz的核心元素如下：</p><ol><li>Scheduler：任务调度器，是实际执行任务调度的控制器</li><li>Trigger；触发器，用于定义任务调度的时间规则</li><li>Calendar：它是一些日历特定时间的集合，一个Trigger可以包含多个Calendar，以便于排除或包含某些时间点</li><li>JobDetail：用来描述Job实现类及其他相关的静态信息，如Job的名字、关联监听器等信息</li><li><p>Job：是一个接口，只有一个方法void execute(JobExecutionContext context)，开发者实现该接口定义运行任务，JobExecutionContext类提供了调度上下文的各种信息</p><h3 id="Quartz单机版"><a href="#Quartz单机版" class="headerlink" title="Quartz单机版"></a>Quartz单机版</h3></li></ol><p>Quartz单机版的集群方案是使用数据库来实现的。集群架构如下：</p><p><img alt="Quartz单机版架构" data-src="//orangesching.github.io/2020/09/04/系统架构/分布式系统架构/分布式任务调度系统/分布式任务调度系统概述/Quartz单机版架构.png" class="lazyload"></p><p>上图3个节点在数据库中都有同一份Job定义，如果某一个节点失效，那么Job会在其他节点上执行。</p><p>如何保证只有一台机器上触发呢？答案是使用了数据库锁。在quartz集群有张scheduler_locks，采用了悲观锁的方式对triggers表进行了行加锁，以保证任务同步的正确性。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>简单来说，quartz的分布式调度策略是以数据库为边界的一种异步策略。各个调度器都遵守一个基于数据库锁的操作规则从而保证了操作的唯一性，同时多个节点的异步运行保证了服务的可靠。</p><p>但这种策略有自己的局限性：集群特性对于高CPU使用率的任务效果特别好，但是对于大量的短任务，各个节点都会抢占数据库锁，这样就出现大量的线程等待资源。Quartz的分布式只解决了任务高可用的问题，并没有解决任务分片的问题，还是会有单机处理的极限。</p><h2 id="Elastic-job"><a href="#Elastic-job" class="headerlink" title="Elastic-job"></a>Elastic-job</h2><p>Elastic-job是当当开源的一款非常好用的作业框架，Elastic-job在2.x之后，出现了两个相互独立的产品线：Elastic-job-lite和Elastic-job-cloud。</p><h3 id="Elastic-job-lite"><a href="#Elastic-job-lite" class="headerlink" title="Elastic-job-lite"></a>Elastic-job-lite</h3><p>Elastic-job-lite定位为轻量级无中心化的解决方案，使用jar包的形式提供分布式任务的协调服务，外部依赖仅依赖于zookeeper。</p><p><img alt="Elastic-job-lite" data-src="//orangesching.github.io/2020/09/04/系统架构/分布式系统架构/分布式任务调度系统/分布式任务调度系统概述/Elastic-job-lite.png" class="lazyload"></p><h4 id="系统架构-1"><a href="#系统架构-1" class="headerlink" title="系统架构"></a>系统架构</h4><p><img alt="Elastic-job-lite系统架构" data-src="//orangesching.github.io/2020/09/04/系统架构/分布式系统架构/分布式任务调度系统/分布式任务调度系统概述/Elastic-job-lite系统架构.png" class="lazyload"></p><p><code>Elastic-job-lite</code>框架使用<code>zookeeper</code>作为注册中心，<code>Elastic-job-lite</code>框架通过监听感知<code>zookeeper</code>数据的变化，并做相应的处理；运维平台也仅是通过读取zk数据来展现作业状态，或是更新<code>zookeeper</code>数据修改全局配置。运维平台和<code>Elastic-job-lite</code>没有直接的关系，完全解耦合。</p><p><code>Elastic-job-lite</code>并不直接提供数据处理的功能，框架只会将分片项分配给各个正在运行中的服务器，分片项与真实数据的对应关系需要开发者在应用程序中自行处理。</p><p><code>Elastic-job-lite</code>并无作业调度中心节点，而是基于部署作业框架的程序在到达相应时间点时各自触发调度。注册中心仅用于作业注册和监控信息存储，而主作业节点仅用于处理分片和清理的功能。</p><blockquote><p><strong>分片</strong>：任务的分布式执行，需要将一个任务拆分为多个独立的任务项，然后由分布式的服务器分别执行某一个或几个分片项。</p></blockquote><p><code>elastic</code>底层的任务调度还是使用的<code>Quartz</code>，通过<code>zookeeper</code>来动态给job节点分片。</p><h3 id="Elastic-job-cloud"><a href="#Elastic-job-cloud" class="headerlink" title="Elastic-job-cloud"></a>Elastic-job-cloud</h3><p>Elastic-job-cloud包含了Elastic-job-lite的全部功能，它是以私有云平台的方式提供集资源、调度以及分片为一体的全量级解决方案，依赖于Mesos和Zookeeper，它额外提供了资源治理、应用分发以及进程隔离等服务。他们两个提供同一套API开发作业，开发者仅需一次开发，然后可根据需要以lite或cloud的方式部署。</p><blockquote><p><strong>Mesos</strong> ——像用一台电脑一样使用整个数据中心</p><p>是Apache下的开源分布式资源管理框架，它被称为分布式系统的内核，是以与Linux内核同样的原则而创建的，不同点仅仅是在于抽象的层面。使用ZooKeeper实现Master和Slave的容错。</p></blockquote><h2 id="saturn"><a href="#saturn" class="headerlink" title="saturn"></a>saturn</h2><p>Saturn（定时任务调度系统）是唯品会自主研发的分布式的定时任务的调度平台，它是基于Elastic-job版本1开发的。目标是取代传统的<code>Linux Cron</code>/<code>Spring Batch Job</code>/<code>Quartz</code>的方式，做到全域统一配置、统一监控、任务高可用以及分片。Saturn的任务可以使用多种语言开发，比如python、Go、Shell、Java、Php等。</p><h3 id="系统架构-2"><a href="#系统架构-2" class="headerlink" title="系统架构"></a>系统架构</h3><p><img alt="saturn系统架构" data-src="//orangesching.github.io/2020/09/04/系统架构/分布式系统架构/分布式任务调度系统/分布式任务调度系统概述/saturn系统架构.png" class="lazyload"></p><p>Saturn包括两大部分，Saturn Console和Saturn Executor。</p><ul><li>Console是一个WEB UI，用来对作业/Executor的管理，统计报表展现等。他同时也是整个调度系统的大脑：将作业任务分配到各Executor。</li><li>Executor是执行任务的worker：按照作业配置的要求去执行部署于Executor所在容器或物理机当中的作业脚本和代码。</li></ul><p>Saturn高度依赖于zookeeper，每个executor及调度服务都会在zookeeper上进行注册，确保调度程序能够及时得到executor的状态。</p><p>Saturn定时任务调度的<strong>最小单位是分片</strong>，即任务的一个执行单元。Saturn的基本任务就是将任务分成多个分片，并将每个分片通过算法调度到对应的executor上去执行。</p><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>Saturn的基本原理是将作业在逻辑上划分为若干个分片，通过作业分片调度器将作业分片指派给特定的执行节点。执行节点通过Quartz触发执行作业的具体实现，在执行的时候，会将分片序号和参数作为参数传入。作业的实现逻辑需分析分片序号和分片参数，并以此为依据来调用具体的实现（比如一个批量处理数据库的作业，可以划分0号分片处理1-10号数据库，1号分片可以处理11-20号数据库）。</p><p><img alt="saturn基本原理" data-src="//orangesching.github.io/2020/09/04/系统架构/分布式系统架构/分布式任务调度系统/分布式任务调度系统概述/saturn基本原理.png" class="lazyload"></p><h2 id="lts"><a href="#lts" class="headerlink" title="lts"></a>lts</h2><p>LTS是一个轻量级分布式任务调度框架，主要用于解决分布式任务的调度问题，支持实时任务、定时任务和Cron任务，有较好的伸缩性、扩展性以及健壮稳定性。参考hadoop的思想，主要有以下四个节点：</p><ul><li>JobClient：主要负责提交任务，并接收任务执行的反馈结果</li><li>JobTracker：负责接收并分配任务，任务调度</li><li>TaskTracker：负责执行任务，执行完反馈给JobTracker</li><li>LTS-Admin：（管理后台）主要负责节点管理，任务队列管理，监控管理等</li></ul><p>其中JobClient、JobTracker、TaskTracker是无状态的，可以部署多个并动态的进行删减，来实现负载均衡，实现更大的负载量，并且框架采用FailStore策略使得LTS具有很好的容错能力。</p><p><img alt="lts" data-src="//orangesching.github.io/2020/09/04/系统架构/分布式系统架构/分布式任务调度系统/分布式任务调度系统概述/lts.png" class="lazyload"></p><p>一个典型的定时任务，大概的执行流程如下：</p><ol><li>添加任务以后在注册中心进行注册，zk集群会暴露各个节点的信息，进行master节点选举等</li><li>JobClient将任务进行提交，如果成功的话将进行下一步；否则的话进入FailStore，重试</li><li>JobTracker接收并分配任务，如果任务已经存在，则结束；否则任务进入可执行队列ExecutableJobQueue，接着进入执行中任务队列ExecutingJobQueue，最后发送给TaskTracker进行执行</li><li>TaskTracker执行完毕后，将结果反馈给客户端；如果反馈成功，则回到JobClient执行下一个任务；否则的话进入FeedbackJobQueue重试</li></ol><h2 id="TBSchedule"><a href="#TBSchedule" class="headerlink" title="TBSchedule"></a>TBSchedule</h2><p>TBSchedule是一款非常优秀的分布式调度框架，广泛应用于阿里巴巴、淘宝、支付宝、京东、汽车之家等很多互联网企业的流程调度系统。TBSchedule在时间调度方面虽然没有quartz强大，但是它支持分片的功能。和quartz不同的是，TBSchedule使用zk来实现任务调度的高可用和分片。纯java开发。</p><p><img alt="TBSchedule" data-src="//orangesching.github.io/2020/09/04/系统架构/分布式系统架构/分布式任务调度系统/分布式任务调度系统概述/TBSchedule.png" class="lazyload"></p><p>TBSchedule项目实际上可以分为两部分。1）schedule管理控制台。负责控制、监控任务执行状态。2）实际执行job的客户端程序。</p><p>在实际使用时，需要先启动zk，然后部署TBSchedule web界面的管理控制台，最后启动实际执行job的客户端程序。这里的zk并不实际控制任务调度，它只是负责与N台执行job任务的客户端进行通讯，协调、管理、监控这些机器的运行信息。实际分配任务的是管理控制台，控制台从zk获取job的运行信息。</p><p>TBSchedule通过控制ZNode的创建、修改、删除来间接控制job的执行，执行任务的客户端监听它们对应ZNode的状态更新事件，从而达到TBSchedule控制job执行的目的。</p><p>特点：</p><ol><li>TBSchedule的分布式机制是通过灵活的Sharding方式实现的，比如可以按所有数据的ID按10取模分片、按月份分片等，根据不同的场景由客户端配置分片规则。</li><li>TBSchedule的宿主服务器可以进行动态的扩容和资源回收，这个特点主要是因为它后端依赖的zooKeeper，这里的zooKeeper对于TBSchedule来说相当于NoSQL，用于存储策略、任务、心跳等信息数据，他的数据结构类似于文件系统的目录结构，他的节点有临时节点、持久节点之分。一个新的服务器上线后，会在zk中创建一个代表当前服务器的一个唯一性路径（临时节点），并且新上线的服务器会和zk保持长连接，当通信断开后，节点会自动删除。</li><li>TBSchedule会定时扫描当前服务器的数量，重新进行任务分配。</li><li>TBSchedule不仅提供了服务端的高性能调度服务，还提供了一个scheduleConsole war随着宿主应用的部署直接部署到服务器，可以通过web的方式对调度的任务、策略进行监控管理，以及实时更新调整。</li></ol><h2 id="xxl-job"><a href="#xxl-job" class="headerlink" title="xxl-job"></a>xxl-job</h2><p>xxl-job是一个轻量级的分布式任务调度框架，其核心设计目标是开发迅速、学习简单、轻量级、易扩展。</p><h3 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h3><p>  （1）将调度行为抽象形成“调度中心”公共平台，而平台自身并不承担业务逻辑，“调度中心”负责发起调度请求</p><p>  （2）将任务抽象成分散的JobHandler，交由执行器统一管理，执行器负责接收调度请求并执行对应的JobHandler中业务逻辑</p><p>调度系统与任务解耦，提高了系统可用性和稳定性，同时调度系统性能不再受限于任务模块</p><h3 id="系统架构-3"><a href="#系统架构-3" class="headerlink" title="系统架构"></a>系统架构</h3><p><img alt="xxl-job" data-src="//orangesching.github.io/2020/09/04/系统架构/分布式系统架构/分布式任务调度系统/分布式任务调度系统概述/xxl-job.png" class="lazyload"></p><p>  xxl-job系统的组成分为：</p><ol><li>调度模块（调度中心）：负责管理调度信息，按照调度配置发出调度请求，自身不承担业务代码。支持可视化、简单且动态的管理调度信息，包括任务新建，更新，删除，GLUE开发和任务报警等，所有上述操作都会实时生效，同时支持监控调度结果以及执行日志，支持执行器Failover。</li><li>执行模块（执行器）：负责接收调度请求并执行任务逻辑。任务模块专注于任务的执行等操作，开发和维护更加简单和高效；接收“调度中心”的执行请求、终止请求和日志请求等。</li></ol><h3 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h3><ol><li>准备一个将要执行的任务</li><li>任务开启后到执行器中注册任务的信息</li><li>加载执行器的配置文件</li><li>初始化执行器的信息</li><li>执行器start</li><li>在admin端配置任务信息，配置执行器的信息</li></ol><h1 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h1><div class="table-container"><table><thead><tr><th>对比内容</th><th>cronsun</th><th>xxl-job</th><th>Elastic-job</th><th>saturn</th><th>lts</th><th>TBSchedule</th></tr></thead><tbody><tr><td>项目背景</td><td>替代crontab</td><td>大众点评、文档齐全</td><td>当当网开源、文档齐全</td><td>唯品会自主研发，基于当当的Elastic-job版本1</td><td>—</td><td>阿里早期开源、代码略陈旧</td></tr><tr><td>语言</td><td>Go</td><td>Java</td><td>Java</td><td>Java</td><td>Java</td><td>Java</td></tr><tr><td>依赖</td><td>etcd<br>mongodb</td><td>mysql<br>jdk1.7+<br>maven3.0+</td><td>jdk1.7+<br>zookeeper 3.4.6+ <br>maven3.0.4+<br>mesos<br>mysql</td><td>JDK 7 or JDK 8     <br>Maven 3.0.4+     <br>node.js 8.7.0+     <br>npm 5.4.2+     <br>docker (版本不限)</td><td>CentOs<br>maven<br>java<br>MySQL</td><td></td></tr><tr><td>易用、易部署</td><td>安装简单、使用简便</td><td>支持通过Web页面对任务进行CRUD操作，操作简单，一分钟上手</td><td>易用易部署</td><td>可以很好的部署到docker容器上</td><td>易用，难部署</td><td></td></tr><tr><td>web界面统一管理任务</td><td>cronweb界面可以管理任务</td><td>xxl-job-admin提供了web界面，同时也是作为任务调度中心</td><td>提供运维界面elastic-job-lite-console，可以管理作业和注册中心</td><td>Saturn  Console</td><td>lts-admin</td><td></td></tr><tr><td>多节点部署时任务不能重复执行</td><td>支持任务单次执行</td><td>“调度中心”通过DB锁保证集群分布式调度的一致性,  一次任务调度只会触发一次执行</td><td>容错处理：作业服务器与Zookeeper服务器通信失败则立即停止作业运行，防止作业注册中心将失效的分片分项配给其他作业服务器，而当前作业服务器仍在执行任务，导致重复执行                幂等性：重复作业任务项判定，不重复执行已运行的作业任务项</td><td></td><td>容错处理</td><td>支持</td></tr><tr><td>日志可追溯</td><td>有日志查询界面，并已支持日志清除</td><td>支持在线查看调度结果，并且支持以Rolling方式实时查看执行器输出的完整的执行日志（数据库）</td><td>支持，有日志查询界面，job的运行日志将会记录到数据库里</td><td>saturn-executor-log.log(executor日志)saturn-executor.log(job日志)</td><td>在TaskTracker端提供了业务日志记录器</td><td></td></tr><tr><td>弹性扩容缩容</td><td></td><td>一旦有新执行器机器上线或者下线，下次调度时将会重新分配任务</td><td>运行中的作业服务器崩溃，或新增加n台作业服务器，作业框架将在下次作业执行前重新分片，不影响当前作业执行</td><td>能支持容器化技术进行自动executor扩容和减容，保证高峰期处理能力的弹性伸缩。</td><td>因为LTS各个节点都是无状态的，所以支持动态增加删除节点，达到负载均衡的目的</td><td>（2）  TBSchedule的宿主服务器可以进行动态的扩容和资源回收</td></tr><tr><td>报警</td><td>邮件提醒，由cronweb界面发出，而不是cronnode</td><td>任务失败邮件报警，支持配置多邮箱地址，用逗号隔开</td><td>可通过事件订阅自行实现</td><td>Saturn提供了完善的监控告警机制，能方便开发者进行监控</td><td></td><td></td></tr><tr><td>阻塞处理策略</td><td>多机单任务(防止单机挂掉任务不按时执行)</td><td>策略包括：单机串行、丢弃后续调度、覆盖之前的调度</td><td>zk的session  timeout时间，超过这个时间临时节点将会被清除，作业才会重新分片</td><td>设置了timeout的作业开始执行后会启动超时检测，如果执行超时，则会停止当前作业的执行</td><td></td><td></td></tr><tr><td>支持并行调度</td><td>多节点</td><td>调度系统多线程触发调度运行，确保调度精确执行，不被阻塞</td><td>将一个任务分为多个小任务在多台服务器上执行</td><td>分片</td><td>多节点</td><td>支持</td></tr><tr><td>失败处理策略</td><td>任务失败重试</td><td>失败告警、失败重试</td><td>失败转移、被错过的作业重触发</td><td>支持作业HA，负载均衡和失败转移</td><td>当节点组中的一个节点当机之后，自动转到其他节点工作。当整个节点组当机之后，将会采用存储文件的方式，待节点组可用的时候进行重发。  当执行任务的TaskTracker节点当机之后，JobTracker  会将这个TaskTracker上的未完成的任务(死任务)，重新分配给节点组中其他节点执行。</td><td>失效转移</td></tr><tr><td>高可用</td><td>当某个节点死机的时候可以自动调度到正常的节点执行</td><td>如果执行器集群中某一台机器故障，将会自动Failover切换到一台正常的执行器发送调度请求</td><td>调度器的高可用是通过运行几个指向同一个ZooKeeper集群的Elastic-Job-Cloud-Scheduler实例来实现的。ZooKeeper用于在当前主Elastic-Job-Cloud-Scheduler实例失败的情况下执行领导者选举。通过至少两个调度器实例来构成集群，集群中只有一个调度器实例提供服务，其他实例处于”待命”状态。当该实例失败时，集群会选举剩余实例中的一个来继续提供服务。</td><td>Saturn是面向任务的，能够监控到executor的状态，在executor下线或者上线的时，均会对任务分片进行重分配，保证其可用性。</td><td>由于上面的失败处理策略，实现了任务的高可用</td><td>支持</td></tr><tr><td>路由策略</td><td>故障转移</td><td>第一个、最后一个、轮询、随机、一致性HASH、最不经常使用、最近最久未使用、故障转移、忙碌转移等</td><td>失效转移</td><td>失败转移、负载均衡</td><td>故障转移</td><td></td></tr><tr><td>动态分片</td><td></td><td>分片广播任务以执行器为维度进行分片，支持动态扩容执行器集群从而动态增加分片数量，协同进行业务处理；在进行大数据量业务操作时可显著提升任务处理能力和速度。</td><td>默认包含三种分片策略：  基于平均分配算法的分片策略、  作业名的哈希值奇偶数决定IP升降序算法的分片策略、根据作业名的哈希值对Job实例列表进行轮转的分片策略，支持自定义分片策略</td><td>由用户在UI界面输入</td><td></td><td>TBSchedule的分布式机制是通过灵活的Sharding方式实现的，比如可以按所有数据的ID按10取模分片、按月份分片等，根据不同的场景由客户端配置分片规则。</td></tr><tr><td>任务类型</td><td>普通任务、单机单进程任务、一个任务执行间隔内允许执行一次</td><td>提供Web  IDE，支持在线开发任务逻辑代码，动态发布，实时编译生效，省略部署上线的过程。支持30个版本的历史版本回溯。支持以GLUE模式开发和运行脚本任务，包括Shell、Python、NodeJS等类型脚本</td><td>支持OneOff，Perpetual和SequencePerpetual三种作业模式</td><td>提供除java作业的基础上增加了shell作业的支持。主要可以支持类似PHP,  Python等脚本作业</td><td>实时任务：提交了之后立即就要执行的任务。     定时任务：在指定时间点执行的任务，譬如 今天3点执行（单次）。     Cron任务：CronExpression，和quartz类似（但是不是使用quartz实现的）譬如 0 0/1 * ?     Repeat任务：譬如每隔5分钟执行一次，重复50次就停止。</td><td></td></tr><tr><td>任务在业务中的状态流转</td><td>所有的任务都会存储在一个分布式etcd里，单个crond部署成一个服务，也就是图中所示的node.1、node.2、node.n等，然后再由web界面去管理</td><td>将调度的行为抽象成“调度中心”公共平台，“调度中心”负责发起调度请求，将任务抽象成JobHandler，交由执行器管理，执行器负责接收调度请求并执行相应的JobHandler中的业务逻辑</td><td>首先配置任务的相关信息，然后任务去注册中心进行注册，注册中心完成主节点选举和分片策略的设置。Quarzt  job一旦触发，则任务执行。任务执行后，处理错过的任务以及监听事件</td><td>将作业在逻辑上划分为若干个分片，通过作业分片调度器将作业分片指派给特定的执行节点。执行节点通过quartz触发执行作业的具体实现，在执行的时候，会将分片序号和参数作为参数传入。作业的实现逻辑需分析分片序号和分片参数，并以此为依据来调用具体的实现</td><td>任务到注册中心进行注册，JobClient将任务进行提交，JobTracker接收并分配任务，TaskTracker执行任务，并将结果反馈给客户端</td><td></td></tr><tr><td>任务进度监控</td><td>在cronweb添加完成任务之后，在任务标签页就能看到所有添加的定时任务以及执行情况</td><td>支持实时监控任务进度</td><td>监控作业运行时状态，统计最近一段时间处理的数据成功和失败数量，记录作业上次运行开始时间，结束时间和下次运行时间。</td><td>Saturn通过统一的控制台进行全部域及全部作业的配置，执行情况监控，结点监控等</td><td>这些业务日志可以通过任务ID串联起来，可以在LTS-Admin中实时查看任务的执行进度</td><td>schedule管理控制台。负责控制、监控任务执行状态。</td></tr><tr><td>自定义任务参数</td><td>在cronweb添加定时任务时，可以指定任务执行脚本和参数</td><td>支持在线配置调度任务入参，即时生效</td><td>在修改任务时，可以自定义参数</td><td>可以在界面中配置任务的参数</td><td></td><td></td></tr><tr><td>安全设置</td><td>支持security.json安全设置</td><td>调度中心向执行器发送的调度请求时使用RequestModel和ResponseModel两个对象封装调度请求参数和响应数据,  在进行通讯之前底层会将上述两个对象对象序列化，并进行数据协议以及时间戳检验,从而达到数据加密的功能</td><td></td><td></td><td></td><td></td></tr><tr><td>开源地址</td><td><a href="http://github.com/shunfei/cronsun" target="_blank" rel="noopener">http://github.com/shunfei/cronsun</a></td><td><a href="https://github.com/xuxueli/xxl-job" target="_blank" rel="noopener">https://github.com/xuxueli/xxl-job</a></td><td><a href="https://github.com/elasticjob/elastic-job-lite" target="_blank" rel="noopener">https://github.com/elasticjob/elastic-job-lite</a></td><td><a href="https://github.com/vipshop/Saturn" target="_blank" rel="noopener">https://github.com/vipshop/Saturn</a></td><td><a href="https://github.com/ltsopensource/light-task-scheduler" target="_blank" rel="noopener">https://github.com/ltsopensource/light-task-scheduler</a></td></tr></tbody></table></div><p>参考：<a href="https://www.cnblogs.com/chen-chen-chen/p/12221923.html" target="_blank" rel="noopener">https://www.cnblogs.com/chen-chen-chen/p/12221923.html</a></p><p>​           <a href="https://blog.csdn.net/u012379844/article/details/82716146" target="_blank" rel="noopener">https://blog.csdn.net/u012379844/article/details/82716146</a></p>]]></content>
      
      
      <categories>
          
          <category> 分布式系统架构 </category>
          
          <category> 分布式任务调度系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xxl-job </tag>
            
            <tag> cronsun </tag>
            
            <tag> Elastic-job </tag>
            
            <tag> saturn </tag>
            
            <tag> lts </tag>
            
            <tag> TBSchedule </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis-plus运行原理</title>
      <link href="/2020/09/01/Java/JavaWeb/JAVA%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93/MyBatis-plus/MyBatis-plus%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/"/>
      <url>/2020/09/01/Java/JavaWeb/JAVA%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93/MyBatis-plus/MyBatis-plus%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>转载自<a href="https://blog.csdn.net/lizhiqiang1217/article/details/89738382" target="_blank" rel="noopener">https://blog.csdn.net/lizhiqiang1217/article/details/89738382</a></p><p>1、 employeeMapper 的本质 org.apache.ibatis.binding.MapperProxy<br>2、 MapperProxy 中 sqlSession –&gt;SqlSessionFactory<br><img alt="sqlSessionFactory" data-src="//orangesching.github.io/2020/09/01/Java/JavaWeb/JAVA与数据库/MyBatis-plus/MyBatis-plus运行原理/sqlSessionFactory.png" class="lazyload"><br>3、SqlSessionFacotry 中 → Configuration→ MappedStatements 。每一个 mappedStatement 都表示 Mapper 接口中的一个方法与 Mapper 映射文件中的一个 SQL。 MyBatisPlus在启动就会挨个分析 xxxMapper 中的方法，并且将对应的 SQL 语句处理好，保存到 configuration 对象中的mappedStatements 中<br><img alt="Configuration" data-src="//orangesching.github.io/2020/09/01/Java/JavaWeb/JAVA与数据库/MyBatis-plus/MyBatis-plus运行原理/Configuration.png" class="lazyload"><br><img alt="Configuration2" data-src="//orangesching.github.io/2020/09/01/Java/JavaWeb/JAVA与数据库/MyBatis-plus/MyBatis-plus运行原理/Configuration2.png" class="lazyload"></p><p>mappedStatements 中<br><img alt="mappedStatements" data-src="//orangesching.github.io/2020/09/01/Java/JavaWeb/JAVA与数据库/MyBatis-plus/MyBatis-plus运行原理/mappedStatements.png" class="lazyload"></p><p>4、本质:<br><img alt="本质" data-src="//orangesching.github.io/2020/09/01/Java/JavaWeb/JAVA与数据库/MyBatis-plus/MyBatis-plus运行原理/本质.png" class="lazyload"></p><ul><li>Configuration： MyBatis 或者 MyBatisPlus全局配置对象。</li><li>MappedStatement：一个 MappedStatement 对象对应 Mapper 配置文件中的一个。 select/update/insert/delete 节点，主要描述的是一条 SQL 语句。</li><li>SqlMethod : 枚举对象 ，MyBatisPlus支持的 SQL 方法。</li><li>TableInfo：数据库表反射信息 ，可以获取到数据库表相关的信息。</li><li>SqlSource: SQL 语句处理对象。</li><li>MapperBuilderAssistant： 用于缓存、SQL 参数、查询方剂结果集处理等。通过 MapperBuilderAssistant 将每一个 mappedStatement 添加到configuration 中的 mappedstatements 中。</li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaWeb </category>
          
          <category> JAVA与数据库 </category>
          
          <category> MyBatis-plus </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis-plus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis-plus环境配置</title>
      <link href="/2020/09/01/Java/JavaWeb/JAVA%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93/MyBatis-plus/MyBatis-plus%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
      <url>/2020/09/01/Java/JavaWeb/JAVA%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93/MyBatis-plus/MyBatis-plus%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-Boot-MyBatis-plus"><a href="#Spring-Boot-MyBatis-plus" class="headerlink" title="Spring Boot + MyBatis-plus"></a>Spring Boot + MyBatis-plus</h1><h2 id="新建MAVEN工程"><a href="#新建MAVEN工程" class="headerlink" title="新建MAVEN工程"></a>新建MAVEN工程</h2><p>在<a href="https://start.spring.io/中初始化一个Spring" target="_blank" rel="noopener">https://start.spring.io/中初始化一个Spring</a> Boot工程，或自己新建MAVEN</p><h2 id="在pom-xml文件中添加依赖"><a href="#在pom-xml文件中添加依赖" class="headerlink" title="在pom.xml文件中添加依赖"></a>在pom.xml文件中添加依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--父级依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.orange<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>orange<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>orange<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">description</span>&gt;</span>orange learn java<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- MySql --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--小工具可以免写get、set、tostring等方法--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- mybatis-plus的依赖包，有这个包不要引mybatis的包以免混乱 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 默认模板引擎和代码生成器依赖 当要使用mybatis-plus的自动代码生成器的时候要这两个依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.velocity<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>velocity-engine-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-generator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="在application-yml中的配置"><a href="#在application-yml中的配置" class="headerlink" title="在application.yml中的配置"></a>在application.yml中的配置</h2><p>注意这是application.yml的配置格式，application.properity文件配置不是这个格式</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">demo</span></span><br><span class="line"><span class="attr">  profiles:</span></span><br><span class="line"><span class="attr">    active:</span> <span class="string">dev</span></span><br><span class="line">  <span class="comment"># 配置数据源</span></span><br><span class="line"><span class="attr">  datasource:</span></span><br><span class="line"><span class="attr">    url:</span> <span class="attr">jdbc:mysql://127.0.0.1:3306/orange_learning?useUnicode=true&amp;characterEncoding=UTF8&amp;useSSL=false</span> <span class="comment"># MySQL在高版本需要指明是否进行SSL连接 解决则加上 &amp;useSSL=false</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">orange_learning</span></span><br><span class="line"><span class="attr">    username:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">    password:</span> <span class="string">.a123456</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># mybatis-plus相关配置</span></span><br><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="comment"># xml扫描，多个目录用逗号或者分号分隔（告诉 Mapper 所对应的 XML 文件位置）</span></span><br><span class="line"><span class="attr">  mapper-locations:</span> <span class="attr">classpath:**/*Mapper.xml</span></span><br><span class="line">  <span class="comment"># 以下配置均有默认值,可以不设置</span></span><br><span class="line"><span class="attr">  global-config:</span></span><br><span class="line">    <span class="comment">#主键类型  0:"数据库ID自增", 1:"用户输入ID",2:"全局唯一ID (数字类型唯一ID)", 3:"全局唯一ID UUID";</span></span><br><span class="line"><span class="attr">    id-type:</span> <span class="number">0</span></span><br><span class="line">    <span class="comment">#字段策略 0:"忽略判断",1:"非 NULL 判断"),2:"非空判断"</span></span><br><span class="line"><span class="attr">    field-strategy:</span> <span class="number">2</span></span><br><span class="line">    <span class="comment">#驼峰下划线转换</span></span><br><span class="line"><span class="attr">    db-column-underline:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment">#刷新mapper 调试神器</span></span><br><span class="line"><span class="attr">    refresh-mapper:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  configuration:</span></span><br><span class="line">    <span class="comment"># 是否开启自动驼峰命名规则映射:从数据库列名到Java属性驼峰命名的类似映射</span></span><br><span class="line"><span class="attr">    map-underscore-to-camel-case:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    cache-enabled:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">    jdbc-type-for-null:</span> <span class="string">'null'</span></span><br></pre></td></tr></table></figure><h2 id="使用自动代码生成器生成mapper、dao、service、domain（也可以自己建）"><a href="#使用自动代码生成器生成mapper、dao、service、domain（也可以自己建）" class="headerlink" title="使用自动代码生成器生成mapper、dao、service、domain（也可以自己建）"></a>使用自动代码生成器生成mapper、dao、service、domain（也可以自己建）</h2><p>与启动类同级的地方创建自动代码生成器类AutoGenerater，自动代码生成器会根据MySQL中的数据表自动创建相应的mapper、dao、service、domain</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AutoGenerater</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AutoGenerator mpg = <span class="keyword">new</span> AutoGenerator();</span><br><span class="line">        <span class="comment">// =============================全局配置===============================</span></span><br><span class="line">        mpg.setGlobalConfig(<span class="keyword">new</span> GlobalConfig()</span><br><span class="line">                <span class="comment">// 覆盖输出到xxx目录</span></span><br><span class="line">                .setFileOverride(<span class="keyword">true</span>).setOutputDir(<span class="string">"D:/TestProject/orange/src/main/java/"</span>)</span><br><span class="line">                <span class="comment">// 主键生成策略 生成BaseResultMap</span></span><br><span class="line">                .setIdType(IdType.AUTO).setBaseResultMap(<span class="keyword">true</span>)</span><br><span class="line">                <span class="comment">// 指定作者</span></span><br><span class="line">                .setAuthor(<span class="string">"orange"</span>)</span><br><span class="line">                <span class="comment">// 设置Controller、Service、ServiceImpl、Dao、Mapper文件名称，%s是依据表名转换来的</span></span><br><span class="line">                .setControllerName(<span class="string">"%sController"</span>)</span><br><span class="line">                .setServiceName(<span class="string">"MP%sService"</span>)</span><br><span class="line">                .setServiceImplName(<span class="string">"%sServiceImpl"</span>)</span><br><span class="line">                .setMapperName(<span class="string">"%sDao"</span>)</span><br><span class="line">                .setXmlName(<span class="string">"%sMapper"</span>));</span><br><span class="line">        <span class="comment">// ================================数据源配置============================</span></span><br><span class="line">        mpg.setDataSource(<span class="keyword">new</span> DataSourceConfig()</span><br><span class="line">                <span class="comment">// 用户名、密码、驱动、url</span></span><br><span class="line">                .setUsername(<span class="string">"root"</span>)</span><br><span class="line">                .setPassword(<span class="string">".a123456"</span>)</span><br><span class="line">                .setDbType(DbType.MYSQL)</span><br><span class="line">                .setDriverName(<span class="string">"com.mysql.cj.jdbc.Driver"</span>)</span><br><span class="line">                .setUrl(<span class="string">"jdbc:mysql://localhost:3306/orange_learning?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false"</span>));</span><br><span class="line">        <span class="comment">// ==================包名配置：父包.模块.controller==========================</span></span><br><span class="line">        mpg.setPackageInfo(<span class="keyword">new</span> PackageConfig()</span><br><span class="line">                <span class="comment">// 父包名 模块名</span></span><br><span class="line">                .setParent(<span class="string">"com.orange"</span>)</span><br><span class="line">                .setModuleName(<span class="string">"learn"</span>)</span><br><span class="line">                <span class="comment">// 分层包名</span></span><br><span class="line">                .setController(<span class="string">"controller"</span>)</span><br><span class="line">                .setService(<span class="string">"service"</span>)</span><br><span class="line">                .setServiceImpl(<span class="string">"service.impl"</span>)</span><br><span class="line">                .setEntity(<span class="string">"domain"</span>)</span><br><span class="line">                .setMapper(<span class="string">"mapper"</span>));</span><br><span class="line">        <span class="comment">// =====================================策略配置==================================</span></span><br><span class="line">        mpg.setStrategy(<span class="keyword">new</span> StrategyConfig()</span><br><span class="line">                <span class="comment">// 命名策略：实体的类名和属性名按下划线转驼峰 user_info -&gt; userInfo</span></span><br><span class="line">                .setNaming(NamingStrategy.underline_to_camel)</span><br><span class="line">                <span class="comment">// controller生成@RestCcontroller</span></span><br><span class="line">                .setRestControllerStyle(<span class="keyword">true</span>));</span><br><span class="line">        <span class="comment">// 执行生成</span></span><br><span class="line">        mpg.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>创建完需注意Service类是否有@Service注释</p><p>Mapper类在启动类中的MapperScan中已经配置了，所以不需要任何Bean相关的注释</p></blockquote><h2 id="最终项目结构"><a href="#最终项目结构" class="headerlink" title="最终项目结构"></a>最终项目结构</h2><p><img alt="springboot目录结构" data-src="//orangesching.github.io/2020/09/01/Java/JavaWeb/JAVA与数据库/MyBatis-plus/MyBatis-plus环境配置/springboot目录结构.png" class="lazyload"></p><h2 id="在启动类添加MapperScan"><a href="#在启动类添加MapperScan" class="headerlink" title="在启动类添加MapperScan"></a>在启动类添加MapperScan</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@MapperScan</span>(<span class="string">"com.orange.learn.mapper"</span>)   <span class="comment">// 添加Mapper扫描包</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrangeApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      SpringApplication.run(OrangeApplication.class, args);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="添加测试文件测试环境是否正常"><a href="#添加测试文件测试环境是否正常" class="headerlink" title="添加测试文件测试环境是否正常"></a>添加测试文件测试环境是否正常</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperCRUDTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    StudentDao studentDao;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 新增数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAdd</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        List&lt;Student&gt; search = studentDao.selectByMap(<span class="keyword">new</span> HashMap&lt;String, Object&gt;()&#123;&#123;put(<span class="string">"name"</span>,<span class="string">"橙子"</span>);&#125;&#125;);</span><br><span class="line">        <span class="keyword">if</span>(search.size()==<span class="number">0</span>)&#123;</span><br><span class="line">            Student stu = <span class="keyword">new</span> Student();</span><br><span class="line">            stu.setName(<span class="string">"橙子"</span>);</span><br><span class="line">            stu.setAge(<span class="number">12</span>);</span><br><span class="line">            stu.setTel(<span class="string">"123456"</span>);</span><br><span class="line">            <span class="keyword">int</span> result = studentDao.insert(stu);</span><br><span class="line">            System.out.println(result);</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"已存在该数据"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaWeb </category>
          
          <category> JAVA与数据库 </category>
          
          <category> MyBatis-plus </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis-plus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis-plus构造SQL</title>
      <link href="/2020/08/31/Java/JavaWeb/JAVA%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93/MyBatis-plus/MyBatis-plus%E6%9E%84%E9%80%A0SQL/"/>
      <url>/2020/08/31/Java/JavaWeb/JAVA%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93/MyBatis-plus/MyBatis-plus%E6%9E%84%E9%80%A0SQL/</url>
      
        <content type="html"><![CDATA[<h1 id="CRUD接口"><a href="#CRUD接口" class="headerlink" title="CRUD接口"></a>CRUD接口</h1><h2 id="Mapper-CRUD-接口"><a href="#Mapper-CRUD-接口" class="headerlink" title="Mapper CRUD 接口"></a>Mapper CRUD 接口</h2><div class="table-container"><table><thead><tr><th>增</th><th>删</th><th>改</th><th>查</th></tr></thead><tbody><tr><td><code>insert</code></td><td><code>delete</code> <br><code>deleteBatchIds</code><br><code>deleteById</code> <br><code>deleteByMap</code></td><td><code>update</code><br><code>updateById</code></td><td><code>selectById</code><br><code>selectOne</code><br><code>selectBatchIds</code><br><code>selectList</code><br><code>selectByMap</code><br><code>selectMaps</code><br><code>selectObjs</code><br><code>selectPage</code><br><code>selectMapsPage</code><br><code>selectCount</code></td></tr><tr><td>返回插入数据条数</td><td>返回删除数据条数</td><td>返回修改数据条数</td><td>返回查询数据</td></tr></tbody></table></div><blockquote><p>通用 CRUD 封装<code>BaseMapper</code>接口，为 <code>Mybatis-Plus</code> 启动时自动解析实体表关系映射转换为 <code>Mybatis</code> 内部对象注入容器</p></blockquote><h3 id="增"><a href="#增" class="headerlink" title="增"></a>增</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入一条记录</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insert</span><span class="params">(T entity)</span></span>;</span><br></pre></td></tr></table></figure><p>insert方法默认底层会增加uuid随机生成的id字段</p><p>所以使用此方法 必须在数据库id字段设置成bigint类型 （不然放不下这么长的数字）。在pojo中id属性不能为int和Integer 了 ， 可以用Long</p><p>id不仅是可以自动生成UUID 还可以自增 或者其他</p><h3 id="删"><a href="#删" class="headerlink" title="删"></a>删</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全部返回删除数据条数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 entity 条件，删除记录</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">delete</span><span class="params">(Wrapper&lt;T&gt; wrapper)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除（根据ID 批量删除）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">deleteBatchIds</span><span class="params">(Collection&lt;? extends Serializable&gt; idList)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 ID 删除</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">deleteById</span><span class="params">(Serializable id)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 columnMap 条件，删除记录</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">deleteByMap</span><span class="params">(Map&lt;String, Object&gt; columnMap)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="改"><a href="#改" class="headerlink" title="改"></a>改</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据 whereEntity 条件，更新记录，没有set的属性将不会被修改</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(T entity, Wrapper&lt;T&gt; updateWrapper)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 ID 修改，如果没有id就不会修改，没有set的属性将不会被修改</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">updateById</span><span class="params">(T entity)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="查"><a href="#查" class="headerlink" title="查"></a>查</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所有不存在的查询会返回空对象，不是NULL</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 ID 查询</span></span><br><span class="line"><span class="function">T <span class="title">selectById</span><span class="params">(Serializable id)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 entity 条件，查询一条记录，如果是多个会抛出异常，随机取一条加上限制条件 wrapper.last("LIMIT 1")</span></span><br><span class="line"><span class="function">T <span class="title">selectOne</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span></span>; </span><br><span class="line"><span class="comment">// 多于一条记录返回会报错`TooManyResultsException`,`selectOne`内部调用的是selectList</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询（根据ID 批量查询）</span></span><br><span class="line"><span class="function">List&lt;T&gt; <span class="title">selectBatchIds</span><span class="params">(Collection idList)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据Wrapper条件，查询全部记录 </span></span><br><span class="line"><span class="function">List&lt;T&gt; <span class="title">selectList</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询（根据 columnMap 条件）</span></span><br><span class="line"><span class="function">List&lt;T&gt; <span class="title">selectByMap</span><span class="params">(Map&lt;String, Object&gt; columnMap)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 Wrapper 条件，查询全部记录，返回的是有值的字段组成的HashMap数组</span></span><br><span class="line">List&lt;Map&lt;String, Object&gt;&gt; selectMaps(Wrapper&lt;T&gt; queryWrapper);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 Wrapper 条件，查询全部记录，只返回第一个字段的值(一般是ID)</span></span><br><span class="line"><span class="function">List&lt;Object&gt; <span class="title">selectObjs</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 entity 条件，查询全部记录（并翻页）</span></span><br><span class="line"><span class="function">IPage&lt;T&gt; <span class="title">selectPage</span><span class="params">(IPage&lt;T&gt; page, @Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 Wrapper 条件，查询全部记录（并翻页），返回的是有值的字段组成的HashMap数组</span></span><br><span class="line">IPage&lt;Map&lt;String, Object&gt;&gt; selectMapsPage(IPage&lt;T&gt; page, Wrapper&lt;T&gt; queryWrapper);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 Wrapper 条件，查询总记录数</span></span><br><span class="line"><span class="function">Integer <span class="title">selectCount</span><span class="params">( Wrapper&lt;T&gt; queryWrapper)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="Service-CRUD-接口"><a href="#Service-CRUD-接口" class="headerlink" title="Service CRUD 接口"></a>Service CRUD 接口</h2><div class="table-container"><table><thead><tr><th>Save</th><th>SaveOrUpdate</th><th>Remove</th><th>Update</th><th>Get</th><th>List</th><th>Page</th><th>Count</th></tr></thead><tbody><tr><td>新增</td><td>新增或修改</td><td>删除</td><td>修改</td><td>获取一条</td><td>获取全部</td><td>分页获取</td><td>计数</td></tr><tr><td><code>save</code><br><code>saveBatch</code></td><td><code>saveOrUpdate</code><br><code>saveOrUpdateBatch</code></td><td><code>remove</code><br><code>removeById</code><br><code>removeByMap</code><br><code>removeByIds</code></td><td><code>update</code><br><code>updateById</code><br><code>updateBatchById</code></td><td><code>getById</code><br><code>getOne</code><br><code>getMap</code><br><code>getObj</code></td><td><code>list</code><br><code>listByIds</code><br><code>listByMap</code><br><code>listMaps</code><br><code>listObjs</code></td><td><code>page</code><br><code>pageMaps</code></td><td><code>count</code></td></tr></tbody></table></div><blockquote><ul><li>通用 Service CRUD 封装<code>IService</code>接口，进一步封装 CRUD 采用 <code>get 查询单行</code> <code>remove 删除</code> <code>list 查询集合</code> <code>page 分页</code> 前缀命名方式区分 <code>Mapper</code> 层避免混淆，</li><li>建议如果存在自定义通用 Service 方法的可能，请创建自己的 <code>IBaseService</code> 继承 <code>Mybatis-Plus</code> 提供的基类</li></ul></blockquote><h3 id="Save"><a href="#Save" class="headerlink" title="Save"></a>Save</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// entity没有set的属性不会被修改，entitiy即使set了id属性也不会使用这个值，所以如果数据库只有id不可重复的限制时，可重复save同一entity对象，这与saveOrUpdate不一样</span></span><br><span class="line"><span class="comment">// 次类方法插入完成会set entity中的id属性为数据表中的值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入一条记录（选择字段，策略插入）</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">save</span><span class="params">(T entity)</span></span>;</span><br><span class="line"><span class="comment">// 插入（批量） 调用saveBatch(entityList, 1000)</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">saveBatch</span><span class="params">(Collection&lt;T&gt; entityList)</span></span>;</span><br><span class="line"><span class="comment">// 插入（批量）</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">saveBatch</span><span class="params">(Collection&lt;T&gt; entityList, <span class="keyword">int</span> batchSize)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="SaveOrUpdate"><a href="#SaveOrUpdate" class="headerlink" title="SaveOrUpdate"></a>SaveOrUpdate</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 次类方法插入完成会set entity中的id属性为数据表中的值</span></span><br><span class="line"><span class="comment">// saveOrUpdate依据id执行插入和修改操作，所以不能重复插入同一entity对象（除了第一次插入其他操作都会认为时修改），当id不存在时也会执行插入操作</span></span><br><span class="line"><span class="comment">// 谨慎用该类方法</span></span><br><span class="line"><span class="comment">// 没有任何数据修改也会返回true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// TableId 注解存在更新记录，否插入一条记录</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">saveOrUpdate</span><span class="params">(T entity)</span></span>;</span><br><span class="line"><span class="comment">// 根据updateWrapper尝试更新，否继续执行saveOrUpdate(T)方法</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">saveOrUpdate</span><span class="params">(T entity, Wrapper&lt;T&gt; updateWrapper)</span></span>;</span><br><span class="line"><span class="comment">// 批量修改插入</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">saveOrUpdateBatch</span><span class="params">(Collection&lt;T&gt; entityList)</span></span>;</span><br><span class="line"><span class="comment">// 批量修改插入</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">saveOrUpdateBatch</span><span class="params">(Collection&lt;T&gt; entityList, <span class="keyword">int</span> batchSize)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="Remove"><a href="#Remove" class="headerlink" title="Remove"></a>Remove</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没有删除记录时返回false，只要删除了一条记录就返回true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 entity 条件，删除记录</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span></span>;</span><br><span class="line"><span class="comment">// 根据 ID 删除</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">removeById</span><span class="params">(Serializable id)</span></span>;</span><br><span class="line"><span class="comment">// 根据 columnMap 条件，删除记录</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">removeByMap</span><span class="params">(Map&lt;String, Object&gt; columnMap)</span></span>;</span><br><span class="line"><span class="comment">// 删除（根据ID 批量删除）,只要删除了list中的一条记录就会返回true</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">removeByIds</span><span class="params">(Collection&lt;? extends Serializable&gt; idList)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="Update"><a href="#Update" class="headerlink" title="Update"></a>Update</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没有更新记录则返回false，更新成功返回true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 UpdateWrapper 条件，更新记录 需要设置sqlset，没有设置setsql将报错BadSqlGrammarException</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">update</span><span class="params">(Wrapper&lt;T&gt; updateWrapper)</span></span>;</span><br><span class="line"><span class="comment">// 根据 whereEntity 条件，更新记录</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">update</span><span class="params">(T entity, Wrapper&lt;T&gt; updateWrapper)</span></span>;</span><br><span class="line"><span class="comment">// 根据 ID 选择修改 没有设置id将不更新</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">updateById</span><span class="params">(T entity)</span></span>;</span><br><span class="line"><span class="comment">// 根据ID 批量更新</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">updateBatchById</span><span class="params">(Collection&lt;T&gt; entityList)</span></span>;</span><br><span class="line"><span class="comment">// 根据ID 批量更新</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">updateBatchById</span><span class="params">(Collection&lt;T&gt; entityList, <span class="keyword">int</span> batchSize)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="Get"><a href="#Get" class="headerlink" title="Get"></a>Get</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据 ID 查询</span></span><br><span class="line"><span class="function">T <span class="title">getById</span><span class="params">(Serializable id)</span></span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper，查询一条记录。结果集，如果是多个会抛出异常，随机取一条加上限制条件 wrapper.last("LIMIT 1")</span></span><br><span class="line"><span class="function">T <span class="title">getOne</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span></span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper，查询一条记录， throwEx为有多个 result 是否抛出异常</span></span><br><span class="line"><span class="function">T <span class="title">getOne</span><span class="params">(Wrapper&lt;T&gt; queryWrapper, <span class="keyword">boolean</span> throwEx)</span></span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper，查询一条记录，返回有值属性组成的map</span></span><br><span class="line"><span class="function">Map&lt;String, Object&gt; <span class="title">getMap</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span></span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper，查询一条记录的第一个字段（一般是id），mapper为映射函数</span></span><br><span class="line">&lt;V&gt; <span class="function">V <span class="title">getObj</span><span class="params">(Wrapper&lt;T&gt; queryWrapper, Function&lt;? <span class="keyword">super</span> Object, V&gt; mapper)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询所有</span></span><br><span class="line"><span class="function">List&lt;T&gt; <span class="title">list</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 查询列表</span></span><br><span class="line"><span class="function">List&lt;T&gt; <span class="title">list</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span></span>;</span><br><span class="line"><span class="comment">// 查询（根据ID 批量查询）</span></span><br><span class="line"><span class="function">Collection&lt;T&gt; <span class="title">listByIds</span><span class="params">(Collection&lt;? extends Serializable&gt; idList)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下返回有值属性组成的map</span></span><br><span class="line"><span class="comment">// 查询（根据 columnMap 条件）</span></span><br><span class="line"><span class="function">Collection&lt;T&gt; <span class="title">listByMap</span><span class="params">(Map&lt;String, Object&gt; columnMap)</span></span>;</span><br><span class="line"><span class="comment">// 查询所有列表</span></span><br><span class="line">List&lt;Map&lt;String, Object&gt;&gt; listMaps();</span><br><span class="line"><span class="comment">// 查询列表</span></span><br><span class="line">List&lt;Map&lt;String, Object&gt;&gt; listMaps(Wrapper&lt;T&gt; queryWrapper);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下返回记录的第一个字段（一般是ID）</span></span><br><span class="line"><span class="comment">// 查询全部记录</span></span><br><span class="line"><span class="function">List&lt;Object&gt; <span class="title">listObjs</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 查询全部记录</span></span><br><span class="line">&lt;V&gt; <span class="function">List&lt;V&gt; <span class="title">listObjs</span><span class="params">(Function&lt;? <span class="keyword">super</span> Object, V&gt; mapper)</span></span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper 条件，查询全部记录</span></span><br><span class="line"><span class="function">List&lt;Object&gt; <span class="title">listObjs</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span></span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper 条件，查询全部记录</span></span><br><span class="line">&lt;V&gt; <span class="function">List&lt;V&gt; <span class="title">listObjs</span><span class="params">(Wrapper&lt;T&gt; queryWrapper, Function&lt;? <span class="keyword">super</span> Object, V&gt; mapper)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="Page"><a href="#Page" class="headerlink" title="Page"></a>Page</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无条件分页查询</span></span><br><span class="line"><span class="function">IPage&lt;T&gt; <span class="title">page</span><span class="params">(IPage&lt;T&gt; page)</span></span>;</span><br><span class="line"><span class="comment">// 条件分页查询</span></span><br><span class="line"><span class="function">IPage&lt;T&gt; <span class="title">page</span><span class="params">(IPage&lt;T&gt; page, Wrapper&lt;T&gt; queryWrapper)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下page中的record格式是Map&lt;String, Object&gt;，由有值字段组成</span></span><br><span class="line"><span class="comment">// 无条件分页查询</span></span><br><span class="line">IPage&lt;Map&lt;String, Object&gt;&gt; pageMaps(IPage&lt;T&gt; page);</span><br><span class="line"><span class="comment">// 条件分页查询</span></span><br><span class="line">IPage&lt;Map&lt;String, Object&gt;&gt; pageMaps(IPage&lt;T&gt; page, Wrapper&lt;T&gt; queryWrapper);</span><br></pre></td></tr></table></figure><blockquote><p>这个分页其实并不是物理分页，而是内存分页。<br>也就是说，查询的时候并没有limit语句。等配置了分页插件后才可以实现真正的分页。</p></blockquote><h3 id="Count"><a href="#Count" class="headerlink" title="Count"></a>Count</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询总记录数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper 条件，查询总记录数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="Chain"><a href="#Chain" class="headerlink" title="Chain"></a>Chain</h3><p>query</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 链式查询 普通</span></span><br><span class="line"><span class="function">QueryChainWrapper&lt;T&gt; <span class="title">query</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 链式查询 lambda 式。注意：不支持 Kotlin</span></span><br><span class="line"><span class="function">LambdaQueryChainWrapper&lt;T&gt; <span class="title">lambdaQuery</span><span class="params">()</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例：</span></span><br><span class="line">query().eq(<span class="string">"column"</span>, value).one();   <span class="comment">// 如果eq出来有多条记录会报错</span></span><br><span class="line">lambdaQuery().eq(Entity::getId, value).list();</span><br></pre></td></tr></table></figure><p>update</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 链式更改 普通</span></span><br><span class="line"><span class="function">UpdateChainWrapper&lt;T&gt; <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 链式更改 lambda 式。注意：不支持 Kotlin </span></span><br><span class="line"><span class="function">LambdaUpdateChainWrapper&lt;T&gt; <span class="title">lambdaUpdate</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例：</span></span><br><span class="line">update().eq(<span class="string">"column"</span>, value).remove();</span><br><span class="line">lambdaUpdate().eq(Entity::getId, value).update(entity);</span><br></pre></td></tr></table></figure><h1 id="条件构造器"><a href="#条件构造器" class="headerlink" title="条件构造器"></a>条件构造器</h1><p><strong>条件构造器是用于生成sql的where条件的</strong></p><p>各种不同构造器的继承关系如下：</p><p><img alt="img" data-src="//orangesching.github.io/2020/08/31/Java/JavaWeb/JAVA与数据库/MyBatis-plus/MyBatis-plus构造SQL/mybatis-wrapper.png" class="lazyload"></p><h2 id="AbstractWrapper"><a href="#AbstractWrapper" class="headerlink" title="AbstractWrapper"></a>AbstractWrapper</h2><blockquote><p>QueryWrapper(LambdaQueryWrapper) 和 UpdateWrapper(LambdaUpdateWrapper) 的父类<br>用于生成 sql 的 where 条件, entity 属性也用于生成 sql 的 where 条件</p></blockquote><ul><li>以下出现的第一个入参<code>boolean condition</code>表示该条件是否加入最后生成的sql中</li><li>以下代码块内的多个方法均为从上往下补全个别<code>boolean</code>类型的入参,默认为<code>true</code></li><li>以下出现的泛型<code>Param</code>均为<code>Wrapper</code>的子类实例(均具有<code>AbstractWrapper</code>的所有方法)</li><li>以下方法在入参中出现的<code>R</code>在普通<code>wrapper</code>中是<code>String</code>,在<code>LambdaWrapper</code>中是函数</li><li>以下方法入参中的<code>R column</code>均表示数据库字段,当<code>R</code>具体类型为<code>String</code>时则为数据库字段名(字段名是数据库关键字)而不是实体类数据字段名</li><li>使用中如果入参的<code>Map</code>或者<code>List</code>为空，则不会加入最后生成的sql中</li><li><code>val</code>不区分类型，最后全部转为<code>string</code></li></ul><h3 id="比较符"><a href="#比较符" class="headerlink" title="比较符"></a>比较符</h3><div class="table-container"><table><thead><tr><th>操作</th><th>sql</th><th>语句</th></tr></thead><tbody><tr><td>allEq</td><td>全部eq(或个别isNull)</td><td><code>allEq(Map&lt;R, V&gt; params)</code> <br><code>allEq(Map&lt;R, V&gt; params, boolean null2IsNull)</code> <br><code>allEq(boolean condition, Map&lt;R, V&gt; params, boolean null2IsNull)</code></td></tr><tr><td>eq</td><td>等于 =</td><td><code>eq(R column, Object val)</code><br><code>eq(boolean condition, R column, Object val)</code></td></tr><tr><td>ne</td><td>不等于 &lt;&gt;</td><td><code>ne(R column, Object val)</code><br><code>ne(boolean condition, R column, Object val)</code></td></tr><tr><td>gt</td><td>大于 &gt;</td><td><code>gt(R column, Object val)</code><br><code>gt(boolean condition, R column, Object val)</code></td></tr><tr><td>ge</td><td>大于等于 >=</td><td><code>ge(R column, Object val)</code><br><code>ge(boolean condition, R column, Object val)</code></td></tr><tr><td>lt</td><td>小于 &lt;</td><td><code>lt(R column, Object val)</code><br><code>lt(boolean condition, R column, Object val)</code></td></tr><tr><td>le</td><td>小于等于 >=</td><td><code>le(R column, Object val)</code><br><code>le(boolean condition, R column, Object val)</code></td></tr></tbody></table></div><h3 id="OR-AND"><a href="#OR-AND" class="headerlink" title="OR / AND"></a>OR / AND</h3><div class="table-container"><table><thead><tr><th>操作</th><th>sql</th><th>语句</th></tr></thead><tbody><tr><td>or</td><td>拼接 OR</td><td><code>or()</code><br><code>or(boolean condition)</code><br><code>or(Consumer&lt;Param&gt; consumer)</code><br><code>or(boolean condition, Consumer&lt;Param&gt; consumer)</code><br>例：<code>or(i -&gt; i.eq(&quot;name&quot;, &quot;李白&quot;).ne(&quot;status&quot;, &quot;活着&quot;))</code>—-&gt;<br><code>or (name = &#39;李白&#39; and status &lt;&gt; &#39;活着&#39;)</code></td></tr><tr><td>and</td><td>AND 嵌套</td><td><code>and(Consumer&lt;Param&gt; consumer)</code><br><code>and(boolean condition, Consumer&lt;Param&gt; consumer)</code><br>例：<code>and(i -&gt; i.eq(&quot;name&quot;, &quot;李白&quot;).ne(&quot;status&quot;, &quot;活着&quot;))</code>—-&gt;<br><code>and (name = &#39;李白&#39; and status &lt;&gt; &#39;活着&#39;)</code></td></tr><tr><td>nested</td><td>正常嵌套 不带 AND 或者 OR</td><td><code>nested(Consumer&lt;Param&gt; consumer)</code><br><code>nested(boolean condition, Consumer&lt;Param&gt; consumer)</code><br>例: <code>nested(i -&gt; i.eq(&quot;name&quot;, &quot;李白&quot;).ne(&quot;status&quot;, &quot;活着&quot;))</code>—-&gt;<br><code>(name = &#39;李白&#39; and status &lt;&gt; &#39;活着&#39;)</code></td></tr></tbody></table></div><h3 id="BETWEEN"><a href="#BETWEEN" class="headerlink" title="BETWEEN"></a>BETWEEN</h3><div class="table-container"><table><thead><tr><th>操作</th><th>sql</th><th>语句</th></tr></thead><tbody><tr><td>between</td><td>BETWEEN</td><td><code>between(R column, Object val1, Object val2)</code><br><code>between(boolean condition, R column, Object val1, Object val2)</code></td></tr><tr><td>notBetween</td><td>NOT BETWEEN</td><td><code>notBetween(R column, Object val1, Object val2)</code><br><code>notBetween(boolean condition, R column, Object val1, Object val2)</code></td></tr></tbody></table></div><h3 id="LIKE"><a href="#LIKE" class="headerlink" title="LIKE"></a>LIKE</h3><div class="table-container"><table><thead><tr><th>操作</th><th>sql</th><th>语句</th></tr></thead><tbody><tr><td>like</td><td>LIKE ‘%值%’</td><td><code>like(R column, Object val)</code><br><code>like(boolean condition, R column, Object val)</code></td></tr><tr><td>notLike</td><td>NOT LIKE ‘%值%’</td><td><code>notLike(R column, Object val)</code><br><code>notLike(boolean condition, R column, Object val)</code></td></tr><tr><td>likeLeft</td><td>LIKE ‘%值’</td><td><code>likeLeft(R column, Object val)</code><br><code>likeLeft(boolean condition, R column, Object val)</code></td></tr><tr><td>likeRight</td><td>LIKE ‘值%’</td><td><code>likeRight(R column, Object val)</code><br><code>likeRight(boolean condition, R column, Object val)</code></td></tr></tbody></table></div><h3 id="NULL"><a href="#NULL" class="headerlink" title="NULL"></a>NULL</h3><div class="table-container"><table><thead><tr><th>操作</th><th>sql</th><th>语句</th></tr></thead><tbody><tr><td>isNull</td><td>IS NULL</td><td><code>isNull(R column)</code><br><code>isNull(boolean condition, R column)</code></td></tr><tr><td>isNotNull</td><td>IS NOT NULL</td><td><code>isNotNull(R column)</code><br><code>isNotNull(boolean condition, R column)</code></td></tr></tbody></table></div><h3 id="IN"><a href="#IN" class="headerlink" title="IN"></a>IN</h3><div class="table-container"><table><thead><tr><th>操作</th><th>sql</th><th>语句</th></tr></thead><tbody><tr><td>in</td><td><code>IN (value.get(0), value.get(1), ...)</code><br><code>IN (v0, v1, ...)</code></td><td><code>in(R column, Collection&lt;?&gt; value)</code><br><code>in(boolean condition, R column, Collection&lt;?&gt; value)</code><br><code>in(R column, Object... values)</code><br><code>in(boolean condition, R column, Object... values)</code></td></tr><tr><td>notIn</td><td><code>NOT IN (value.get(0), value.get(1), ...)</code><br><code>NOT IN (v0, v1, ...)</code></td><td><code>notIn(R column, Collection&lt;?&gt; value)</code><br><code>notIn(boolean condition, R column, Collection&lt;?&gt; value)</code><br><code>notIn(R column, Object... values)</code><br><code>notIn(boolean condition, R column, Object... values)</code></td></tr><tr><td>inSql</td><td>IN ( sql语句 )<br>可嵌套select语句</td><td>inSql(R column, String inValue) inSql(boolean condition, R column, String inValue)</td></tr><tr><td>notInSql</td><td>NOT IN ( sql语句 )<br>可嵌套select语句</td><td>notInSql(R column, String inValue) notInSql(boolean condition, R column, String inValue)</td></tr></tbody></table></div><h3 id="GROUPBY"><a href="#GROUPBY" class="headerlink" title="GROUPBY"></a>GROUPBY</h3><div class="table-container"><table><thead><tr><th>操作</th><th>sql</th><th>语句</th></tr></thead><tbody><tr><td>groupBy</td><td>GROUP BY 字段, …</td><td><code>groupBy(R... columns)</code><br><code>groupBy(boolean condition, R... columns)</code></td></tr></tbody></table></div><h3 id="ORDERBY"><a href="#ORDERBY" class="headerlink" title="ORDERBY"></a>ORDERBY</h3><div class="table-container"><table><thead><tr><th>操作</th><th>sql</th><th>语句</th></tr></thead><tbody><tr><td>orderByAsc</td><td>ORDER BY 字段, … ASC</td><td><code>orderByAsc(R... columns)</code><br><code>orderByAsc(boolean condition, R... columns)</code></td></tr><tr><td>orderByDesc</td><td>ORDER BY 字段, … DESC</td><td><code>orderByDesc(R... columns)</code><br><code>orderByDesc(boolean condition, R... columns)</code></td></tr><tr><td>orderBy</td><td>ORDER BY 字段, …</td><td><code>orderBy(boolean condition, boolean isAsc, R... columns)</code></td></tr></tbody></table></div><h3 id="HAVING"><a href="#HAVING" class="headerlink" title="HAVING"></a>HAVING</h3><div class="table-container"><table><thead><tr><th>操作</th><th>sql</th><th>语句</th></tr></thead><tbody><tr><td>having</td><td>HAVING ( sql语句 )</td><td><code>having(String sqlHaving, Object... params)</code><br><code>having(boolean condition, String sqlHaving, Object... params)</code></td></tr></tbody></table></div><h3 id="EXISTS"><a href="#EXISTS" class="headerlink" title="EXISTS"></a>EXISTS</h3><div class="table-container"><table><thead><tr><th>操作</th><th>sql</th><th>语句</th></tr></thead><tbody><tr><td>exists</td><td>EXISTS ( sql语句 )</td><td><code>exists(String existsSql)</code><br><code>exists(boolean condition, String existsSql)</code></td></tr><tr><td>notExists</td><td>NOT EXISTS ( sql语句 )</td><td><code>notExists(String notExistsSql)</code><br><code>notExists(boolean condition, String notExistsSql)</code></td></tr></tbody></table></div><h3 id="func"><a href="#func" class="headerlink" title="func"></a>func</h3><p>func 方法(主要方便在出现if…else下调用不同方法能不断链)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func(Consumer&lt;Children&gt; consumer)</span><br><span class="line">func(<span class="keyword">boolean</span> condition, Consumer&lt;Children&gt; consumer)</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 例</span></span><br><span class="line">func(i -&gt; <span class="keyword">if</span>(<span class="keyword">true</span>) &#123;i.eq(<span class="string">"id"</span>, <span class="number">1</span>)&#125; <span class="keyword">else</span> &#123;i.ne(<span class="string">"id"</span>, <span class="number">1</span>)&#125;)</span><br></pre></td></tr></table></figure><h3 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h3><p>拼接 sql</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">apply(String applySql, Object... params)</span><br><span class="line">apply(<span class="keyword">boolean</span> condition, String applySql, Object... params)</span><br><span class="line"><span class="comment">// 例: </span></span><br><span class="line">apply(<span class="string">"id = 1"</span>)  <span class="comment">// id = 1</span></span><br><span class="line">apply(<span class="string">"date_format(dateColumn,'%Y-%m-%d') = '2008-08-08'"</span>)<span class="comment">// date_format(dateColumn,'%Y-%m-%d') = '2008-08-08'")`</span></span><br><span class="line">apply(<span class="string">"date_format(dateColumn,'%Y-%m-%d') = &#123;0&#125;"</span>, <span class="string">"2008-08-08"</span>)<span class="comment">// date_format(dateColumn,'%Y-%m-%d') = '2008-08-08'")`</span></span><br></pre></td></tr></table></figure><blockquote><p>注意:</p><p>该方法可用于数据库函数动态入参的params对应前面applySql内部的{index}部分.<br>这样是不会有sql注入风险的,反之会有!</p></blockquote><h3 id="last"><a href="#last" class="headerlink" title="last"></a>last</h3><p>无视优化规则直接拼接到 sql 的最后</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">last(String lastSql)</span><br><span class="line">last(<span class="keyword">boolean</span> condition, String lastSql)</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 例子</span></span><br><span class="line">last(<span class="string">"limit 1"</span>)</span><br></pre></td></tr></table></figure><blockquote><p>注意: </p><p>只能调用一次，多次调用以最后一次为准，<strong>有sql注入的风险</strong></p></blockquote><h2 id="QueryWrapper"><a href="#QueryWrapper" class="headerlink" title="QueryWrapper"></a>QueryWrapper</h2><p>在<code>QueryWrapper</code>中通过<code>new QueryWrapper().lambda()</code>获取<code>LambdaQueryWrapper</code></p><h3 id="SELECT"><a href="#SELECT" class="headerlink" title="SELECT"></a>SELECT</h3><p>设置查询字段，即select <em> from中</em>的地方写的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select(String... sqlSelect)</span><br><span class="line">select(Predicate&lt;TableFieldInfo&gt; predicate)</span><br><span class="line">select(Class&lt;T&gt; entityClass, Predicate&lt;TableFieldInfo&gt; predicate)</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 例: </span></span><br><span class="line">select(<span class="string">"id"</span>, <span class="string">"name"</span>, <span class="string">"age"</span>)</span><br><span class="line">select(i -&gt; i.getProperty().startsWith(<span class="string">"test"</span>))</span><br></pre></td></tr></table></figure><p>注意：带<code>select</code>的查询返回的数据依旧是整个实体类只不过其他字段都是<code>null</code>，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">QueryWrapper classesWrapper = <span class="keyword">new</span> QueryWrapper&lt;Classes&gt;()</span><br><span class="line">                    .select(<span class="string">"id"</span>)</span><br><span class="line">                    .eq(<span class="string">"grade"</span>,<span class="string">"高三"</span>)</span><br><span class="line"># 用于接收的List&lt;Long&gt;就错了，其实接收到的是List&lt;Classes&gt;</span><br><span class="line">List&lt;Long&gt; classesList = classesService.list(classesWrapper);</span><br><span class="line"># 报错</span><br><span class="line">List&lt;Student&gt; students = studentService.list(<span class="keyword">new</span> QuerryWrapper&lt;Student&gt;().in(<span class="string">"class_id"</span>,classesList))</span><br></pre></td></tr></table></figure><h2 id="UpdateWrapper"><a href="#UpdateWrapper" class="headerlink" title="UpdateWrapper"></a>UpdateWrapper</h2><p>在<code>UpdateWrapper</code>中通过<code>new UpdateWrapper().lambda()</code>获取<code>LambdaUpdateWrapper</code></p><h3 id="SET"><a href="#SET" class="headerlink" title="SET"></a>SET</h3><p>SQL SET 字段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">set(String column, Object val)</span><br><span class="line">set(<span class="keyword">boolean</span> condition, String column, Object val)</span><br><span class="line">setSql(String sql)</span><br><span class="line"><span class="comment">// 例: </span></span><br><span class="line">set(<span class="string">"name"</span>, <span class="string">"张三"</span>)</span><br><span class="line">set(<span class="string">"name"</span>, <span class="string">""</span>)   <span class="comment">// 数据库字段值变为空字符串</span></span><br><span class="line">set(<span class="string">"name"</span>, <span class="keyword">null</span>) <span class="comment">// 数据库字段值变为空</span></span><br><span class="line">setSql(<span class="string">"name = '张三'"</span>)</span><br></pre></td></tr></table></figure><h2 id="LambdaWrapper"><a href="#LambdaWrapper" class="headerlink" title="LambdaWrapper"></a>LambdaWrapper</h2><p>使用lambda表达式的语法来操作</p><h3 id="LambdaQueryWrapper"><a href="#LambdaQueryWrapper" class="headerlink" title="LambdaQueryWrapper"></a>LambdaQueryWrapper</h3><p>在<code>QueryWrapper</code>中获取<code>LambdaQueryWrapper</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> QueryWrapper&lt;&gt;();</span><br><span class="line">queryWrapper.lambda()</span><br><span class="line">       .between(User::getAge,<span class="number">30</span>,<span class="number">60</span>)</span><br><span class="line">       .orderByDesc(User::getId);</span><br><span class="line">List&lt;User&gt; list = userService.list(queryWrapper);</span><br></pre></td></tr></table></figure><h3 id="LambdaUpdateWrapper"><a href="#LambdaUpdateWrapper" class="headerlink" title="LambdaUpdateWrapper"></a>LambdaUpdateWrapper</h3><p>在<code>UpdateWrapper</code>中获取<code>LambdaUpdateWrapper</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">UpdateWrapper&lt;User&gt; updateWrapper = <span class="keyword">new</span> UpdateWrapper&lt;&gt;();</span><br><span class="line">updateWrapper.lambda()</span><br><span class="line">.le(User::getAge, <span class="number">30</span>)</span><br><span class="line">.setSql(<span class="string">"email = 'abc@163.com'"</span>);</span><br><span class="line">userService.update(updateWrapper);</span><br></pre></td></tr></table></figure><blockquote><p>注意，使用<code>save()</code>接口和<code>update()</code>更新时若<code>wrapper</code>为<code>UpdateWrapper</code>，则为<code>null</code>的字段讲被跳过而不会更新为<code>null</code>，所以如果需要将某一字段置为null时，应使用<code>LambdaUpdateWrapper</code></p></blockquote><h1 id="自定义SQL"><a href="#自定义SQL" class="headerlink" title="自定义SQL"></a>自定义SQL</h1><h2 id="方案一：原始的自定义SQL方法"><a href="#方案一：原始的自定义SQL方法" class="headerlink" title="方案一：原始的自定义SQL方法"></a>方案一：原始的自定义SQL方法</h2><p>注意要在application.yml中配置Mapper接口对应的xml文件所在位置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.test.mapper.WxUserExtMapper"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--注意上面的namespace一定要修改--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 通用查询映射结果 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"BaseResultMap"</span> <span class="attr">type</span>=<span class="string">"com.test.entity.WxUser"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">property</span>=<span class="string">"id"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"openid"</span> <span class="attr">property</span>=<span class="string">"openid"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"nickname"</span> <span class="attr">property</span>=<span class="string">"nickname"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"sex"</span> <span class="attr">property</span>=<span class="string">"sex"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--以下是新增的方法--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectMethod"</span> <span class="attr">resultType</span>=<span class="string">"com.test.entity.WxUser"</span>&gt;</span></span><br><span class="line">        select * from wx_user;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"oneUser"</span> <span class="attr">parameterType</span>=<span class="string">"java.lang.Integer"</span> <span class="attr">resultType</span>=<span class="string">"com.test.entity.WxUser"</span>&gt;</span></span><br><span class="line">        select * from wx_user WHERE id = #&#123;id&#125;;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>mapper文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WxUserExtMapper</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="function">List&lt;WxUser&gt; <span class="title">selectMethod</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">WxUser <span class="title">oneUser</span><span class="params">(@Param(<span class="string">"id"</span>)</span> Integer id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方案二：自定义接口方法使用Wrapper条件构造器"><a href="#方案二：自定义接口方法使用Wrapper条件构造器" class="headerlink" title="方案二：自定义接口方法使用Wrapper条件构造器"></a>方案二：自定义接口方法使用Wrapper条件构造器</h2><p>如果我们想在自定义的方法中，使用Wrapper条件构造器。可以参考下面的方式实现。这种方式虽然简单，但仍然只适用于单表（可以是多表关联查询，但查询条件也是基于单表的）。</p><h3 id="使用注解方式-Wrapper"><a href="#使用注解方式-Wrapper" class="headerlink" title="使用注解方式 + Wrapper"></a>使用注解方式 + Wrapper</h3><p><code>${ew.customSqlSegment}</code>是一个查询条件占位符，代表Wapper查询条件，用于生成where</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Select</span>(<span class="string">"select * from `user` $&#123;ew.customSqlSegment&#125;"</span>)</span><br><span class="line"><span class="function">List&lt;User&gt; <span class="title">selectAll</span><span class="params">(@Param(Constants.WRAPPER)</span> Wrapper wrapper)</span>;</span><br></pre></td></tr></table></figure><h3 id="使用xml-配置方式-Wrapper"><a href="#使用xml-配置方式-Wrapper" class="headerlink" title="使用xml 配置方式 + Wrapper"></a>使用xml 配置方式 + Wrapper</h3><p><code>${ew.customSqlSegment}</code>是一个查询条件占位符，代表Wapper查询条件，用于生成where</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List&lt;User&gt; <span class="title">selectAll</span><span class="params">(@Param(Constants.WRAPPER)</span> Wrapper wrapper)</span>;</span><br><span class="line"></span><br><span class="line">&lt;select id=<span class="string">"selectAll"</span> resultType=<span class="string">"com.zimug.example.model.User"</span>&gt;</span><br><span class="line">  select * from `user` $&#123;ew.customSqlSegment&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><h3 id="通过Wapper传递查询参数"><a href="#通过Wapper传递查询参数" class="headerlink" title="通过Wapper传递查询参数"></a>通过Wapper传递查询参数</h3><p>上面两种方式任意选择一种，参数都是Wrapper</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCustomSQL2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  LambdaQueryWrapper&lt;User&gt; query = <span class="keyword">new</span> LambdaQueryWrapper&lt;&gt;();</span><br><span class="line">  query.eq(User::getName, <span class="string">"字母"</span>);</span><br><span class="line"></span><br><span class="line">  List&lt;User&gt; list = userMapper.selectAll(query);</span><br><span class="line">  list.forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最终得到的SQL</span></span><br><span class="line"><span class="comment">// SELECT id,name,age,email </span></span><br><span class="line"><span class="comment">// FROM user </span></span><br><span class="line"><span class="comment">// WHERE name = '字母'</span></span><br></pre></td></tr></table></figure><h1 id="ActiveRecord"><a href="#ActiveRecord" class="headerlink" title="ActiveRecord"></a>ActiveRecord</h1><p>Active Record(活动记录)，是一种领域模型模式，特点是一个模型类对应关系型数据库中的一个表，而模型类的一个实例对应表中的一行记录。</p><p>MyBatis-plus仅需让实体类继承<code>Model</code>类且实现主键指定方法即可</p><h2 id="启动AR的准备工作"><a href="#启动AR的准备工作" class="headerlink" title="启动AR的准备工作"></a>启动AR的准备工作</h2><p>domain</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">extends</span> <span class="title">Model</span>&lt;<span class="title">User</span>&gt; </span>&#123;    <span class="comment">// 实体类继承Model类，重写pkVal方法</span></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> Integer gender;</span><br><span class="line">    <span class="comment">//重写这个方法，return当前类的主键</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Serializable <span class="title">pkVal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mapper</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> <span class="keyword">extends</span> <span class="title">BaseMapper</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注：</strong>虽然AR模式不会直接调用该接口，但是一定要定义，否则使用AR时会报空指针异常。</p><h2 id="使用AR"><a href="#使用AR" class="headerlink" title="使用AR"></a>使用AR</h2><p>使用时并不需要注入mapper接口。AR操作是通过对象本身间接调用Mapper的相关方法，AR的大部分接口也与Mapper同名，比如要insert一个user，那就用这个user调用insert方法即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner.class)</span><br><span class="line"><span class="meta">@ContextConfiguration</span>(&#123;<span class="string">"classpath:spring/spring-dao.xml"</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAR</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 插入操作</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testArInsert</span><span class="params">()</span></span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setName(<span class="string">"林青霞"</span>);</span><br><span class="line">        user.setAge(<span class="number">22</span>);</span><br><span class="line">        user.setGender(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">boolean</span> result = user.insert();</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 更新操作</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testArUpdate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setId(<span class="number">1</span>);</span><br><span class="line">        user.setName(<span class="string">"刘亦菲"</span>);</span><br><span class="line">        <span class="keyword">boolean</span> result = user.updateById();</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查询操作</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testArSelect</span><span class="params">()</span></span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        <span class="comment">//1、根据id查询</span></span><br><span class="line">        <span class="comment">//user = user.selectById(1);</span></span><br><span class="line">        <span class="comment">//或者这样用</span></span><br><span class="line">        <span class="comment">//user.setId(1);</span></span><br><span class="line">        <span class="comment">//user = user.selectById();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2、查询所有</span></span><br><span class="line">        <span class="comment">//List&lt;User&gt; users = user.selectAll();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//3、根据条件查询</span></span><br><span class="line">        <span class="comment">//List&lt;User&gt; users = user.selectList(new EntityWrapper&lt;User&gt;().like("name","刘"));</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//4、查询符合条件的总数</span></span><br><span class="line">        <span class="keyword">int</span> result = user.selectCount(<span class="keyword">new</span> EntityWrapper&lt;User&gt;().eq(<span class="string">"gender"</span>,<span class="number">1</span>));</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 删除操作，删除数据库中不存在的数据，结果也是true</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testArDelete</span><span class="params">()</span></span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        <span class="comment">//删除数据库中不存在的数据也是返回true</span></span><br><span class="line">        <span class="comment">//1、根据id删除数据</span></span><br><span class="line">        <span class="comment">//boolean result = user.deleteById(1);</span></span><br><span class="line">        <span class="comment">//或者这样写</span></span><br><span class="line">        <span class="comment">//user.setId(1);</span></span><br><span class="line">        <span class="comment">//boolean result = user.deleteById();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2、根据条件删除</span></span><br><span class="line">        <span class="keyword">boolean</span> result = user.delete(<span class="keyword">new</span> EntityWrapper&lt;User&gt;().like(<span class="string">"name"</span>,<span class="string">"玲"</span>));</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 分页操作</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testArPage</span><span class="params">()</span></span>&#123;</span><br><span class="line">       User user = <span class="keyword">new</span> User();</span><br><span class="line">       Page&lt;User&gt; page =</span><br><span class="line">               user.selectPage(<span class="keyword">new</span> Page&lt;&gt;(<span class="number">1</span>,<span class="number">4</span>),</span><br><span class="line">               <span class="keyword">new</span> EntityWrapper&lt;User&gt;().like(<span class="string">"name"</span>,<span class="string">"刘"</span>));</span><br><span class="line">       List&lt;User&gt; users = page.getRecords();</span><br><span class="line">       System.out.println(users);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>分页操作的补充：</strong></p><p>这个分页方法和BaseMapper提供的分页一样都是内存分页，并非物理分页，因为sql语句中没用limit，和BaseMapper的selectPage方法一样，配置了分页插件后就可以实现真正的物理分页。</p><p>AR的分页方法与BaseMapper提供的分页方法不同的是，BaseMapper的selectPage方法返回值是查询到的记录的list集合，而AR的selectPage方法返回的是page对象，该page对象封装了查询到的信息，可以通过getRecords方法获取信息。</p></blockquote><p>参考：</p><p><a href="https://www.jianshu.com/p/a4d5d310daf8" target="_blank" rel="noopener">https://www.jianshu.com/p/a4d5d310daf8</a></p><p><a href="https://mybatis.plus/" target="_blank" rel="noopener">https://mybatis.plus/</a></p>]]></content>
      
      
      <categories>
          
          <category> JavaWeb </category>
          
          <category> JAVA与数据库 </category>
          
          <category> MyBatis-plus </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis-plus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA操作关系型数据库</title>
      <link href="/2020/08/25/Java/JavaWeb/JAVA%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93/JAVA%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%BC%E8%BF%B0/JAVA%E6%93%8D%E4%BD%9C%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
      <url>/2020/08/25/Java/JavaWeb/JAVA%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93/JAVA%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%BC%E8%BF%B0/JAVA%E6%93%8D%E4%BD%9C%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<p>JAVA的数据库操作可视为以下演变图，ORM框架中可以加入池化技术，ORM框架的底层都是JDBC实现，只是为了方便开发和解耦封装。</p><p><img alt="数据库操作演变" data-src="//orangesching.github.io/2020/08/25/Java/JavaWeb/JAVA与数据库/JAVA与数据库综述/JAVA操作关系型数据库/数据库操作演变.png" class="lazyload"></p><h1 id="原生JDBC"><a href="#原生JDBC" class="headerlink" title="原生JDBC"></a>原生JDBC</h1><p>JDBC是Java数据库连接，全称是Java Database Connectivity，简称JDBC，是Java语言中用来规范客户端程序如何来访问数据库的应用程序接口，提供了诸如查询和更新数据库中数据的方法。JDBC也是Sun Microsystems的商标。我们通常说的JDBC是面向关系型数据库的</p><h2 id="开发步骤"><a href="#开发步骤" class="headerlink" title="开发步骤"></a>开发步骤</h2><ol><li><p>注册驱动.，告知JVM使用的是哪一个数据库的驱动</p><p>-参数：“驱动程序类名”  </p><p>-<code>Class.forname(&quot;驱动程序类名&quot;)</code></p></li><li><p>获得连接.，使用JDBC中的类，完成对MySQL数据库的连接</p><p>需要三个参数：<code>url</code>, <code>username</code>, <code>password</code>- 连接到数据库</p></li><li><p>获得语句执行平台，通过连接对象获取对SQL语句的执行者对象</p><p>-<code>conn.getStatemnent()</code>方法创建对象用于执行SQL语句</p></li><li><p>执行SQL语句，使用执行者对象，向数据库执行SQL语句 获取到数据库的执行后的结果</p><p>-<code>execute(ddl)</code>执行任何SQL，常用于执行DDL、DCL</p><p>-<code>executeUpdate(dml)</code>执行DML语句，如：<code>insert</code>，<code>update</code>，<code>delete</code></p><p>-<code>executeQuery(dql)</code>执行DQL语句，如：<code>select</code></p></li><li><p>处理结果</p><p>-<code>execute(ddl)</code>如果没有异常则成功 boolean</p><p>-<code>executeUpdate(dml)</code>返回数字，表示更新“行”数量，抛出异常则失败  int</p><p>-<code>executeQuery(dql)</code>返回<code>ResultSet</code>（结果）对象，代表2维查询结果， <code>ResultSet</code>使用<code>for</code>遍历处理，如果查询失败抛出异常</p></li><li><p>释放连接</p><p>-<code>conn.close();</code></p></li></ol><p>注意写代码之前，要导入数据库驱动包，连接不同厂商的数据库要用不同的驱动包</p><p><img alt="JDBC" data-src="//orangesching.github.io/2020/08/25/Java/JavaWeb/JAVA与数据库/JAVA与数据库综述/JAVA操作关系型数据库/JDBC.png" class="lazyload"></p><p>示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.mysql.jdbc.ResultSetMetaData;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> dgm</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@describe</span> "原生jdbc"</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020年4月13日</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MysqlTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// JDBC 驱动名及数据库 URL</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String JDBC_DRIVER = <span class="string">"com.mysql.jdbc.Driver"</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String DB_URL = <span class="string">"jdbc:mysql://192.168.8.200:3306/bdrackdemo?useUnicode=true&amp;characterEncoding=utf8&amp;autoReconnect=true"</span>;</span><br><span class="line">    <span class="comment">// 数据库的用户名与密码，需要根据自己的设置</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String USER = <span class="string">"root"</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String PASS = <span class="string">"cstorfs"</span>;</span><br><span class="line">    <span class="keyword">static</span> Properties prop = <span class="keyword">new</span> Properties();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取数据库配置文件</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readDBSetting</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        Properties prop = <span class="keyword">new</span> Properties();</span><br><span class="line">        <span class="comment">// 读取属性文件mysql.properties</span></span><br><span class="line">        InputStream in = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            in = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(path));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 加载属性列表</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            prop.load(in);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; </span><br><span class="line">        Iterator&lt;String&gt; it = prop.stringPropertyNames().iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            String key = it.next();</span><br><span class="line">            System.out.println(key + <span class="string">"="</span> + prop.getProperty(key));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            in.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 读取mysql 配置信息</span></span><br><span class="line">        readDBSetting(<span class="string">"conf/mysql.properties"</span>);</span><br><span class="line"></span><br><span class="line">        Connection conn = <span class="keyword">null</span>;</span><br><span class="line">        Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">        ResultSet rs = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 注册 JDBC 驱动</span></span><br><span class="line">            Class.forName(prop.getProperty(<span class="string">"dbDriver"</span>)).newInstance();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 打开链接</span></span><br><span class="line">            System.out.println(<span class="string">"连接数据库..."</span>);</span><br><span class="line">            conn = DriverManager</span><br><span class="line">                    .getConnection(</span><br><span class="line">                            <span class="string">"jdbc:mysql://"</span></span><br><span class="line">                                    + prop.getProperty(<span class="string">"mysqlhost"</span>)</span><br><span class="line">                                    + <span class="string">":"</span></span><br><span class="line">                                    + prop.getProperty(<span class="string">"mysqlport"</span>)</span><br><span class="line">                                    + <span class="string">"/"</span></span><br><span class="line">                                    + prop.getProperty(<span class="string">"dbname"</span>)</span><br><span class="line">                                    + <span class="string">"?useUnicode=true&amp;characterEncoding=utf8&amp;autoReconnect=true"</span>,</span><br><span class="line">                            prop.getProperty(<span class="string">"mysqluser"</span>),</span><br><span class="line">                            prop.getProperty(<span class="string">"mysqlpwd"</span>));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 执行查询</span></span><br><span class="line">            System.out.println(<span class="string">" 实例化Statement对象..."</span>);</span><br><span class="line">            stmt = conn.createStatement();</span><br><span class="line">            String sql = <span class="string">"SELECT id, username, number FROM student"</span>;</span><br><span class="line">            rs = stmt.executeQuery(sql);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 展开结果集数据库</span></span><br><span class="line">            <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">                <span class="comment">// 输出数据</span></span><br><span class="line">                System.out.print(<span class="string">"用户id: "</span> + rs.getInt(<span class="string">"id"</span>));</span><br><span class="line">                System.out.print(<span class="string">", 用户名: "</span> + rs.getString(<span class="string">"username"</span>));</span><br><span class="line">                System.out.print(<span class="string">", 学号: "</span> + rs.getString(<span class="string">"number"</span>));</span><br><span class="line">                System.out.print(<span class="string">"\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException se) &#123;</span><br><span class="line">            se.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 关闭资源</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (rs != <span class="keyword">null</span>)</span><br><span class="line">                    rs.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException se3) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (stmt != <span class="keyword">null</span>)</span><br><span class="line">                    stmt.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException se2) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (conn != <span class="keyword">null</span>)</span><br><span class="line">                    conn.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException se) &#123;</span><br><span class="line">                se.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>早期开发将上述代码自己封装成JDBC工具，传入SQL语句。这种模式在规模不大的情况下，使用起来挺好</p><h2 id="开发技巧"><a href="#开发技巧" class="headerlink" title="开发技巧"></a>开发技巧</h2><ol><li>使用PrearedStatement，可以通过预编译的方式避免在拼接SQL时造成SQL注入。</li><li>使用ConnectionPool</li><li>禁用自动提交<br>这个最佳实践在我们使用JDBC的批量提交的时候显得非常有用，将自动提交禁用后，你可以将一组数据库操作放在一个事务中，而自动提交模式每次执行SQL语句都将执行自己的事务，并且在执行结束提交。</li><li>使用Batch Update：批量更新/删除，比单个更新/删除，能显著减少数据传输的往返次数，提高性能。</li><li>使用列名获取ResultSet中的数据，从而避免invalidColumIndexError<br>JDBC中的查询结果封装在ResultSet中，我们可以通过列名和列序号两种方式获取查询的数据，当我们传入的列序号不正确的时候，就会抛出invalidColumIndexException，例如你传入了0，就会出错，因为ResultSet中的列序号是从1开始的。另外，如果你更改了数据表中列的顺序，你也不必更改JDBC代码，保持了程序的健壮性。有一些Java程序员可能会说通过序号访问列要比列名访问快一些，确实是这样，但是为了程序的健壮性、可读性，我还是更推荐你使用列名来访问。</li><li>使用变量绑定而不是字符串拼接<br>使用PreparedStatment可以防止注入，而使用<code>?</code>或者其他占位符也会提升性能，因为这样数据库就可以使用不同的参数执行相同的查询，提示性能，也防止SQL注入。</li><li>关闭Connection 等资源，确保资源被释放；</li><li>选择合适的JDBC驱动，参考前文，选择第四种；</li><li>尽量使用标准的SQL语句，从而在某种程度上避免数据库对SQL支持的差异<br>不同的数据库厂商的数据库产品支持的SQL的语法会有一定的出入，为了方便移植，推荐使用标准的ANSI SQL标准写SQL语句。</li><li>使用正确的getXXX()方法<br>当从ResultSet中读取数据的时候，虽然JDBC允许你使用getString()和getObject()方法获取任何数据类型，推荐使用正确的getter方法，这样可以避免数据类型转换。</li></ol><h2 id="连接步骤"><a href="#连接步骤" class="headerlink" title="连接步骤"></a>连接步骤</h2><p>JAVA操作关系型数据库<img alt="JDBC连接" data-src="//orangesching.github.io/2020/08/25/Java/JavaWeb/JAVA与数据库/JAVA与数据库综述/JAVA操作关系型数据库/JDBC连接.png" class="lazyload"></p><p>上图大致画出以访问MySQL为例，执行一条 SQL 命令的流程：</p><ol><li>TCP建立连接的三次握手；</li><li>MySQL认证的三次握手；</li><li>真正的SQL执行；</li><li>MySQL的关闭；</li><li>TCP的四次握手关闭；</li></ol><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>由上图可知，为了执行一条SQL，有大量的网络交互，性价比低<br><strong>优点</strong>：实现简单<br><strong>缺点</strong>：</p><ol><li>网络IO较多</li><li>数据库的负载较高</li><li>响应时间较长及QPS较低</li><li>应用频繁的创建连接和关闭连接，导致临时对象较多，GC频繁</li><li>在关闭连接后，会出现大量TIME_WAIT 的TCP状态(在2个MSL之后关闭)。</li><li>大项目中使用很复杂</li><li>没有封装</li><li>难以实现 MVC 的概念</li><li>很大的编程成本</li></ol><h1 id="池化数据库连接的JDBC"><a href="#池化数据库连接的JDBC" class="headerlink" title="池化数据库连接的JDBC"></a>池化数据库连接的JDBC</h1><p>原生JDBC的瓶颈在于数据库连接，通过池化技术可解决</p><h2 id="池化连接"><a href="#池化连接" class="headerlink" title="池化连接"></a>池化连接</h2><blockquote><p>池化技术简单点说就是预先连接好一定数量的连接，等需要时随意从中选择一个进行操作。比如线程池。</p></blockquote><p>连接池负责：连接建立、连接释放、连接管理、连接分配。</p><p><strong>数据库连接池运行机制</strong><br>系统初始化时创建连接池，程序操作数据库时从连接池中获取空闲连接，程序使用完毕将连接归还到连接池中，系统退出时，断开所有数据库连接并释放内存资源。</p><p><strong>使用池化连接的好处</strong></p><ol><li>性能。连接到数据库既昂贵又缓慢。池化连接可以保持与数据库的物理连接，并在需要数据库访问的各个组件之间共享。这样一来，连接成本便一次性支付，并在所有消耗组件中摊销。</li><li>诊断。如果您有一个子系统负责连接到数据库，则诊断和分析数据库连接使用情况将变得更加容易。</li><li>可维护性。同样，如果您有一个子系统负责分发数据库连接，则与每个组件都连接到数据库本身相比，代码将更易于维护。</li></ol><p><strong>为什么池化连接能带来性能上的提高</strong></p><p>因为无论何时请求一个连接，池数据源会从可用的连接池获取新连接。仅当没有可用的连接而且未达到最大的连接数时连接池将创建新的连接。<code>close()</code>方法把连接返回到连接池而不是真正地关闭它</p><p>重用数据库连接最明显的原因：</p><ul><li>减少应用程序和数据库管理系统创建/销毁TCP连接的OS I/O开销</li><li>减少JVM对象垃圾</li><li>缓冲安全：连接池是即将到来的连接请求的有界缓冲区。如果出现瞬间流量尖峰，连接池会平缓这一变化，而不是使所有可用数据库资源趋于饱和。</li><li>等待步骤和超时机制，可有效防止数据库服务器过载。如果一个应用消耗太多数据库流量，为防止它将数据库服务器压垮，连接池将减少它对数据库的使用。</li></ul><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><ul><li>C3P0：开源JDBC连接池，实现数据源和JNDI绑定，包括实现jdbc3和jdbc2扩展规范说明的Connection 和Statement 池的DataSources 对象。单线程，性能较差，适用于小型系统，代码600KB左右。</li><li>BoneCP：开源的快速的 JDBC 连接池。只有四十几K（运行时需要log4j和Google Collections的支持）。另外个人觉得 BoneCP 有个缺点是，JDBC驱动的加载是在连接池之外的，这样在一些应用服务器的配置上就不够灵活。官方说法BoneCP是一个高效、免费、开源的Java数据库连接池实现库。设计初衷就是为了提高数据库连接池性能，完美集成到一些持久化产品如Hibernate和DataNucleus中。特色：高度可扩展，快速；连接状态切换的回调机制；允许直接访问连接；自动化重置能力；JMX支持；懒加载能力；支持XML和属性文件配置方式；较好的Java代码组织。</li><li>DBCP：Database Connection Pool，一个依赖Jakarta commons-pool对象池机制的数据库连接池，单独使用dbcp需要3个包：<code>common-dbcp.jar,common-pool.jar,common-collections.jar</code>，预先将数据库连接放在内存中，应用程序需要建立数据库连接时直接到连接池中申请一个就行，用完再放回。单线程，并发量低，性能不好，适用于小型系统。</li><li>Tomcat Jdbc Pool：Tomcat在7.0以前都是使用common-dbcp做为连接池组件，但是dbcp是单线程，为保证线程安全会锁整个连接池，性能较差，dbcp有超过60个类，也相对复杂。Tomcat从7.0开始引入新增连接池模块叫做Tomcat jdbc pool，基于Tomcat JULI，使用Tomcat日志框架，完全兼容dbcp，通过异步方式获取连接，支持高并发应用环境，超级简单核心文件只有8个，支持JMX，支持XA Connection。</li><li>Druid：阿里出品，淘宝和支付宝专用数据库连接池，但它不仅仅是一个数据库连接池，它还包含一个ProxyDriver，一系列内置的JDBC组件库，一个SQL Parser。支持所有JDBC兼容的数据库。Druid针对Oracle和MySQL特别优化，比如Oracle的PS Cache内存占用优化，MySQL的ping检测优化。</li><li>HikariCP：新一代数据库连接池，性能相当优异，spring boot 2 默认使用的 dbcp 从之前的 tomcat-pool 换成HikariCP 。</li></ul><h2 id="开发步骤-1"><a href="#开发步骤-1" class="headerlink" title="开发步骤"></a>开发步骤</h2><ol><li>导入连接池jar</li><li>创建连接池对象</li><li>设置数据库必须的连接参数</li><li>设置可选的连接池管理策略参数</li><li>从连接池中获得活动的数据库连接</li><li>使用连接范围数据量</li><li>使用以后关闭数据库连接，这个关闭不再是真的关闭连接，而是将使用过的连接归还给连接池</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DBUtils</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String driver;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String url;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String username;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String password;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> initSize;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> BasicDataSource ds; <span class="comment">//连接池就一个</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        ds = <span class="keyword">new</span> BasicDataSource();</span><br><span class="line">        Properties cfg = <span class="keyword">new</span> Properties();</span><br><span class="line">        <span class="comment">//初始化静态属性</span></span><br><span class="line">        <span class="comment">//利用properties 读取配置文件</span></span><br><span class="line">        <span class="comment">//从配置文件中查找相应参数</span></span><br><span class="line">        <span class="keyword">try</span> &#123;            <span class="comment">//load天生有异常</span></span><br><span class="line">            InputStream in = DBUtils.class.getClassLoader()</span><br><span class="line">                    .getResourceAsStream(<span class="string">"db.properties"</span>);</span><br><span class="line">            cfg.load(in);</span><br><span class="line"> </span><br><span class="line">            driver = cfg.getProperty(<span class="string">"jdbc.driver"</span>);</span><br><span class="line">            url = cfg.getProperty(<span class="string">"jdbc.url"</span>);</span><br><span class="line">            username = cfg.getProperty(<span class="string">"jdbc.username"</span>);</span><br><span class="line">            password = cfg.getProperty(<span class="string">"jdbc.pasaword"</span>);</span><br><span class="line">            initSize = Integer.parseInt(cfg.getProperty(<span class="string">"initSize"</span>));</span><br><span class="line">            in.close();</span><br><span class="line">            <span class="comment">//初始化连接池</span></span><br><span class="line">            ds.setDriverClassName(driver);</span><br><span class="line">            ds.setUrl(url);</span><br><span class="line">            ds.setUsername(username);</span><br><span class="line">            ds.setPassword(password);</span><br><span class="line">            <span class="comment">//设置连接池的管理策略参数</span></span><br><span class="line">            ds.setInitialSize(initSize);</span><br><span class="line"> </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//getConnection()从连接池获取重用的连接，如果连接池满了，则等待</span></span><br><span class="line">            <span class="comment">//如果连接归还，则获取重用的连接; 连接池的线程阻塞方法</span></span><br><span class="line">            Connection conn = ds.getConnection();</span><br><span class="line">            <span class="keyword">return</span> conn;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Connection conn)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//将用过的连接归还到连接池</span></span><br><span class="line">            <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">                conn.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rollback</span><span class="params">(Connection conn)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//将用过的连接归还到连接池</span></span><br><span class="line">            <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">                conn.rollback();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Hibernate"><a href="#Hibernate" class="headerlink" title="Hibernate"></a>Hibernate</h1><p>JDBC的另一方面的缺点是不易于大型项目的开发，Hibernate的出现就是为了弥补这一缺陷</p><p>Hibernate是一个持久化框架和ORM框架，持久化和ORM是两个有区别的概念，持久化注重对象的存储方法是否随着程序的退出而消亡，ORM关注的是如何在数据库表和内存对象之间建立关联。</p><p>Hibernate使用POJO来表示Model，使用XML配置文件来配置对象和表之间的关系，它提供了一系列API来通过对对象的操作而改变数据库中的过程。</p><p>Hibernate更强调如何对单条记录进行操作，对于更复杂的操作，它提供了一种新的面向对象的查询语言：HQL。</p><blockquote><p>当我们工作在一个面向对象的系统中时，存在一个对象模型和关系数据库不匹配的问题。RDBMSs 用表格的形式存储数据，然而像 Java 或者 C# 这样的面向对象的语言它表示一个对象关联图。这时就需要ORM</p><p>ORM 表示 Object-Relational Mapping (ORM)，是一个方便在关系数据库和类似于 Java， C# 等面向对象的编程语言中转换数据的技术。一个 ORM 系统相比于普通的 JDBC 有以下的优点。</p><ul><li>使用业务代码访问对象而不是数据库中的表</li><li>从面向对象逻辑中隐藏 SQL 查询的细节</li><li>基于 JDBC 的 ‘under the hood’</li><li>没有必要去处理数据库实现</li><li>实体是基于业务的概念而不是数据库的结构</li><li>事务管理和键的自动生成</li><li>应用程序的快速开发</li></ul></blockquote><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><div class="table-container"><table><thead><tr><th><img alt="架构" data-src="//orangesching.github.io/2020/08/25/Java/JavaWeb/JAVA与数据库/JAVA与数据库综述/JAVA操作关系型数据库/hibernate_architecture.jpg" class="lazyload"></th><th><img alt="高层次架构" data-src="//orangesching.github.io/2020/08/25/Java/JavaWeb/JAVA与数据库/JAVA与数据库综述/JAVA操作关系型数据库/hibernate_high_level.jpg" class="lazyload"></th></tr></thead><tbody><tr><td>详细的 Hibernate 应用程序体系结构</td><td>非常高水平的 Hibernate 应用程序架构</td></tr></tbody></table></div><p>Hibernate 架构是分层的，作为数据访问层，你不必知道底层 API 。Hibernate 利用数据库以及配置数据来为应用程序提供持续性服务（以及持续性对象）</p><p>Hibernate 使用不同的现存 Java API，比如 JDBC，Java 事务 API（JTA），以及 Java 命名和目录界面（JNDI）。JDBC 提供了一个基本的抽象级别的通用关系数据库的功能， Hibernate 支持几乎所有带有 JDBC 驱动的数据库。JNDI 和 JTA 允许 Hibernate 与 J2EE 应用程序服务器相集成。</p><h2 id="开发步骤-2"><a href="#开发步骤-2" class="headerlink" title="开发步骤"></a>开发步骤</h2><h3 id="准备Hibernate环境"><a href="#准备Hibernate环境" class="headerlink" title="准备Hibernate环境"></a>准备Hibernate环境</h3><p>导入Hibernate必须的jar包：导入hibernate-release-5.0.2.Final\lib\required下的jar包</p><p>加入数据库驱动的jar包</p><h3 id="创建核心配置文件"><a href="#创建核心配置文件" class="headerlink" title="创建核心配置文件"></a>创建核心配置文件</h3><p>Hibernate 需要事先知道在哪里找到映射信息，这些映射信息定义了 Java 类怎样关联到数据库表。Hibernate 也需要一套相关数据库和其它相关参数的配置设置。</p><p>所有这些信息通常是作为一个标准的 Java 属性文件提供的，名叫 <code>hibernate.properties</code>。又或者是作为 XML 文件提供的，名叫 <code>hibernate.cfg.xml</code></p><p>例子：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE hibernate-configuration PUBLIC</span></span><br><span class="line"><span class="meta">        "-//Hibernate/Hibernate Configuration DTD 3.0//EN"</span></span><br><span class="line"><span class="meta">        "http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">session-factory</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">        <span class="comment">&lt;!-- 配置连接数据库的基本信息 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"connection.username"</span>&gt;</span>root<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"connection.password"</span>&gt;</span>ds756953242<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"connection.driver_class"</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"connection.url"</span>&gt;</span>jdbc:mysql:///hibernate<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!-- 配置 hibernate 的基本信息 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- hibernate 所使用的数据库方言 </span></span><br><span class="line"><span class="comment">        &lt;property name="dialect"&gt;org.hibernate.dialect.MySQLMyISAMDialect&lt;/property&gt;        </span></span><br><span class="line"><span class="comment">        &lt;property name="dialect"&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt;        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dialect"</span>&gt;</span>org.hibernate.dialect.MySQL5InnoDBDialect<span class="tag">&lt;/<span class="name">property</span>&gt;</span>        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!-- 执行操作时是否在控制台打印 SQL --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"show_sql"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">        <span class="comment">&lt;!-- 是否对 SQL 进行格式化 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"format_sql"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">        <span class="comment">&lt;!-- 指定自动生成数据表的策略 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hbm2ddl.auto"</span>&gt;</span>update<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!-- 指定关联的 .hbm.xml 文件 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapping</span> <span class="attr">resource</span>=<span class="string">"helloWorld/customer.hbm.xml"</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;/<span class="name">session-factory</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="创建持久化Java类"><a href="#创建持久化Java类" class="headerlink" title="创建持久化Java类"></a>创建持久化Java类</h3><p>在 Hibernate 中，其对象或实例将会被存储在数据库表单中的 Java 类被称为持久化类。若该类遵循一些简单的规则或者被大家所熟知的 Plain Old Java Object (POJO) 编程模型。</p><p><strong>持久化类的要求</strong></p><ol><li>提供一个无参的构造器：使Hibernate可以使用<code>Constructor.newInstance()</code> 来实例化持久化类</li><li>为了使对象能够在 Hibernate 和数据库中容易识别，所有类都需要包含一个 ID。此属性映射到数据库表的主键列。</li><li>为类的持久化类字段声明访问方法(<code>get/set</code>): Hibernate对JavaBeans 风格的属性实行持久化。</li><li>所有将被持久化的属性都应该声明为 private</li><li>使用非 final 类: 在运行时生成代理是 Hibernate 的一个重要的功能. 如果持久化类没有实现任何接口, Hibnernate 使用 CGLIB 生成代理. 如果使用的是 final 类, 则无法生成 CGLIB 代理.</li><li>重写 eqauls 和 hashCode 方法: 如果需要把持久化类的实例放到 Set 中(当需要进行关联映射时), 则应该重写这两个方法</li><li>Hibernate 不要求持久化类继承任何父类或实现接口，这可以保证代码不被污染。这就是Hibernate被称为低侵入式设计的原因</li></ol><p>例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">   <span class="keyword">private</span> String firstName; </span><br><span class="line">   <span class="keyword">private</span> String lastName;   </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> salary;  </span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      firstName=<span class="keyword">null</span>;</span><br><span class="line">      lastName=<span class="keyword">null</span>;</span><br><span class="line">      salary =<span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(String fname, String lname, <span class="keyword">int</span> salary)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.firstName = fname;</span><br><span class="line">      <span class="keyword">this</span>.lastName = lname;</span><br><span class="line">      <span class="keyword">this</span>.salary = salary;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> id;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">( <span class="keyword">int</span> id )</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.id = id;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getFirstName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> firstName;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirstName</span><span class="params">( String first_name )</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.firstName = first_name;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getLastName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> lastName;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLastName</span><span class="params">( String last_name )</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.lastName = last_name;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSalary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> salary;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSalary</span><span class="params">( <span class="keyword">int</span> salary )</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.salary = salary;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建对象-关系映射文件"><a href="#创建对象-关系映射文件" class="headerlink" title="创建对象-关系映射文件"></a>创建对象-关系映射文件</h3><p>Hibernate 采用 XML 格式的文件来指定对象和关系数据之间的映射. 在运行时 Hibernate 将根据这个映射文件来生成各种 SQL 语句。映射文件的扩展名为 <code>.hbm.xml</code>。</p><p>有很多工具可以用来给先进的 Hibernate 用户生成映射文件。这样的工具包括 <strong>XDoclet</strong>, <strong>Middlegen</strong> 和 <strong>AndroMDA</strong></p><p>下面是一个Mapping映射文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE hibernate-mapping PUBLIC </span></span><br><span class="line"><span class="meta"> "-//Hibernate/Hibernate Mapping DTD//EN"</span></span><br><span class="line"><span class="meta"> "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">"Employee"</span> <span class="attr">table</span>=<span class="string">"EMPLOYEE"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">meta</span> <span class="attr">attribute</span>=<span class="string">"class-description"</span>&gt;</span></span><br><span class="line">         This class contains the employee detail. </span><br><span class="line">      <span class="tag">&lt;/<span class="name">meta</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">type</span>=<span class="string">"int"</span> <span class="attr">column</span>=<span class="string">"id"</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"native"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"firstName"</span> <span class="attr">column</span>=<span class="string">"first_name"</span> <span class="attr">type</span>=<span class="string">"string"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"lastName"</span> <span class="attr">column</span>=<span class="string">"last_name"</span> <span class="attr">type</span>=<span class="string">"string"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"salary"</span> <span class="attr">column</span>=<span class="string">"salary"</span> <span class="attr">type</span>=<span class="string">"int"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>&lt;class&gt;</code>标签定义从一个 Java 类到数据库表的特定映射。Java 的类名使用 <strong>name</strong> 来表示，数据库表明用 <strong>table</strong> 来表示。</p><p><code>&lt;meta&gt;</code> 标签是一个可选元素，可以被用来修饰类。</p><p><code>&lt;id&gt;</code> 标签将类中独一无二的 ID 属性与数据库表中的主键关联起来。id 元素中的 <strong>name</strong> 对应类的属性，<strong>column</strong> 对应数据库表的列。<strong>type</strong> 保存 Hibernate 映射的类型，这个类型会将从 Java 转换成 SQL 数据类型。</p><p> id 元素中的 <code>&lt;generator&gt;</code> 标签用来自动生成主键值。设置 generator 标签中的 <strong>class</strong> 可以设置 <strong>native</strong> 使 Hibernate 可以使用 <strong>identity</strong>, <strong>sequence</strong> 或 <strong>hilo</strong> 算法根据底层数据库的情况来创建主键。</p><p><code>&lt;property&gt;</code> 标签用来将 Java 类的属性与数据库表的列匹配。标签中 <strong>name</strong> 引用的是类的属性，<strong>column</strong> 引用的是数据库表的列。<strong>type</strong> 保存 Hibernate <a href="https://www.w3cschool.cn/hibernate/fzum1iem.html" target="_blank" rel="noopener">映射的类型</a>，这个类型会将从 Java 转换成 SQL 数据类型。</p><h3 id="通过-Hibernate-API-编写访问数据库"><a href="#通过-Hibernate-API-编写访问数据库" class="headerlink" title="通过 Hibernate API 编写访问数据库"></a>通过 Hibernate API 编写访问数据库</h3><h4 id="创建会话Session"><a href="#创建会话Session" class="headerlink" title="创建会话Session"></a>创建会话Session</h4><p>Session 用于获取与数据库的物理连接。 Session 对象是轻量级的，并且设计为在每次需要与数据库进行交互时被实例化。持久态对象被保存，并通过 Session 对象检索找回。</p><p>该 Session 对象不应该长时间保持开放状态，因为它们通常不能保证线程安全，而应该根据需求被创建和销毁。Session 的主要功能是为映射实体类的实例提供创建，读取和删除操作。</p><h4 id="创建事务"><a href="#创建事务" class="headerlink" title="创建事务"></a>创建事务</h4><p>一个典型的事务应该使用以下语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Session session = factory.openSession();</span><br><span class="line">Transaction tx = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   tx = session.beginTransaction();</span><br><span class="line">   <span class="comment">// do some work</span></span><br><span class="line">   ...</span><br><span class="line">   tx.commit();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">   <span class="keyword">if</span> (tx!=<span class="keyword">null</span>) tx.rollback();</span><br><span class="line">   e.printStackTrace(); </span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">   session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 Session 引发异常，则事务必须被回滚，该 session 必须被丢弃。</p><h4 id="Session-接口方法"><a href="#Session-接口方法" class="headerlink" title="Session 接口方法"></a>Session 接口方法</h4><div class="table-container"><table><thead><tr><th>序号</th><th style="text-align:left">Session 方法及说明</th></tr></thead><tbody><tr><td>1</td><td style="text-align:left"><strong>Transaction beginTransaction()</strong> 开始工作单位，并返回关联事务对象。</td></tr><tr><td>2</td><td style="text-align:left"><strong>void cancelQuery()</strong> 取消当前的查询执行。</td></tr><tr><td>3</td><td style="text-align:left"><strong>void clear()</strong> 完全清除该会话。</td></tr><tr><td>4</td><td style="text-align:left"><strong>Connection close()</strong> 通过释放和清理 JDBC 连接以结束该会话。</td></tr><tr><td>5</td><td style="text-align:left"><strong>Criteria createCriteria(Class persistentClass)</strong> 为给定的实体类或实体类的超类创建一个新的 Criteria 实例。</td></tr><tr><td>6</td><td style="text-align:left"><strong>Criteria createCriteria(String entityName)</strong> 为给定的实体名称创建一个新的 Criteria 实例。</td></tr><tr><td>7</td><td style="text-align:left"><strong>Serializable getIdentifier(Object object)</strong> 返回与给定实体相关联的会话的标识符值。</td></tr><tr><td>8</td><td style="text-align:left"><strong>Query createFilter(Object collection, String queryString)</strong> 为给定的集合和过滤字符创建查询的新实例。</td></tr><tr><td>9</td><td style="text-align:left"><strong>Query createQuery(String queryString)</strong> 为给定的 HQL 查询字符创建查询的新实例。</td></tr><tr><td>10</td><td style="text-align:left"><strong>SQLQuery createSQLQuery(String queryString)</strong> 为给定的 SQL 查询字符串创建 SQLQuery 的新实例。</td></tr><tr><td>11</td><td style="text-align:left"><strong>void delete(Object object)</strong> 从数据存储中删除持久化实例。</td></tr><tr><td>12</td><td style="text-align:left"><strong>void delete(String entityName, Object object)</strong> 从数据存储中删除持久化实例。</td></tr><tr><td>13</td><td style="text-align:left"><strong>Session get(String entityName, Serializable id)</strong> 返回给定命名的且带有给定标识符或 null 的持久化实例（若无该种持久化实例）。</td></tr><tr><td>14</td><td style="text-align:left"><strong>SessionFactory getSessionFactory()</strong> 获取创建该会话的 session 工厂。</td></tr><tr><td>15</td><td style="text-align:left"><strong>void refresh(Object object)</strong> 从基本数据库中重新读取给定实例的状态。</td></tr><tr><td>16</td><td style="text-align:left"><strong>Transaction getTransaction()</strong> 获取与该 session 关联的事务实例。</td></tr><tr><td>17</td><td style="text-align:left"><strong>boolean isConnected()</strong> 检查当前 session 是否连接。</td></tr><tr><td>18</td><td style="text-align:left"><strong>boolean isDirty()</strong> 该 session 中是否包含必须与数据库同步的变化？</td></tr><tr><td>19</td><td style="text-align:left"><strong>boolean isOpen()</strong> 检查该 session 是否仍处于开启状态。</td></tr><tr><td>20</td><td style="text-align:left"><strong>Serializable save(Object object)</strong> 先分配一个生成的标识，以保持给定的瞬时状态实例。</td></tr><tr><td>21</td><td style="text-align:left"><strong>void saveOrUpdate(Object object)</strong> 保存（对象）或更新（对象）给定的实例。</td></tr><tr><td>22</td><td style="text-align:left"><strong>void update(Object object)</strong> 更新带有标识符且是给定的处于脱管状态的实例的持久化实例。</td></tr><tr><td>23</td><td style="text-align:left"><strong>void update(String entityName, Object object)</strong> 更新带有标识符且是给定的处于脱管状态的实例的持久化实例。</td></tr></tbody></table></div><h4 id="HQL语法"><a href="#HQL语法" class="headerlink" title="HQL语法"></a>HQL语法</h4><p>Hibernate 查询语言（HQL）是一种面向对象的查询语言，类似于 SQL，但不是去对表和列进行操作，而是面向对象和它们的属性。 HQL 查询被 Hibernate 翻译为传统的 SQL 查询从而对数据库进行操作。</p><p>尽管你能直接使用本地 SQL 语句，但我还是建议你尽可能的使用 HQL 语句，以避免数据库关于可移植性的麻烦，并且体现了 Hibernate 的 SQL 生成和缓存策略。</p><p>在 HQL 中一些关键字比如 SELECT ，FROM 和 WHERE 等，是不区分大小写的，但是一些属性比如表名和列名是区分大小写的。</p><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List; </span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator; </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.hibernate.HibernateException; </span><br><span class="line"><span class="keyword">import</span> org.hibernate.Session; </span><br><span class="line"><span class="keyword">import</span> org.hibernate.Transaction;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.SessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.cfg.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ManageEmployee</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> SessionFactory factory; </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">try</span>&#123;</span><br><span class="line">         factory = <span class="keyword">new</span> Configuration().configure().buildSessionFactory();</span><br><span class="line">      &#125;<span class="keyword">catch</span> (Throwable ex) &#123; </span><br><span class="line">         System.err.println(<span class="string">"Failed to create sessionFactory object."</span> + ex);</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> ExceptionInInitializerError(ex); </span><br><span class="line">      &#125;</span><br><span class="line">      ManageEmployee ME = <span class="keyword">new</span> ManageEmployee();</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Add few employee records in database */</span></span><br><span class="line">      Integer empID1 = ME.addEmployee(<span class="string">"Zara"</span>, <span class="string">"Ali"</span>, <span class="number">1000</span>);</span><br><span class="line">      Integer empID2 = ME.addEmployee(<span class="string">"Daisy"</span>, <span class="string">"Das"</span>, <span class="number">5000</span>);</span><br><span class="line">      Integer empID3 = ME.addEmployee(<span class="string">"John"</span>, <span class="string">"Paul"</span>, <span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* List down all the employees */</span></span><br><span class="line">      ME.listEmployees();</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Update employee's records */</span></span><br><span class="line">      ME.updateEmployee(empID1, <span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Delete an employee from the database */</span></span><br><span class="line">      ME.deleteEmployee(empID2);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* List down new list of the employees */</span></span><br><span class="line">      ME.listEmployees();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/* Method to CREATE an employee in the database */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Integer <span class="title">addEmployee</span><span class="params">(String fname, String lname, <span class="keyword">int</span> salary)</span></span>&#123;</span><br><span class="line">      Session session = factory.openSession();</span><br><span class="line">      Transaction tx = <span class="keyword">null</span>;</span><br><span class="line">      Integer employeeID = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">try</span>&#123;</span><br><span class="line">         tx = session.beginTransaction();</span><br><span class="line">         Employee employee = <span class="keyword">new</span> Employee(fname, lname, salary);</span><br><span class="line">         employeeID = (Integer) session.save(employee); </span><br><span class="line">         tx.commit();</span><br><span class="line">      &#125;<span class="keyword">catch</span> (HibernateException e) &#123;</span><br><span class="line">         <span class="keyword">if</span> (tx!=<span class="keyword">null</span>) tx.rollback();</span><br><span class="line">         e.printStackTrace(); </span><br><span class="line">      &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">         session.close(); </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> employeeID;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/* Method to  READ all the employees */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listEmployees</span><span class="params">( )</span></span>&#123;</span><br><span class="line">      Session session = factory.openSession();</span><br><span class="line">      Transaction tx = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">try</span>&#123;</span><br><span class="line">         tx = session.beginTransaction();</span><br><span class="line">         List employees = session.createQuery(<span class="string">"FROM Employee"</span>).list(); </span><br><span class="line">         <span class="keyword">for</span> (Iterator iterator = </span><br><span class="line">                           employees.iterator(); iterator.hasNext();)&#123;</span><br><span class="line">            Employee employee = (Employee) iterator.next(); </span><br><span class="line">            System.out.print(<span class="string">"First Name: "</span> + employee.getFirstName()); </span><br><span class="line">            System.out.print(<span class="string">"  Last Name: "</span> + employee.getLastName()); </span><br><span class="line">            System.out.println(<span class="string">"  Salary: "</span> + employee.getSalary()); </span><br><span class="line">         &#125;</span><br><span class="line">         tx.commit();</span><br><span class="line">      &#125;<span class="keyword">catch</span> (HibernateException e) &#123;</span><br><span class="line">         <span class="keyword">if</span> (tx!=<span class="keyword">null</span>) tx.rollback();</span><br><span class="line">         e.printStackTrace(); </span><br><span class="line">      &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">         session.close(); </span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/* Method to UPDATE salary for an employee */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateEmployee</span><span class="params">(Integer EmployeeID, <span class="keyword">int</span> salary )</span></span>&#123;</span><br><span class="line">      Session session = factory.openSession();</span><br><span class="line">      Transaction tx = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">try</span>&#123;</span><br><span class="line">         tx = session.beginTransaction();</span><br><span class="line">         Employee employee = </span><br><span class="line">                    (Employee)session.get(Employee.class, EmployeeID); </span><br><span class="line">         employee.setSalary( salary );</span><br><span class="line">         session.update(employee); </span><br><span class="line">         tx.commit();</span><br><span class="line">      &#125;<span class="keyword">catch</span> (HibernateException e) &#123;</span><br><span class="line">         <span class="keyword">if</span> (tx!=<span class="keyword">null</span>) tx.rollback();</span><br><span class="line">         e.printStackTrace(); </span><br><span class="line">      &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">         session.close(); </span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/* Method to DELETE an employee from the records */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteEmployee</span><span class="params">(Integer EmployeeID)</span></span>&#123;</span><br><span class="line">      Session session = factory.openSession();</span><br><span class="line">      Transaction tx = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">try</span>&#123;</span><br><span class="line">         tx = session.beginTransaction();</span><br><span class="line">         Employee employee = </span><br><span class="line">                   (Employee)session.get(Employee.class, EmployeeID); </span><br><span class="line">         session.delete(employee); </span><br><span class="line">         tx.commit();</span><br><span class="line">      &#125;<span class="keyword">catch</span> (HibernateException e) &#123;</span><br><span class="line">         <span class="keyword">if</span> (tx!=<span class="keyword">null</span>) tx.rollback();</span><br><span class="line">         e.printStackTrace(); </span><br><span class="line">      &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">         session.close(); </span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h1><p>MyBatis和Hibernate一样是一个持久化框架和ORM框架。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以对配置和原生Map使用简单的 XML 或注解，将接口和 Java 的 POJOs映射成数据库中的记录</p><h2 id="架构-1"><a href="#架构-1" class="headerlink" title="架构"></a>架构</h2><ol><li>API接口层：提供给外部使用的接口API，开发人员通过这些本地API来操纵数据库。接口层一接收到调用请求就会调用数据处理层来完成具体的数据处理。</li><li>数据处理层：负责具体的SQL查找、SQL解析、SQL执行和执行结果映射处理等。它主要的目的是根据调用的请求完成一次数据库操作。</li><li>基础支撑层：负责最基础的功能支撑，包括连接管理、事务管理、配置加载和缓存处理，这些都是共用的东西，将他们抽取出来作为最基础的组件。为上层的数据处理层提供最基础的支撑。</li></ol><h2 id="开发步骤-3"><a href="#开发步骤-3" class="headerlink" title="开发步骤"></a>开发步骤</h2><h3 id="准备MyBatis环境"><a href="#准备MyBatis环境" class="headerlink" title="准备MyBatis环境"></a>准备MyBatis环境</h3><p>导入Hibernate必须的jar包：导入mybatis-3.2.2.jar包</p><p>加入数据库驱动的jar包mysql-connector-java-5.1.10-bin.jar </p><h3 id="创建核心配置文件-1"><a href="#创建核心配置文件-1" class="headerlink" title="创建核心配置文件"></a>创建核心配置文件</h3><p>Mybatis需要事先知道在哪里找到映射信息。Mybatis也需要一套相关数据库和其它相关参数的配置设置。</p><p>所有这些信息通常是作为一个标准的 Java 属性文件提供的。又或者是作为 XML 文件提供的</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE configuration</span></span><br><span class="line"><span class="meta">        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"</span></span><br><span class="line"><span class="meta">        "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置开发环境，可以配置多个，在具体用时再做切换 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">"test"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">"test"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">"JDBC"</span>&gt;</span><span class="tag">&lt;/<span class="name">transactionManager</span>&gt;</span>  <span class="comment">&lt;!-- 事务管理类型：JDBC、MANAGED --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"POOLED"</span>&gt;</span>    <span class="comment">&lt;!-- 数据源类型：POOLED、UNPOOLED、JNDI --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://localhost:3306/test?characterEncoding=utf-8"</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"root"</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"root"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 加载映射文件 mapper --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 路径用 斜线（/） 分割，而不是用 点(.) --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">"yeepay/payplus/mapper/UserMapper.xml"</span>&gt;</span><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="创建持久化Java类-1"><a href="#创建持久化Java类-1" class="headerlink" title="创建持久化Java类"></a>创建持久化Java类</h3><p>遵循POJO类要求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> yeepay.payplus;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by 维C果糖 on 2017/2/2.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                <span class="string">"id="</span> + id +</span><br><span class="line">                <span class="string">", name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建对象-关系映射、定义SQL语句"><a href="#创建对象-关系映射、定义SQL语句" class="headerlink" title="创建对象-关系映射、定义SQL语句"></a>创建对象-关系映射、定义SQL语句</h3><p>MyBatis采用 XML 格式的文件来指定对象和关系数据之间的映射. MyBatis3加入了注解形式</p><h4 id="XML形式"><a href="#XML形式" class="headerlink" title="XML形式"></a>XML形式</h4><p><strong>文件中的一些属性</strong></p><p>设置 <code>namespace</code> 命名空间，目的是为了区分映射文件中的方法</p><p>结果集 <code>resultMap</code> 是 MyBatis 最大的特色，对象的 ORM 就由其来转换</p><ul><li>在结果集中，包括主键 <code>id</code> 和 普通属性 <code>result</code>；</li><li>在结果集中，常用的两个属性分别为：<code>property</code>，表示实体的属性；<code>column</code>，表示 SQL 查询的结果集的列。</li></ul><p>在映射文件中，常用的标签有四个，分别为： <code>select</code>、<code>insert</code>、<code>update</code> 和 <code>delete</code></p><ul><li>每个标签中都有 id 属性，在同一个 mapper 文件中 id 不允许重复；</li><li>参数 <code>parameterMap</code> 已经被废弃，现在其存在的目的就是为了兼容前期的项目；</li><li>参数 <code>parameterType</code> 支持很多的类型，例如 <code>int</code>、<code>Integer</code>、<code>String</code>、<code>Double</code>、<code>List</code>、<code>Map</code> 或者实体对象等；</li><li>返回值 <code>resultType</code> 用于简单的类型；</li><li>返回值 <code>resultMap</code> 用于复杂的类型；</li><li>当参数和返回值是集合的时候，其声明的是集合中的元素类型；</li><li>SQL 语句不区分大小写，它默认使用 <code>PrepareStatement</code>，预编译，可以防止 SQL 注入。</li></ul><p>获取参数的方法为 #{ 字段名 }**</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE mapper</span></span><br><span class="line"><span class="meta">        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"</span></span><br><span class="line"><span class="meta">        "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"yeepay.payplus/mapper.UserMapper"</span>&gt;</span>   <span class="comment">&lt;!-- 命名空间，名字可以随意起，只要不冲突即可 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 对象映射，可以不写 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">"yeepay.payplus.Person"</span> <span class="attr">id</span>=<span class="string">"personRM"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- property="id"，表示实体对象的属性；column="ID"，表示结果集字段 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"ID"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"Name"</span> <span class="attr">column</span>=<span class="string">"NAME"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"age"</span> <span class="attr">column</span>=<span class="string">"AGE"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 查询功能，resultType 设置返回值类型 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findAll"</span> <span class="attr">resultType</span>=<span class="string">"yeepay.payplus.Person"</span>&gt;</span>  <span class="comment">&lt;!-- 书写 SQL 语句 --&gt;</span></span><br><span class="line">        SELECT * FROM person</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 通过 ID 查询 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"get"</span> <span class="attr">parameterType</span>=<span class="string">"Integer"</span> <span class="attr">resultMap</span>=<span class="string">"personRM"</span>&gt;</span>  <span class="comment">&lt;!-- 书写 SQL 语句 --&gt;</span></span><br><span class="line">        SELECT * FROM person</span><br><span class="line">        WHERE id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 新增功能，在SQL语句中有参数，并以实体来封装参数 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"insert"</span> <span class="attr">parameterType</span>=<span class="string">"yeepay.payplus.Person"</span>&gt;</span></span><br><span class="line">        INSERT INTO person (id,name,age) VALUES (#&#123;id&#125;,#&#123;name&#125;,#&#123;age&#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 修改功能 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"update"</span> <span class="attr">parameterType</span>=<span class="string">"yeepay.payplus.Person"</span>&gt;</span></span><br><span class="line">        UPDATE person set name=#&#123;name&#125;,age=#&#123;age&#125;</span><br><span class="line">        WHERE id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 删除功能 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">"deleteById"</span> <span class="attr">parameterType</span>=<span class="string">"integer"</span>&gt;</span></span><br><span class="line">        DELETE FROM person</span><br><span class="line">        WHERE id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="定义动态SQL"><a href="#定义动态SQL" class="headerlink" title="定义动态SQL"></a>定义动态SQL</h5><p>动态SQL支持根据不同条件拼接 SQL 语句，可用标签：</p><ul><li>if</li><li>choose (when, otherwise)</li><li>trim (where, set)</li><li>foreach</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 动态SQL，parameterType 设置参数类型，resultType 设置返回值类型 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findAll"</span> <span class="attr">parameterType</span>=<span class="string">"yeepay.payplus.Person"</span> <span class="attr">resultType</span>=<span class="string">"Person"</span>&gt;</span>  </span><br><span class="line">        SELECT id,name,age FROM person</span><br><span class="line">        <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"name =! null"</span>&gt;</span></span><br><span class="line">                name = #&#123;name&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"age =! null"</span>&gt;</span></span><br><span class="line">                and age = #&#123;age&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">&lt;!-- 批量删除，Map 类型 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">"deleteMap"</span> <span class="attr">parameterType</span>=<span class="string">"Map"</span>&gt;</span></span><br><span class="line">        DELETE FROM person WHERE id IN</span><br><span class="line">        <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">"ids"</span> <span class="attr">item</span>=<span class="string">"id"</span> <span class="attr">open</span>=<span class="string">"("</span> <span class="attr">close</span>=<span class="string">")"</span> <span class="attr">separator</span>=<span class="string">","</span>&gt;</span></span><br><span class="line">            #&#123;id&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">        AND  age = #&#123;age&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 批量删除，List 类型 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">"deleteList"</span> <span class="attr">parameterType</span>=<span class="string">"integer"</span>&gt;</span></span><br><span class="line">        DELETE FROM person WHERE id IN</span><br><span class="line">        <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">"list"</span> <span class="attr">item</span>=<span class="string">"id"</span> <span class="attr">open</span>=<span class="string">"("</span> <span class="attr">close</span>=<span class="string">")"</span> <span class="attr">separator</span>=<span class="string">","</span>&gt;</span></span><br><span class="line">            #&#123;id&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="1-N映射关系定义"><a href="#1-N映射关系定义" class="headerlink" title="1:N映射关系定义"></a>1:N映射关系定义</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置关联关系 1:N --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">"yeepay.payplus.domain.Customer"</span> <span class="attr">id</span>=<span class="string">"customerOrdersRM"</span> <span class="attr">extends</span>=<span class="string">"customerRM"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置多的（N），property 属性就是实体中的 List 对象属性名称，ofType 属性就是集合元素的类型 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">"orders"</span> <span class="attr">ofType</span>=<span class="string">"yeepay.payplus.domain.Orders"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"ID"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"sn"</span> <span class="attr">column</span>=<span class="string">"SN"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"remark"</span> <span class="attr">column</span>=<span class="string">"REMARK"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="注解形式"><a href="#注解形式" class="headerlink" title="注解形式"></a>注解形式</h4><p>因为最初设计时,MyBatis 是一个 XML 驱动的框架。配置信息是基于 XML 的,而且 映射语句也是定义在 XML 中的。而到了 MyBatis 3,有新的可用的选择了。MyBatis 3 构建 在基于全面而且强大的 Java 配置 API 之上。这个配置 API 是基于 XML 的 MyBatis 配置的 基础,也是新的基于注解配置的基础。注解提供了一种简单的方式来实现简单映射语句,而 不会引入大量的开销。</p><p>注意 不幸的是,Java 注解限制了它们的表现和灵活。尽管很多时间都花调查,设计和 实验上,最强大的 MyBatis 映射不能用注解来构建,那并不可笑。C#属性(做示例)就没 有这些限制,因此 MyBatis.NET 将会比 XML 有更丰富的选择。也就是说,基于 Java 注解 的配置离不开它的特性。</p><p><strong>注解有下面这些:</strong></p><div class="table-container"><table><thead><tr><th>注解</th><th>目标</th><th>相对应的 XML</th></tr></thead><tbody><tr><td><code>@CacheNamespace</code></td><td><code>class</code></td><td></td></tr><tr><td><code>@CacheNamespaceRef</code></td><td><code>class</code></td><td></td></tr><tr><td><code>@ConstructorArgs</code></td><td><code>Method</code></td><td></td></tr><tr><td><code>@Arg</code></td><td><code>Method</code></td><td></td></tr><tr><td><code>@TypeDiscriminator</code></td><td><code>Method</code></td><td></td></tr><tr><td><code>@Case</code></td><td><code>Method</code></td><td></td></tr><tr><td><code>@Results</code></td><td><code>Method</code></td><td></td></tr><tr><td><code>@Result</code></td><td><code>Method</code></td><td></td></tr><tr><td><code>@One</code></td><td><code>Method</code></td><td></td></tr><tr><td><code>@Many</code></td><td><code>Method</code></td><td></td></tr><tr><td><code>@MapKey</code></td><td><code>Method</code></td><td></td></tr><tr><td><code>@Options</code></td><td><code>Method</code></td><td></td></tr><tr><td><code>@Insert</code>,<code>@Update</code>, <code>@Delete</code>, <code>@Select</code></td><td><code>Method</code></td><td><code>&lt;insert&gt;</code>,<code>&lt;update&gt;</code>,<code>&lt;delete&gt;</code>,<code>&lt;select&gt;</code></td></tr><tr><td><code>@InsertProvider,@UpdateProvider,@DeleteProvider,@SelectProvider</code></td><td><code>Method</code></td><td><code>&lt;insert&gt;</code>,<code>&lt;update&gt;</code>,<code>&lt;delete&gt;</code>,<code>&lt;select&gt;</code></td></tr><tr><td><code>@Param</code></td><td><code>Parameter</code></td><td></td></tr><tr><td><code>@SelectKey</code></td><td><code>Method</code></td><td><code>&lt;selectKey&gt;</code></td></tr><tr><td><code>@ResultMap</code></td><td><code>Method</code></td><td></td></tr><tr><td><code>@ResultType</code></td><td><code>Method</code></td><td>N</td></tr></tbody></table></div><h5 id="映射注解申明sql样例"><a href="#映射注解申明sql样例" class="headerlink" title="映射注解申明sql样例"></a>映射注解申明sql样例</h5><p>这些函数名相当于XML中的id</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ClusterMessageMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Insert</span></span><br><span class="line">    <span class="meta">@Insert</span>(<span class="string">"insert into cluster_manager(cluster_name, cluster_time, cluster_address, cluster_access_user, cluster_access_passwd) "</span> +</span><br><span class="line">            <span class="string">"values(#&#123;clusterName&#125;, #&#123;clusterTime&#125;, #&#123;clusterAddress&#125;, #&#123;clusterAccessUser&#125;, #&#123;clusterAccessPasswd&#125;)"</span>)</span><br><span class="line">    <span class="meta">@Options</span>(useGeneratedKeys = <span class="keyword">true</span>, keyColumn = <span class="string">"cluster_id"</span>, keyProperty = <span class="string">"clusterId"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertClusterMessage</span><span class="params">(ClusterMessage clusterMessage)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// select</span></span><br><span class="line">    <span class="meta">@Select</span>(<span class="string">"select * from cluster_manager"</span>)</span><br><span class="line">    <span class="meta">@Results</span>(</span><br><span class="line">            id = <span class="string">"clusterMessage"</span>,</span><br><span class="line">            value = &#123;</span><br><span class="line">                    <span class="meta">@Result</span>(column = <span class="string">"cluster_name"</span>, property = <span class="string">"clusterName"</span>, javaType = String.class, jdbcType = JdbcType.VARCHAR),</span><br><span class="line">                    <span class="meta">@Result</span>(column = <span class="string">"cluster_time"</span>, property = <span class="string">"clusterTime"</span>, javaType = Long.class, jdbcType = JdbcType.BIGINT),</span><br><span class="line">                    <span class="meta">@Result</span>(column = <span class="string">"cluster_address"</span>, property = <span class="string">"clusterAddress"</span>, javaType = String.class, jdbcType = JdbcType.VARCHAR),</span><br><span class="line">                    <span class="meta">@Result</span>(column = <span class="string">"cluster_access_user"</span>, property = <span class="string">"clusterAccessUser"</span>, javaType = String.class, jdbcType = JdbcType.VARCHAR),</span><br><span class="line">                    <span class="meta">@Result</span>(column = <span class="string">"cluster_access_passwd"</span>, property = <span class="string">"clusterAccessPasswd"</span>, javaType = String.class, jdbcType = JdbcType.VARCHAR)</span><br><span class="line">            &#125;</span><br><span class="line">    )</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;ClusterMessage&gt; <span class="title">getClusterMessage</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select</span>(<span class="string">"select * from cluster_manager"</span>)</span><br><span class="line">    <span class="meta">@MapKey</span>(<span class="string">"clusterId"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;Integer, ClusterMessage&gt; <span class="title">getClusterMessageMapper</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select</span>(<span class="string">"select * from cluster_manager where cluster_id=#&#123;clusterId&#125;"</span>)</span><br><span class="line">    <span class="meta">@ResultMap</span>(<span class="string">"clusterMessage"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ClusterMessage <span class="title">getClusterMessageById</span><span class="params">(@Param(<span class="string">"clusterId"</span>)</span> <span class="keyword">int</span> clusterId)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// update</span></span><br><span class="line">    <span class="meta">@Update</span>(<span class="string">"update cluster_manager set cluster_name=#&#123;clusterName&#125; where cluster_id=#&#123;clusterId&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateClusterMessage</span><span class="params">(ClusterMessage clusterMessage)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// delete</span></span><br><span class="line">    <span class="meta">@Delete</span>(<span class="string">"delete from cluster_manager where cluster_id=#&#123;clusterId&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteClusterMessage</span><span class="params">(@Param(<span class="string">"clusterId"</span>)</span><span class="keyword">int</span> clusterId)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="调用定义的SQL"><a href="#调用定义的SQL" class="headerlink" title="调用定义的SQL"></a>调用定义的SQL</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、获得 SqlSessionFactory</span></span><br><span class="line">String resource = <span class="string">"sqlMapConfig.xml"</span>;           <span class="comment">// 定位核心配置文件</span></span><br><span class="line">InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、获得 SqlSession</span></span><br><span class="line">SqlSession sqlSession = sqlSessionFactory.openSession();   </span><br><span class="line"></span><br><span class="line"><span class="comment">// 3、调用在 mapper 文件中配置的 SQL 语句</span></span><br><span class="line">List&lt;Person&gt; personList = sqlSession.selectList(<span class="string">"yeepay.payplus/mapper.UserMapper.findAll"</span>);</span><br><span class="line">Person p = sqlSession.selectOne(<span class="string">"yeepay.payplus.mapper.UserMapper.get"</span>, <span class="number">2</span>);</span><br><span class="line">sqlSession.insert(<span class="string">"yeepay.payplus.mapper.UserMapper.insert"</span>, p);</span><br><span class="line">sqlSession.insert(<span class="string">"yeepay.payplus.mapper.UserMapper.update"</span>, p);</span><br><span class="line">sqlSession.delete(<span class="string">"yeepay.payplus.mapper.UserMapper.deleteById"</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><h1 id="MyBatis-plus"><a href="#MyBatis-plus" class="headerlink" title="MyBatis-plus"></a>MyBatis-plus</h1><p>虽然mybatis可以直接在xml中通过SQL语句操作数据库，很是灵活。但正其操作都要通过SQL语句进行，就必须写大量的xml文件，很是麻烦。mybatis-plus就很好的解决了这个问题。</p><p>Mybatis-Plus（简称MP）是一个 Mybatis 的增强工具，在 Mybatis 的基础上只做增强不做改变，为简化开发、提高效率而生。其实就是它已经封装好了一些crud方法，我们不需要再写xml了，直接调用这些方法就行，就类似于JPA</p><h2 id="架构-2"><a href="#架构-2" class="headerlink" title="架构"></a>架构</h2><p><img alt="架构" data-src="//orangesching.github.io/2020/08/25/Java/JavaWeb/JAVA与数据库/JAVA与数据库综述/JAVA操作关系型数据库/mybatis-plus-framework.jpg" class="lazyload"></p><p><img alt="架构细节" data-src="//orangesching.github.io/2020/08/25/Java/JavaWeb/JAVA与数据库/JAVA与数据库综述/JAVA操作关系型数据库/mybatis-plus-framework-detail.jpg" class="lazyload"></p><h2 id="开发步骤-4"><a href="#开发步骤-4" class="headerlink" title="开发步骤"></a>开发步骤</h2><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>在 <code>application.yml</code> 配置文件中添加 H2 数据库的相关配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># DataSource Config</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  datasource:</span></span><br><span class="line"><span class="attr">    driver-class-name:</span> <span class="string">org.h2.Driver</span></span><br><span class="line"><span class="attr">    schema:</span> <span class="attr">classpath:db/schema-h2.sql</span></span><br><span class="line"><span class="attr">    data:</span> <span class="attr">classpath:db/data-h2.sql</span></span><br><span class="line"><span class="attr">    url:</span> <span class="attr">jdbc:h2:mem:test</span></span><br><span class="line"><span class="attr">    username:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">    password:</span> <span class="string">test</span></span><br></pre></td></tr></table></figure><p>在 Spring Boot 启动类中添加 <code>@MapperScan</code> 注解，扫描 Mapper 文件夹：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@MapperScan</span>(<span class="string">"com.baomidou.mybatisplus.samples.quickstart.mapper"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(QuickStartApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建实体类"><a href="#创建实体类" class="headerlink" title="创建实体类"></a>创建实体类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建Mapper类或Service类"><a href="#创建Mapper类或Service类" class="headerlink" title="创建Mapper类或Service类"></a>创建Mapper类或Service类</h3><h4 id="Mapper类"><a href="#Mapper类" class="headerlink" title="Mapper类"></a>Mapper类</h4><p>创建Mapper类继承BaseMapper类，BaseMapper类是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> <span class="keyword">extends</span> <span class="title">BaseMapper</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>通用 CRUD 封装<code>BaseMapper</code>接口，为 <code>Mybatis-Plus</code> 启动时自动解析实体表关系映射转换为 <code>Mybatis</code> 内部对象注入容器</li><li>泛型 <code>T</code> 为任意实体对象</li><li>参数 <code>Serializable</code> 为任意类型主键 <code>Mybatis-Plus</code> 不推荐使用复合主键约定每一张表都有自己的唯一 <code>id</code> 主键</li><li>对象 <code>Wrapper</code> 为条件构造器</li></ul></blockquote><h4 id="Service类"><a href="#Service类" class="headerlink" title="Service类"></a>Service类</h4><p>创建Service接口继承IService接口，创建Service类继承ServiceImpl类和Service接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.service.IService;</span><br><span class="line"><span class="keyword">import</span> com.tp.mybatisplusstudy.vo.User;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IUserService</span> <span class="keyword">extends</span> <span class="title">IService</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;</span><br><span class="line"><span class="keyword">import</span> com.tp.mybatisplusstudy.dao.UserMapper;</span><br><span class="line"><span class="keyword">import</span> com.tp.mybatisplusstudy.service.IUserService;</span><br><span class="line"><span class="keyword">import</span> com.tp.mybatisplusstudy.vo.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">extends</span> <span class="title">ServiceImpl</span>&lt;<span class="title">UserMapper</span>, <span class="title">User</span>&gt; <span class="keyword">implements</span> <span class="title">IUserService</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>说明:</p><ul><li>通用 Service CRUD 封装<code>IService</code>接口，进一步封装 CRUD 采用 <code>get 查询单行</code> <code>remove 删除</code> <code>list 查询集合</code> <code>page 分页</code> 前缀命名方式区分 <code>Mapper</code> 层避免混淆，</li><li>泛型 <code>T</code> 为任意实体对象</li><li>建议如果存在自定义通用 Service 方法的可能，请创建自己的 <code>IBaseService</code> 继承 <code>Mybatis-Plus</code> 提供的基类</li><li>对象 <code>Wrapper</code> 为条件构造器</li></ul></blockquote><h3 id="调用函数操纵数据库"><a href="#调用函数操纵数据库" class="headerlink" title="调用函数操纵数据库"></a>调用函数操纵数据库</h3><div class="table-container"><table><thead><tr><th>Service CRUD 接口</th><th>Mapper CRUD 接口</th></tr></thead><tbody><tr><td>Save<br>SaveOrUpdate<br>Remove<br>Update<br>Get<br>List<br>Page<br>Count<br>Chain</td><td>Insert<br>Delete<br>Update<br>Select</td></tr></tbody></table></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSelect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println((<span class="string">"----- selectAll method test ------"</span>));</span><br><span class="line">        List&lt;User&gt; userList = userMapper.selectList(<span class="keyword">null</span>);    <span class="comment">// 使用了Mapper接口</span></span><br><span class="line">        Assert.assertEquals(<span class="number">5</span>, userList.size());</span><br><span class="line">        userList.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考：</p><p><a href="https://www.cnblogs.com/dongguangming/p/12742533.html" target="_blank" rel="noopener">https://www.cnblogs.com/dongguangming/p/12742533.html</a></p><p><a href="https://blog.csdn.net/lonelymanontheway/article/details/83339837" target="_blank" rel="noopener">https://blog.csdn.net/lonelymanontheway/article/details/83339837</a></p><p><a href="https://blog.csdn.net/binqijiang9465/article/details/106993191/" target="_blank" rel="noopener">https://blog.csdn.net/binqijiang9465/article/details/106993191/</a></p>]]></content>
      
      
      <categories>
          
          <category> JavaWeb </category>
          
          <category> JAVA与数据库 </category>
          
          <category> JAVA与数据库综述 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JDBC </tag>
            
            <tag> Hibernate </tag>
            
            <tag> MyBatis </tag>
            
            <tag> MyBatis-plus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一些小工具</title>
      <link href="/2020/08/24/%E5%85%B6%E4%BB%96/%E4%B8%80%E4%BA%9B%E5%B0%8F%E5%B7%A5%E5%85%B7/"/>
      <url>/2020/08/24/%E5%85%B6%E4%BB%96/%E4%B8%80%E4%BA%9B%E5%B0%8F%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h1 id="Liquibase"><a href="#Liquibase" class="headerlink" title="Liquibase"></a>Liquibase</h1><p>Liquibase 是一个用于跟踪，管理和应用数据库变化的开源的数据库重构工具。它将所有数据库的变化都保存在XML文件中，包括对数据库的改变，以及数据库的版本信息，方便数据的升级和回滚等操作。</p><h2 id="Liquibase是如何工作的"><a href="#Liquibase是如何工作的" class="headerlink" title="Liquibase是如何工作的"></a>Liquibase是如何工作的</h2><p>Liquibase的核心是依靠一种简单的机制来跟踪、版本和部署更改：</p><ul><li><p>Liquibase使用更改日志（是更改的分类）按特定顺序显式列出数据库更改。更改日志中的每个更改都是一个<code>change set</code>。更改日志可以任意嵌套，以帮助组织和管理数据库迁移。</p><p>  注意： 最佳做法是确保每个<code>change set</code>都尽可能原子性更改，以避免失败的结果使数据库中剩下的未处理的语句处于unknown 状态;不过，可以将大型 <code>SQL</code> 脚本视为单个更改集。</p></li><li><p>Liquibase 使用跟踪表（具体称为<code>DATABASECHANGELOG</code> ），该表位于每个数据库上，并跟踪已部署更改日志中的<code>change set</code><br>  注意：如果 Liquibase所在的数据库没有跟踪表，Liquibase将创建一个跟踪表。<br>  注意：为了协助处理您未从空白数据库开始的项目，Liquibase具有生成一条更改日志以表示数据库模式当前状态的功能。</p><blockquote><p>查看数据库可以除了自己创建的表外，还有另外两个表：<code>databasechangeloglock</code>和<code>databasechangeloglock</code>。<code>databasechangelog</code>表包含针对数据库运行的所有更改的列表。<code>databasechangeloglock</code>表用于确保两台计算机不会同时尝试修改数据库。</p></blockquote></li></ul><p>使用分类和跟踪表，Liquibase能够：</p><ul><li><p>跟踪和以版本控制数据库更改 – 用户确切知道已部署到数据库的更改以及尚未部署的更改。</p></li><li><p>部署更改 — 具体来说，通过将分类(<code>ledger</code>)中的内容与跟踪表中的内容进行比较，  Liquibase只能将以前尚未部署到数据库的更改部署到数据库中。</p><p>注意：Liquibase具有上下文、标签和先决条件等高级功能，可精确控制<code>changeSet</code>的部署时间以及位置。</p></li></ul><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>使用 <code>Liquibase</code>时，可以使用 <a href="https://www.liquibase.org/quickstart.html#simpleSQL" target="_blank" rel="noopener">Liquibase 函数</a>或 <a href="https://www.liquibase.org/quickstart.html#lbmodel" target="_blank" rel="noopener">SQL</a> 定义更改。重要的是，这些模式不是互斥的，可以结合使用</p><p><a href="https://docs.liquibase.com/commands/home.html" target="_blank" rel="noopener">手册地址</a></p><h3 id="Change-Log"><a href="#Change-Log" class="headerlink" title="Change Log"></a>Change Log</h3><p>这是一次性步骤，用于配置更改日志以指向将包含 <code>SQL</code> 脚本的 <code>sql</code> 文件夹。在解压的<code>*.zip</code> 或<code>*.tar.gz</code>的 <code>Liquibase</code> 的目录中创建并保存文件名为 <code>myChangeLog.xml</code> 的文件 。<code>myChangeLog.xml</code> 的内容应如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">databaseChangeLog</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns</span>=<span class="string">"http://www.liquibase.org/xml/ns/dbchangelog"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.liquibase.org/xml/ns/dbchangelog</span></span></span><br><span class="line"><span class="tag"><span class="string">         http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-3.1.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">includeAll</span> <span class="attr">path</span>=<span class="string">"/sql"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">databaseChangeLog</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="ChangeSet"><a href="#ChangeSet" class="headerlink" title="ChangeSet"></a>ChangeSet</h3><p>每个<code>changeSet</code>都由<code>id</code>属性和<code>author</code>属性进行唯一标识。这两个标记以及更改日志文件的名称和包唯一地标识了更改。如果只需要指定一个<code>id</code>，则很容易意外重用它们，尤其是在处理多个开发人员和代码分支时。包括<code>author</code>属性可最大程度地减少重复的可能性。</p><p>将每个<code>changeSet</code>视为要应用于数据库的原子更改。通常最好在<code>changeSet</code>中只包含一个更改，但如果插入多个行时，这些行一起有作为单个事务添加的意义，则允许进行更多更改。<code>Liquibase</code> 将尝试将每个<code>changeSet</code>运行为单个事务，但对于某些命令，许多数据库将静默地提交和回滚事务（创建表、删除表等）。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">databaseChangeLog</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns</span>=<span class="string">"http://www.liquibase.org/xml/ns/dbchangelog"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.liquibase.org/xml/ns/dbchangelog</span></span></span><br><span class="line"><span class="tag"><span class="string">         http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-3.1.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">changeSet</span> <span class="attr">id</span>=<span class="string">"1"</span> <span class="attr">author</span>=<span class="string">"bob"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">createTable</span> <span class="attr">tableName</span>=<span class="string">"department"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">type</span>=<span class="string">"int"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">constraints</span> <span class="attr">primaryKey</span>=<span class="string">"true"</span> <span class="attr">nullable</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">column</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">type</span>=<span class="string">"varchar(50)"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">constraints</span> <span class="attr">nullable</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">column</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"active"</span> <span class="attr">type</span>=<span class="string">"boolean"</span> <span class="attr">defaultValueBoolean</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">createTable</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">changeSet</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">databaseChangeLog</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="Lombok"><a href="#Lombok" class="headerlink" title="Lombok"></a>Lombok</h1>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Liquibase </tag>
            
            <tag> Lombok </tag>
            
            <tag> 小工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一些小工具</title>
      <link href="/2020/08/24/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E4%B8%8E%E7%AE%A1%E7%90%86/ECS%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/"/>
      <url>/2020/08/24/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E4%B8%8E%E7%AE%A1%E7%90%86/ECS%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<p>安装一览：</p><ol><li><p>安装rc、rz</p><p>使用 yum provides */rz 这条命令，查看系统自带的软件包信息</p><p>在输出的信息中，可以看出 rz包的路径，说明 rz包是存在的。<br>确认 rz 包存在之后，使用命令 yum -y install lrzsz 进行包的安装，如图：</p></li><li><p>git</p></li><li><p>JDK</p></li><li><p>Tomcat</p></li><li><p>nginx</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 服务器配置与管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境安装 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一些小工具</title>
      <link href="/2020/08/24/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E4%B8%8E%E7%AE%A1%E7%90%86/Linux%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
      <url>/2020/08/24/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E4%B8%8E%E7%AE%A1%E7%90%86/Linux%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>Linux有很多种发行版本，各种发行版本之间安装软件方式和命令不一样，同一个版本之间安装软件也有不同的方法。但是，大体来说，Linux有两大派系，一个是红帽派系，包含Redhat、Centos、Fedora等。还有一个是Debian派系，包含Kali、Ubuntu等。</p><p><img alt="img" data-src="//orangesching.github.io/2020/08/24/服务器配置与管理/Linux安装软件的几种方式/20191011102551327.png" class="lazyload"></p><h1 id="红帽派"><a href="#红帽派" class="headerlink" title="红帽派"></a>红帽派</h1><h2 id="源码包安装"><a href="#源码包安装" class="headerlink" title="源码包安装"></a>源码包安装</h2><h3 id="源码包安装步骤"><a href="#源码包安装步骤" class="headerlink" title="源码包安装步骤"></a>源码包安装步骤</h3><ol><li>下载源代码安装包文件</li><li>tar报解压缩：解压并释放源代码包到指定的目录</li><li><code>./configure</code>配置：设置安装目录、安装模块等选项</li><li><code>make</code>编译：生成可执行的二进制文件Makefile</li><li><code>make install</code>安装：复制二进制文件到系统、配置应用环境</li><li>配置并使用软件</li></ol><h3 id="源码安装需要安装编译工具"><a href="#源码安装需要安装编译工具" class="headerlink" title="源码安装需要安装编译工具"></a>源码安装需要安装编译工具</h3><p><code>yum -y install gcc gcc-c++ make</code></p><h3 id="步骤详解"><a href="#步骤详解" class="headerlink" title="步骤详解"></a>步骤详解</h3><ul><li><code>./configure</code>是用来检测你的安装平台的目标特征的。比如它会检测你是不是有CC或GCC，并不是需要CC或GCC，它是个shell脚本，一般用来生成<code>Makefile</code></li><li><code>make</code>是用来编译的，它从<code>Makefile</code>中读取指令，然后编译</li><li><code>make install</code>是用来安装的，它也从<code>Makefile</code>中读取指令，安装到指定的位置</li></ul><h4 id="configure"><a href="#configure" class="headerlink" title="configure"></a>configure</h4><p>这一步一般用来生成 Makefile，为下一步的编译做准备，你可以通过在 configure 后加上参数来对安装进行控制，比如代码:  ./configure —prefix=/usr 上面的意思是将该软件安装在 /usr 下面，执行文件就会安装在 /usr/bin.同时一些软件的配置文件你可以通过指定 —sys-config= 参数进行设定。有一些软件还可以加上 —with、—enable、—without、—disable 等等参数对编译加以控制，你可以通过允许 ./configure —help 察看详细的说明帮助。</p><h4 id="make"><a href="#make" class="headerlink" title="make"></a>make</h4><p>这一步就是编译，大多数的源代码包都经过这一步进行编译（当然有些perl或Python编写的软件需要调用perl或python来进行编译）。如果 在 make 过程中出现 error ，你就要记下错误代码（注意不仅仅是最后一行），然后你可以向开发者提交 bugreport（一般在 INSTALL 里有提交地址），或者你的系统少了一些依赖库等，这些需要自己仔细研究错误代码。make 的作用是开始进行源代码编译，以及一些功能的提供，这些功能由他的 Makefile 设置文件提供相关的功能，<br>make 是 Linux 开发套件里面自动化编译的一个控制程序，他通过借助 Makefile 里面编写的编译规范进行自动化的调用 gcc 、ld 以及运行某些需要的程序进行编译的程序。一般情况下，他所使用的 Makefile 控制代码，由 configure 这个设置脚本根据给定的参数和系统环境生成。</p><h4 id="make-install"><a href="#make-install" class="headerlink" title="make install"></a>make install</h4><p>这条命令来进行安装（当然有些软件需要先运行 make check 或 make test来进行一些测试），这一步一般需要你有 root 权限（因为要向系统写入文件）。 <code>make install</code> 一般表示进行安装，<code>make uninstall</code> 是卸载。</p><h2 id="rpm包安装"><a href="#rpm包安装" class="headerlink" title="rpm包安装"></a>rpm包安装</h2><p><code>RPM (RedHat Package Manager)</code>：由红帽公司提出，建议统一的数据库文件，详细记录软件包的安装、卸载等变化信息，能够自动分析软件包依赖关系</p><p>RPM包的命名格式： firefox-17.0.10-1.el6.centos.x86_64.rpm<br>                                软件名称 版本号发行次数 硬件平台扩展名</p><p>rpm指令管理<br>  针对已安装软件</p><pre><code>rpm -qa：查询所有已安装软件的rpm包信息，列出包的版本rpm  -q httpd： 查看 httpd 是否安装rpm -qi  httpd：列出 httpd 软件的详细信息rpm -qc httpd：查看 httpd 的配置文件目录rpm  -ql  httpd：查看 httpd 所包含的文件whereis  httpd：查看httpd的安装路径和可执行文件路径根据指令搜索包的名称 which vim：搜索指令在系统中的路径rpm -qf   指令的绝对路径 ： 查看该命令是由哪个rpm包所提供  rqm -qf  /usr/bin/vim</code></pre><p>  针对未安装软件(需要把光盘文件挂载，然后进入其Package目录下  </p><pre><code>rpm -qpl 包.rpm  选项p表示package，后面需要写包的完整路径信息，qpl表示列出这个包在安装之后生成哪些文件和目录rpm -qpi 包.rpm  查询未安装包的详细信息</code></pre><p>验证软件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">V：后面接软件名称，该软件所含的文件被改动过，才会被列出来。针对一个软件查询。 </span><br><span class="line">Va：列出系统上面所有有可能被改动过的文件。针对真个系统的。 </span><br><span class="line">Vp：后面接RPM软件包。 </span><br><span class="line">Vf：列出某个文件是否被改动过。</span><br></pre></td></tr></table></figure><p>对于输出中每个标记的含义介绍如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">S 表示文件长度发生了变化</span><br><span class="line">M 表示文件的访问权限或文件类型发生了变化</span><br><span class="line">5 表示MD5校验和发生了变化</span><br><span class="line">D 表示设备节点的属性发生了变化</span><br><span class="line">L 表示文件的符号链接发生了变化</span><br><span class="line">U 表示文件/子目录/设备节点的owner发生了变化</span><br><span class="line">G 表示文件/子目录/设备节点的group发生了变化</span><br><span class="line">T 表示文件最后一次的修改时间发生了变化</span><br></pre></td></tr></table></figure><p>如果在输出结果中有“M”标记出现，那么对应的文件可能已经遭到篡改或替换，此时可以通过卸载这个rpm包重新安装来清除受攻击的文件。</p><p>不过这个命令有个局限性，那就是只能检查通过rpm包方式安装的所有文件，对于通过非rpm包方式安装的文件就无能为力了。同时，如果rpm工具也遭到替换，就不能通过这个方法了，此时可以从正常的系统上复制一个rpm工具进行检测。</p><p>对文件系统的检查也可以通过chkrootkit、RKHunter这两个工具来完成。</p><p>  安装与卸载</p><pre><code>rpm  -ivh  包.rpm        i表示安装，v表示显示安装过程，h表示以‘#’作为进度，显示安装进度rpm  -e  包的名称         移除指定的rpm包</code></pre><h2 id="yum源安装"><a href="#yum源安装" class="headerlink" title="yum源安装"></a>yum源安装</h2><p><code>YUM(Yellow dog  Updater Modified)</code>: <strong>基于RPM包</strong>构建的软件更新机制，可以自动解决rpm包之间的依赖关系，所有软件包由集中的yum软件仓库提供</p><p>相关文章：<a href="https://blog.csdn.net/qq_36119192/article/details/82222175" target="_blank" rel="noopener">Redhat7配置yum源(本地源和网络源)</a><br>一些常见的yum命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">yum  clean all                           清空缓存信息</span><br><span class="line">yum  list                                   列出所有包的信息</span><br><span class="line">yum  list  httpd                         查看 httpd 是否安装</span><br><span class="line">yum  info httpd                        显示 httpd 包的详细具体信息</span><br><span class="line">yum install httpd   -y               安装 httpd 包</span><br><span class="line">yum remove httpd  -y               卸载 httpd 包</span><br><span class="line">yum search 关键词                 根据关键词，在已发现的repo源中搜索包含关键词的rpm包</span><br><span class="line">yum provides 命令                   根据命令，在已发现的repo源中搜索安装指令的rpm包</span><br><span class="line">yum history  list/info/undo/redo number             history可以列出，查看，重装，反安装对应的包，但是是以yum指令的操作顺序为依据的，所以需要加指定的数字执行</span><br><span class="line">yum update -y                        升级所有包同时也升级软件和系统内核</span><br><span class="line">yum upgrade  -y                     只升级所有包，不升级软件和系统内核</span><br></pre></td></tr></table></figure><h1 id="Debian派"><a href="#Debian派" class="headerlink" title="Debian派"></a>Debian派</h1><h2 id="Deb包安装"><a href="#Deb包安装" class="headerlink" title="Deb包安装"></a>Deb包安装</h2><p>DEB是Debian软件包格式的文件扩展名，Debian包是Unixar的标准归档，将包文件信息以及包内容，经过gzip和tar打包而成。<br>处理这些包的经典程序是dpkg，经常是通过Debian的apt-get来运作。deb 格式是 Debian 系统(包含 Debian 和 Ubuntu )专属安装包格式，配合 APT 软件管理系统，成为了当前在 Linux 下非常流行的一种安装包</p><p>dpkg指令用法：</p><pre><code>-i：安装软件包；-r：删除软件包；-P：删除软件包的同时删除其配置文件；-L：显示于软件包关联的文件；-l：显示已安装软件包列表；--unpack：解开软件包；-c：显示软件包内文件列表；--confiugre：配置软件包。</code></pre><h2 id="apt-get源安装"><a href="#apt-get源安装" class="headerlink" title="apt-get源安装"></a>apt-get源安装</h2><p>1.Ubuntu中的高级包管理方法apt-get</p><p>除了apt的便捷以外，apt-get的一大好处是<strong>极大地减小了所谓依赖关系恶梦的发生几率(dependency hell)</strong>，即使是陷入了dependency hell，apt-get也提供了很好的援助手段，帮你逃出魔窟。<br>通常 apt-get 都和网上的压缩包一起出没，从互联网上下载或是安装。全世界有超过200个 debian官方镜像，还有繁多的非官方软件包提供网站。你所使用的基于Debian的发布版不同，你所使用的软件仓库可能需要手工选择或是可以自动设置。你能从Debian官方网站得到完整的镜像列表。而很多非官方网站提供各种特殊用途的非官方软件包，当然，使用非官方软件包会有更多风险了。<br>软件包都是为某一个基本的Debian发布版所准备的(从unstable 到stable)，并且划分到不同类别中(如 main contrib nonfree)，这个是依据 debian 自由软件纲领而划分的(也就是常说的dfsg)，因为美国限制加密软件出口，还有一个non-us类别。 </p><p>2.常用的APT命令参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">apt-cache search package    搜索包 </span><br><span class="line">apt-cache show package      获取包的相关信息，如说明、大小、版本等 </span><br><span class="line">sudo apt-get install httpd      安装软件</span><br><span class="line">sudo apt-get install package -- reinstall  重新安装包 </span><br><span class="line">sudo apt-get -f install      修复安装&quot;-f = --fix-missing&quot; </span><br><span class="line">sudo apt-get remove httpd    卸载软件</span><br><span class="line">sudo apt-get remove package -- purge  删除包，包括删除配置文件等 </span><br><span class="line">sudo apt-get update   更新源 </span><br><span class="line">sudo apt-get upgrade  更新已安装的包 </span><br><span class="line">sudo apt-get dist-upgrade  升级系统 </span><br><span class="line">sudo apt-get dselect-upgrade  使用 dselect 升级 </span><br><span class="line">apt-cache depends package  了解使用依赖 </span><br><span class="line">apt-cache rdepends package  是查看该包被哪些包依赖 </span><br><span class="line">sudo apt-get build-dep package  安装相关的编译环境 </span><br><span class="line">apt-get source package  下载该包的源代码 </span><br><span class="line">sudo apt-get clean &amp;&amp; sudo apt-get autoclean  清理无用的包 </span><br><span class="line">sudo apt-get check  检查是否有损坏的依赖</span><br></pre></td></tr></table></figure><p>原文链接：<a href="https://blog.csdn.net/qq_36119192/article/details/82866329" target="_blank" rel="noopener">https://blog.csdn.net/qq_36119192/article/details/82866329</a></p>]]></content>
      
      
      <categories>
          
          <category> 服务器配置与管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境安装 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>各种缓存概述</title>
      <link href="/2020/08/24/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E4%B8%8E%E7%AE%A1%E7%90%86/Web%E6%8A%80%E6%9C%AF/%E5%90%84%E7%A7%8D%E7%BC%93%E5%AD%98%E6%A6%82%E8%BF%B0/"/>
      <url>/2020/08/24/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E4%B8%8E%E7%AE%A1%E7%90%86/Web%E6%8A%80%E6%9C%AF/%E5%90%84%E7%A7%8D%E7%BC%93%E5%AD%98%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="缓存概述"><a href="#缓存概述" class="headerlink" title="缓存概述"></a>缓存概述</h1><h2 id="缓存的目的"><a href="#缓存的目的" class="headerlink" title="缓存的目的"></a>缓存的目的</h2><p>加速请求时间：请求时间=</p><h2 id="缓存的原理"><a href="#缓存的原理" class="headerlink" title="缓存的原理"></a>缓存的原理</h2><p>将数据写入/读取速度更快的存储（设备）；</p><p>将数据缓存到离应用最近的位置；</p><p>将数据缓存到离用户最近的位置。</p><p><strong>2**</strong>、缓存分类**</p><p>在分布式系统中，缓存的应用非常广泛，从部署角度有以下几个方面的缓存应用。</p><p>CDN缓存；</p><p>反向代理缓存；</p><p>分布式Cache；</p><p>本地应用缓存；</p><p><strong>3**</strong>、缓存媒介**</p><p>常用中间件：Varnish，Ngnix，Squid，Memcache，Redis，Ehcache等；</p><p>缓存的内容：文件，数据，对象；</p><p>缓存的介质：CPU，内存（本地，分布式），磁盘（本地，分布式）</p><p><strong>4**</strong>、缓存设计**</p><p>缓存设计需要解决以下几个问题：</p><p>缓存什么？</p><p>哪些数据需要缓存：1.热点数据；2.静态资源。</p><p>缓存的位置？</p><p>CDN，反向代理，分布式缓存服务器，本机（内存，硬盘）</p><p>如何缓存的问题？</p><p>过期策略</p><p>固定时间：比如指定缓存的时间是30分钟；</p><p>相对时间：比如最近10分钟内没有访问的数据；</p><p>同步机制</p><p>实时写入；（推）</p><p>异步刷新；（推拉）</p>]]></content>
      
      
      <categories>
          
          <category> 服务器配置与管理 </category>
          
          <category> Web技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis基础之一：Redis概述</title>
      <link href="/2020/08/19/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E5%9F%BA%E7%A1%80%E4%B9%8B%E4%B8%80%EF%BC%9ARedis%E6%A6%82%E8%BF%B0/"/>
      <url>/2020/08/19/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E5%9F%BA%E7%A1%80%E4%B9%8B%E4%B8%80%EF%BC%9ARedis%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是Redis"><a href="#什么是Redis" class="headerlink" title="什么是Redis"></a>什么是Redis</h1><p><strong>Redis(Remote Dictionary Server)</strong>是用C语言开发的一个开源的、支持网络交互的、可基于内存也可持久化的高性能键值对（key-value)数据库。</p><p>特征：</p><ol><li>数据间没有必然的关联关系</li><li>内部采用单线程机制进行工作（保证安全性）</li><li>高性能。官方测试数据：50个并发执行10w个请求，读的速度是11w次/s，写的速度是8.1w次/s。</li><li>多数据类型支持</li><li>持久化支持。可以进行数据灾难恢复</li><li>所提供指令都是原子的</li></ol><h1 id="为什么要使用Redis"><a href="#为什么要使用Redis" class="headerlink" title="为什么要使用Redis"></a>为什么要使用Redis</h1><p>用缓存，主要有两个用途：<strong>高性能</strong>、<strong>高并发</strong>。</p><h2 id="高性能"><a href="#高性能" class="headerlink" title="高性能"></a>高性能</h2><p>对于一些需要复杂操作耗时查出来的结果，且确定后面不怎么变化，但是有很多读请求，可直接将查询出来的结果放在缓存中，后面直接读缓存来提高性能。</p><h2 id="高并发"><a href="#高并发" class="headerlink" title="高并发"></a>高并发</h2><p>mysql 对高并发的支持不好，单机到 <code>2000QPS</code> 也开始容易报警了</p><p>而使用缓存可以将数据放入缓存中。缓存功能简单，就是 <code>key-value</code> 式操作，单机支撑的并发量轻松一秒几万十几万，支撑高并发 so easy。单机承载并发量是 mysql 单机的几十倍。</p><blockquote><p>缓存是走内存的，内存天然就支撑高并发。</p></blockquote><h1 id="Redis应用场景"><a href="#Redis应用场景" class="headerlink" title="Redis应用场景"></a>Redis应用场景</h1><ul><li>为热点数据加速查询（主要场景），如热点商品、热点新闻、热点资讯、推广类等高访问量信息等</li><li>任务队列，如秒杀、抢购、购票排队等</li><li>即时信息查询，如各位排行榜、各类网站访问统计、公交到站信息、在线人数、设备信息等</li><li>时效性信息控制，如验证码控制、投票控制等</li><li>消息队列</li><li>分布式锁</li></ul><h1 id="需要承担的问题"><a href="#需要承担的问题" class="headerlink" title="需要承担的问题"></a>需要承担的问题</h1><p>常见的缓存问题有以下几个：</p><ul><li>缓存与数据库双写不一致</li><li>缓存雪崩、缓存穿透、缓存击穿</li><li>缓存并发竞争</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> 非关系型数据库 </category>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 缓存 </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis基础之五：Redis发布订阅</title>
      <link href="/2020/08/19/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E5%9F%BA%E7%A1%80%E4%B9%8B%E4%BA%94%EF%BC%9ARedis%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85/"/>
      <url>/2020/08/19/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E5%9F%BA%E7%A1%80%E4%B9%8B%E4%BA%94%EF%BC%9ARedis%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85/</url>
      
        <content type="html"><![CDATA[<p>Redis 发布订阅 (pub/sub) 是一种<strong>消息通信模式</strong>：发送者 (pub) 发送消息，订阅者 (sub) 接收消息。</p><p>Redis提供了两种信息机制， 分别是<code>订阅/发布到频道</code>和<code>订阅/发布到模式</code></p><h1 id="订阅-发布到频道"><a href="#订阅-发布到频道" class="headerlink" title="订阅/发布到频道"></a>订阅/发布到频道</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>发布订阅通信模式示意图如下，Redis客户端可以订阅任意数量的频道，当有消息发布到该频道时会转发到所有订阅了该频道的订阅者处</p><p><img alt="img" data-src="//orangesching.github.io/2020/08/19/数据库/非关系型数据库/Redis/Redis基础之五：Redis发布订阅/pubsub2.png" class="lazyload"></p><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p>发布消息：<code>PUBLISH channel message</code></p><p>订阅频道：<code>SUBSCRIBE channel [channel ...]</code></p><p>退订：<code>UNSUBSCRIBE [channel [channel ...\]]</code></p><p>查看订阅与发布系统状态信息：<code>PUBSUB subcommand [argument [argument ...\]]</code></p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><img alt="image-20201209153900676" data-src="//orangesching.github.io/2020/08/19/数据库/非关系型数据库/Redis/Redis基础之五：Redis发布订阅/image-20201209153900676.png" class="lazyload"></p><h1 id="订阅-发布到模式"><a href="#订阅-发布到模式" class="headerlink" title="订阅/发布到模式"></a>订阅/发布到模式</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>Redis支持订阅到某一模式，当订阅到某一模式时，发布消息到符合该模式的任意频道，订阅者都会收到消息</p><p>例如图中， <code>tweet.shop.*</code> 模式匹配了 <code>tweet.shop.kindle</code> 频道和 <code>tweet.shop.ipad</code> 频道。<code>client123</code>和<code>client256</code>订阅该模式，<code>clientX</code>和<code>clientY</code>订阅了<code>tweet.shop.kindle</code> 频道。当有信息发送到 <code>tweet.shop.kindle</code> 频道时， 信息除了发送给 <code>clientX</code> 和 <code>clientY</code> 之外， 还会发送给订阅 <code>tweet.shop.*</code> 模式的 <code>client123</code> 和 <code>client256</code> ：</p><p><img alt="订阅模式" data-src="//orangesching.github.io/2020/08/19/数据库/非关系型数据库/Redis/Redis基础之五：Redis发布订阅/graphviz-3d1f513ee0718a326d53152b2b97f82977e38ad6.svg" class="lazyload"></p><h2 id="命令-1"><a href="#命令-1" class="headerlink" title="命令"></a>命令</h2><p>发布消息：<code>PUBLISH channel message</code></p><p>订阅频道：<code>PSUBSCRIBE channel [channel ...]</code></p><p>退订：<code>PUNSUBSCRIBE [channel [channel ...\]]</code></p><p>查看订阅与发布系统状态信息：<code>PUBSUB subcommand [argument [argument ...\]]</code></p><h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><p>使用subscribe不能订阅模式，如果使用subscribe订阅模式，<code>*</code>会认为是普通字符</p><p><img alt="image-20201209154550733" data-src="//orangesching.github.io/2020/08/19/数据库/非关系型数据库/Redis/Redis基础之五：Redis发布订阅/image-20201209154550733.png" class="lazyload"></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> 非关系型数据库 </category>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 缓存 </tag>
            
            <tag> Redis </tag>
            
            <tag> 发布订阅 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis进阶之一：Redis持久化</title>
      <link href="/2020/08/19/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E5%8E%9F%E7%90%86%E4%B9%8B%E4%B8%80%EF%BC%9ARedis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
      <url>/2020/08/19/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E5%8E%9F%E7%90%86%E4%B9%8B%E4%B8%80%EF%BC%9ARedis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a>底层数据结构</h1><h2 id="简单动态字符串"><a href="#简单动态字符串" class="headerlink" title="简单动态字符串"></a>简单动态字符串</h2><div class="table-container"><table><thead><tr><th></th><th>C字符串</th><th>SDS字符串</th></tr></thead><tbody><tr><td>示意图</td><td><img alt="img" data-src="//orangesching.github.io/2020/08/19/数据库/非关系型数据库/Redis/Redis原理之一：Redis数据结构底层原理/graphviz-cd9ca0391fd6ab95a2c5b48d5f5fbd0da2db1cab.png" class="lazyload"></td><td><img alt="img" data-src="//orangesching.github.io/2020/08/19/数据库/非关系型数据库/Redis/Redis原理之一：Redis数据结构底层原理/graphviz-dbd2f4d49a9f495f18093129393569f93e645529.png" class="lazyload"></td></tr><tr><td>结构</td><td>使用长度为 <code>N+1</code> 的字符数组来表示长度为 <code>N</code> 的字符串， 并且字符数组的最后一个元素总是空字符 <code>&#39;\0&#39;</code></td><td><code>free</code>保存剩余存储空间<br><code>len</code>保存字符串实际长度空间<br><code>buf</code>为一个字节数组，保存字符串内容，数组实际大小为<code>free+len+1</code></td></tr><tr><td>区别</td><td>获取字符串长度的复杂度为 O(N) <br>API 是不安全的，可能会造成缓冲区溢出<br>修改字符串长度 <code>N</code> 次必然需要执行 <code>N</code> 次内存重分配<br>只能保存文本数据<br></td><td>获取字符串长度的复杂度为 O(1) <br>API 是安全的，不会造成缓冲区溢出<br>修改字符串长度 <code>N</code> 次最多需要执行 <code>N</code> 次内存重分配<br>可以保存文本或者二进制数据</td></tr></tbody></table></div><h3 id="SDS字符串扩容"><a href="#SDS字符串扩容" class="headerlink" title="SDS字符串扩容"></a>SDS字符串扩容</h3><p>SDS字符串通过<strong>惰性空间释放</strong>和<strong>空间预分配</strong>来减少字符串修改导致的内存重分配次数</p><p><strong>惰性空间释放</strong>：即当字符串操作导致字符串变短时，空闲出的内存不马上释放，而是加入到<code>free</code>保存，以便有增长字符串长度时，要重新分配内存</p><p><strong>空间预分配</strong>：当对一个 SDS 进行修改并需要进行空间扩展时， 不仅会为 SDS 分配修改所必须要的空间， 还会为 SDS 分配额外的未使用空间。例如修改后的字符串占用<code>1M</code>，则<code>free</code>将等于<code>1M</code>，字符串buf数组的实际长度<code>free+len+1</code>，具体分配额外未使用空间<code>V(x)</code>的大小计算如下，<code>x</code>为修改后SDS长度（<code>len</code> 属性的值）：</p><script type="math/tex; mode=display">V(x)=\left\{\begin{aligned}x & & x<1M \\1M & & x\geq1M\end{aligned}\right.</script><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p><img alt="链表数据结构" data-src="http://redisbook.com/_images/graphviz-5f4d8b6177061ac52d0ae05ef357fceb52e9cb90.png" class="lazyload"></p><p>链表结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line">    <span class="comment">// 表头节点</span></span><br><span class="line">    listNode *head;</span><br><span class="line">    <span class="comment">// 表尾节点</span></span><br><span class="line">    listNode *tail;</span><br><span class="line">    <span class="comment">// 链表所包含的节点数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 节点值复制函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*dup)(<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="comment">// 节点值释放函数</span></span><br><span class="line">    <span class="keyword">void</span> (*<span class="built_in">free</span>)(<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="comment">// 节点值对比函数</span></span><br><span class="line">    <span class="keyword">int</span> (*match)(<span class="keyword">void</span> *ptr, <span class="keyword">void</span> *key);</span><br><span class="line">&#125; <span class="built_in">list</span>;</span><br></pre></td></tr></table></figure><p>链表结点结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> &#123;</span></span><br><span class="line">    <span class="comment">// 前置节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="comment">// 后置节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="comment">// 节点的值</span></span><br><span class="line">    <span class="keyword">void</span> *value;</span><br><span class="line">&#125; listNode;</span><br></pre></td></tr></table></figure><p>Redis 的链表特性总结如下：</p><ul><li>双端： 链表节点带有 <code>prev</code> 和 <code>next</code> 指针， 获取某个节点的前置节点和后置节点的复杂度都是 O(1) </li><li>无环： 表头节点的 <code>prev</code> 指针和表尾节点的 <code>next</code> 指针都指向 <code>NULL</code> ， 对链表的访问以 <code>NULL</code> 为终点</li><li>带表头指针和表尾指针： 通过 <code>list</code> 结构的 <code>head</code> 指针和 <code>tail</code> 指针， 程序获取链表的表头节点和表尾节点的复杂度为 O(1) </li><li>带链表长度计数器： 程序使用 <code>list</code> 结构的 <code>len</code> 属性来对 <code>list</code> 持有的链表节点进行计数， 程序获取链表中节点数量的复杂度为 O(1) </li><li>多态： 链表节点使用 <code>void*</code> 指针来保存节点值， 并且可以通过 <code>list</code> 结构的 <code>dup</code> 、 <code>free</code> 、 <code>match</code> 三个属性为节点值设置类型特定函数， 所以链表可以用于保存各种不同类型的值</li></ul><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p><img alt="哈希表结构" data-src="http://redisbook.com/_images/graphviz-d2641d962325fd58bf15d9fffb4208f70251a999.png" class="lazyload"></p><p>哈希表数据结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">typedef struct dictht &#123;</span><br><span class="line">    // 哈希表数组</span><br><span class="line">    dictEntry **table;</span><br><span class="line">    // 哈希表大小</span><br><span class="line">    unsigned long size;</span><br><span class="line">    // 哈希表大小掩码，用于计算索引值</span><br><span class="line">    // 总是等于 size - 1</span><br><span class="line">    unsigned long sizemask;</span><br><span class="line">    // 该哈希表已有节点的数量</span><br><span class="line">    unsigned long used;</span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure><p>哈希表结点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">typedef struct dictEntry &#123;</span><br><span class="line">    // 键</span><br><span class="line">    void *key;</span><br><span class="line">    // 值</span><br><span class="line">    union &#123;</span><br><span class="line">        void *val;</span><br><span class="line">        uint64_t u64;</span><br><span class="line">        int64_t s64;</span><br><span class="line">    &#125; v;</span><br><span class="line">    // 指向下个哈希表节点，形成链表</span><br><span class="line">    struct dictEntry *next;</span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure><h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p>字典使用哈希表作为底层实现</p><p><img alt="image-20201229164644593" data-src="//orangesching.github.io/2020/08/19/数据库/非关系型数据库/Redis/Redis原理之一：Redis数据结构底层原理/image-20201229164644593.png" class="lazyload"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">typedef struct dict &#123;</span><br><span class="line">    // 类型特定函数，指向 dictType 结构的指针， 每个 dictType 结构保存了一簇用于操作特定类型键值对的函数</span><br><span class="line">    dictType *type;</span><br><span class="line">    // 私有数据，保存了需要传给那些类型特定函数的可选参数</span><br><span class="line">    void *privdata;</span><br><span class="line">    // 包含两个项的数组， 数组中的每个项都是一个 dictht 哈希表， 一般情况下， 字典只使用 ht[0] 哈希表， ht[1] 哈希表只会在对 ht[0] 哈希表进行 rehash 时使用</span><br><span class="line">    dictht ht[2];</span><br><span class="line">    // 当没有进行重哈希时，值为 -1</span><br><span class="line">    int rehashidx; </span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure><p>对于关键字key最终的存储位置由以下步骤得出：</p><p>1.使用哈希函数计算哈希值</p><p>2.计算索引值</p><p>3.如有冲突，则使用冲突策略解决冲突</p><p>4.为平衡冲突与空间占用，当负载因子处于非合理水平时，哈希表进行扩容或收缩，表内数据进行重哈希</p><h3 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h3><p>哈希函数能将关键字集合均匀地分布在地址集<code>{0,1，…，m-1}</code>上，使冲突最小</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 1.使用字典设置的哈希函数，计算键 key 的哈希值</span><br><span class="line">hash = dict-&gt;type-&gt;hashFunction(key);</span><br><span class="line"></span><br><span class="line"># 使用哈希表的 sizemask 属性和哈希值，计算出索引值</span><br><span class="line"># 根据情况不同， ht[x] 可以是 ht[0] 或者 ht[1]</span><br><span class="line">index = hash &amp; dict-&gt;ht[x].sizemask;</span><br></pre></td></tr></table></figure><h3 id="冲突解决"><a href="#冲突解决" class="headerlink" title="冲突解决"></a>冲突解决</h3><h3 id="重哈希"><a href="#重哈希" class="headerlink" title="重哈希"></a>重哈希</h3><h1 id="对象数据结构"><a href="#对象数据结构" class="headerlink" title="对象数据结构"></a>对象数据结构</h1><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><h2 id="SortedSet"><a href="#SortedSet" class="headerlink" title="SortedSet"></a>SortedSet</h2>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> 非关系型数据库 </category>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 缓存 </tag>
            
            <tag> Redis </tag>
            
            <tag> 持久化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis应用之一：Redis分布式锁</title>
      <link href="/2020/08/19/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E5%BA%94%E7%94%A8%E4%B9%8B%E4%BA%8C%EF%BC%9ARedis%E5%AD%98%E5%9C%A8%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3/"/>
      <url>/2020/08/19/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E5%BA%94%E7%94%A8%E4%B9%8B%E4%BA%8C%EF%BC%9ARedis%E5%AD%98%E5%9C%A8%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> 非关系型数据库 </category>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 缓存 </tag>
            
            <tag> Redis </tag>
            
            <tag> 分布式锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis应用之一：Redis分布式锁</title>
      <link href="/2020/08/19/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E5%BA%94%E7%94%A8%E4%B9%8B%E4%B8%89%EF%BC%9ARedis%E7%9A%84Java%E5%AE%A2%E6%88%B7%E7%AB%AF/"/>
      <url>/2020/08/19/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E5%BA%94%E7%94%A8%E4%B9%8B%E4%B8%89%EF%BC%9ARedis%E7%9A%84Java%E5%AE%A2%E6%88%B7%E7%AB%AF/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> 非关系型数据库 </category>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 缓存 </tag>
            
            <tag> Redis </tag>
            
            <tag> 分布式锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis基础之四：Redis事务</title>
      <link href="/2020/08/19/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%9B%9B%EF%BC%9ARedis%E4%BA%8B%E5%8A%A1/"/>
      <url>/2020/08/19/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%9B%9B%EF%BC%9ARedis%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis事务概述"><a href="#Redis事务概述" class="headerlink" title="Redis事务概述"></a>Redis事务概述</h1><h2 id="Redis事务是什么"><a href="#Redis事务是什么" class="headerlink" title="Redis事务是什么"></a>Redis事务是什么</h2><p>Redis事务就是一次性、顺序性、排他性的执行一个队列中的一系列指令</p><h2 id="与MYSQL数据库的区别"><a href="#与MYSQL数据库的区别" class="headerlink" title="与MYSQL数据库的区别"></a>与MYSQL数据库的区别</h2><div class="table-container"><table><thead><tr><th>Redis</th><th>Mysql</th></tr></thead><tbody><tr><td>默认不会开启事务，即指令会立即执行，而不会排队<br>不支持隔离级别的调整<br>指令执行错误其他指令仍然回被执行<br>不支持回滚<br>支持乐观锁</td><td>默认开启一个自动提交的事务，即每成功执行一次sql，一个事务就会马上提交<br>支持隔离级别的调整<br>执行错误自动回滚<br><br></td></tr></tbody></table></div><blockquote><p>在关系型数据库中，经常使用ACID来讨论事务，但是在非关系型数据库中是无意义的（因为没有这个概念），Redis实现的原子性只是要么都运行，要么都不运行。而不是Mysql的要么都正确运行，要么都不运行。对于一致性，Redis不存在这个概念，因为没有这个约束</p></blockquote><h2 id="Redis事务三个阶段"><a href="#Redis事务三个阶段" class="headerlink" title="Redis事务三个阶段"></a>Redis事务三个阶段</h2><ul><li><p>开始事务</p></li><li><p>命令入队，没有实际执行</p></li><li><p>执行事务，顺序的一次执行</p></li></ul><blockquote><p>批量操作在发送 EXEC 命令前被放入队列缓存，并不会被实际执行</p><p>即事务内的查询看不到事务里的更新</p><p>事务外查询也不能看到事务里的更新</p></blockquote><p><img alt="事务在EXEC命令之前没有实际被执行" data-src="//orangesching.github.io/2020/08/19/数据库/非关系型数据库/Redis/Redis基础之四：Redis事务/image-20201204175952150.png" class="lazyload"></p><h1 id="Redis事务指令"><a href="#Redis事务指令" class="headerlink" title="Redis事务指令"></a>Redis事务指令</h1><div class="table-container"><table><thead><tr><th>指令</th><th>详情</th></tr></thead><tbody><tr><td><code>watch key1 [key2 ...]</code></td><td>监控一或多个key,如果在事务执行之前，被监视的key被其他命令改动，则事务被打断（乐观锁）</td></tr><tr><td><code>multi</code></td><td>标记一个事务块的开始，之后的指令入队</td></tr><tr><td><code>exec</code></td><td>执行所有事务块的命令，<strong>释放所有监控锁</strong></td></tr><tr><td><code>discard</code></td><td>取消事务，放弃事务块中的所有命令</td></tr><tr><td><code>unwatch key1 [key2 ...]</code></td><td>取消监控</td></tr></tbody></table></div><h2 id="一般事务的执行样例"><a href="#一般事务的执行样例" class="headerlink" title="一般事务的执行样例"></a>一般事务的执行样例</h2><div class="table-container"><table><thead><tr><th>正常执行</th><th>取消事务</th></tr></thead><tbody><tr><td><img alt="image-20201204180740303" data-src="//orangesching.github.io/2020/08/19/数据库/非关系型数据库/Redis/Redis基础之四：Redis事务/image-20201204180740303.png" class="lazyload"></td><td><img alt="image-20201204181056518" data-src="//orangesching.github.io/2020/08/19/数据库/非关系型数据库/Redis/Redis基础之四：Redis事务/image-20201204181056518.png" class="lazyload"></td></tr></tbody></table></div><h2 id="Watch的执行样例"><a href="#Watch的执行样例" class="headerlink" title="Watch的执行样例"></a>Watch的执行样例</h2><p><code>watch</code>指令类似于乐观锁，在事务提交时，如果<code>watch</code>监控的多个KEY中任何KEY的值已经被其他客户端更改，则使用<code>exec</code>执行事务时，事务队列将不会被执行，同时返回<code>Nullmulti-bulk</code>应答以通知调用者事务执行失败</p><p><strong><code>watch</code>一定要在<code>multi</code>之前执行</strong></p><div class="table-container"><table><thead><tr><th>监听后未修改，执行成功</th><th>监听后修改，执行失败</th></tr></thead><tbody><tr><td><img alt="监听后未修改，执行成功" data-src="//orangesching.github.io/2020/08/19/数据库/非关系型数据库/Redis/Redis基础之四：Redis事务/image-20201207092433865.png" class="lazyload"></td><td><img alt="监听后修改，执行失败" data-src="//orangesching.github.io/2020/08/19/数据库/非关系型数据库/Redis/Redis基础之四：Redis事务/image-20201204183515345.png" class="lazyload"></td></tr></tbody></table></div><h2 id="错误对事务的影响"><a href="#错误对事务的影响" class="headerlink" title="错误对事务的影响"></a>错误对事务的影响</h2><div class="table-container"><table><thead><tr><th>命令错误（输完会直接报错，不会显示QUEUED的错误）导致的错误会导致整个事务不执行</th><th>语法错误导致的错误只会影响有错误的指令，事务中的其他指令正常执行</th></tr></thead><tbody><tr><td><img alt="image-20201204182015956" data-src="//orangesching.github.io/2020/08/19/数据库/非关系型数据库/Redis/Redis基础之四：Redis事务/image-20201204182015956.png" class="lazyload"></td><td><img alt="image-20201204182439396" data-src="//orangesching.github.io/2020/08/19/数据库/非关系型数据库/Redis/Redis基础之四：Redis事务/image-20201204182439396.png" class="lazyload"></td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> 非关系型数据库 </category>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 缓存 </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis应用之一：Redis分布式锁</title>
      <link href="/2020/08/19/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E5%BA%94%E7%94%A8%E4%B9%8B%E4%B8%80%EF%BC%9ARedis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
      <url>/2020/08/19/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E5%BA%94%E7%94%A8%E4%B9%8B%E4%B8%80%EF%BC%9ARedis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> 非关系型数据库 </category>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 缓存 </tag>
            
            <tag> Redis </tag>
            
            <tag> 分布式锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis进阶之二：Redis集群</title>
      <link href="/2020/08/19/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%BF%9B%E9%98%B6%E4%B9%8B%E4%BA%8C%EF%BC%9ARedis%E9%9B%86%E7%BE%A4/"/>
      <url>/2020/08/19/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%BF%9B%E9%98%B6%E4%B9%8B%E4%BA%8C%EF%BC%9ARedis%E9%9B%86%E7%BE%A4/</url>
      
        <content type="html"><![CDATA[<h1 id><a href="#" class="headerlink" title=" "></a> </h1>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> 非关系型数据库 </category>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 缓存 </tag>
            
            <tag> Redis </tag>
            
            <tag> 持久化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis进阶之一：Redis持久化</title>
      <link href="/2020/08/19/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%BF%9B%E9%98%B6%E4%B9%8B%E4%B8%80%EF%BC%9ARedis%E6%8C%81%E4%B9%85%E5%8C%96/"/>
      <url>/2020/08/19/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%BF%9B%E9%98%B6%E4%B9%8B%E4%B8%80%EF%BC%9ARedis%E6%8C%81%E4%B9%85%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>RDB持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘。默认的持久化方式为RDB，这种方式就是将内存中数据以快照的方式写入到二进制文件中,默认的文件名为dump.rdb。</p><p>Reddis的所有的配置都是在redis.conf文件中，其中包含RDB和AOF两种持久化机制的各种配置。</p><h1 id="Redis-DataBase-RDB"><a href="#Redis-DataBase-RDB" class="headerlink" title="Redis DataBase(RDB)"></a>Redis DataBase(RDB)</h1><p>RDB就是把数据以<strong>快照</strong>的形式保存在磁盘上，即像对数据拍照一样，把某一时刻的数据保存到磁盘上。</p><p>对于RDB来说需讨论的关键问题是：什么时候拍照，拍照的时候Redis是否正常工作</p><h2 id="触发机制"><a href="#触发机制" class="headerlink" title="触发机制"></a>触发机制</h2><p>RDB提供了三种机制：<code>save</code>、<code>bgsave</code>、<code>自动触发</code></p><h3 id="手动触发"><a href="#手动触发" class="headerlink" title="手动触发"></a>手动触发</h3><h4 id="save命令（已废弃）"><a href="#save命令（已废弃）" class="headerlink" title="save命令（已废弃）"></a>save命令（已废弃）</h4><p>在主线程中保存快照。会<strong>阻塞当前Redis服务器</strong>，直到保存完毕</p><p><strong>优点</strong>是不会消耗额外的内存空间</p><p><strong>缺点</strong>是对于内存大的实例会造成长时间的阻塞，线上环境不建议使用</p><p>具体流程如下：</p><p><img alt="img" data-src="//orangesching.github.io/2020/08/19/数据库/非关系型数据库/Redis/Redis进阶之一：Redis持久化/e7cd7b899e510fb3aa8c05042b22c093d0430ca7.jpeg" class="lazyload"></p><h4 id="bgsave命令"><a href="#bgsave命令" class="headerlink" title="bgsave命令"></a>bgsave命令</h4><p>Redis进程执行fork操作创建子进程，RDB持久化过程由子进程负责，完成后自动结束。</p><p>堵塞只发生在fork阶段，一般时间很短。</p><p>BGSAVE命令是针对SAVE堵塞问题做的优化。因此Redis内部所有的设计RDB的操作都采用BGSAVE的方式，而save命令已经废弃。</p><p>执行该命令时，Redis会在后台异步进行快照操作，快照同时还可以响应客户端请求。具体流程如下：</p><p><img alt="img" data-src="//orangesching.github.io/2020/08/19/数据库/非关系型数据库/Redis/Redis进阶之一：Redis持久化/023b5bb5c9ea15cefb035bc8431132f53b87b21e.jpeg" class="lazyload"></p><h3 id="自动触发"><a href="#自动触发" class="headerlink" title="自动触发"></a>自动触发</h3><p>自动触发是由配置文件配置完成</p><h4 id="save-n-m"><a href="#save-n-m" class="headerlink" title="save n m"></a>save n m</h4><p>自动触发最常见的情况是在配置文件中通过<code>save m n</code>，指定当<code>m</code>秒内发生<code>n</code>次变化时，会自动触发<code>bgsave</code></p><p><code>redis.conf</code>配置文件中可配置</p><p>默认配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">################################ SNAPSHOTTING  ################################</span><br><span class="line">#</span><br><span class="line"># Save the DB on disk:</span><br><span class="line">#</span><br><span class="line">#   save &lt;seconds&gt; &lt;changes&gt;</span><br><span class="line">#</span><br><span class="line">#   Will save the DB if both the given number of seconds and the given</span><br><span class="line">#   number of write operations against the DB occurred.</span><br><span class="line">#</span><br><span class="line">#   In the example below the behaviour will be to save:</span><br><span class="line">#   after 900 sec (15 min) if at least 1 key changed</span><br><span class="line">#   after 300 sec (5 min) if at least 10 keys changed</span><br><span class="line">#   after 60 sec if at least 10000 keys changed</span><br><span class="line">#</span><br><span class="line">#   Note: you can disable saving completely by commenting out all &quot;save&quot; lines.</span><br><span class="line">#</span><br><span class="line">#   It is also possible to remove all the previously configured save</span><br><span class="line">#   points by adding a save directive with a single empty string argument</span><br><span class="line">#   like in the following example:</span><br><span class="line">#</span><br><span class="line">#   save &quot;&quot;</span><br><span class="line"># 不需要持久化，可以注释掉所有的 save 行来停用功能</span><br><span class="line">save 900 1      # 900秒内如果至少有1个key的值变化</span><br><span class="line">save 300 10     # 300 秒内如果至少有10个key的值变化</span><br><span class="line">save 60 10000   # 60 秒内如果至少有 10000 个 key 的值变化</span><br></pre></td></tr></table></figure><p>其他配置</p><ul><li><p>stop-writes-on-bgsave-error：默认值为yes。启用了RDB且最后一次后台保存数据失败时，Redis是否停止接收数据。这会让用户意识到数据没有正确持久化到磁盘上，否则没有人会注意到灾难发生了</p></li><li><p>rdbcompression：默认值是yes。对于存储到磁盘中的快照，可以设置是否进行压缩存储。</p></li><li><p>rdbchecksum：默认值是yes。在存储快照后，是否使用使用CRC64算法来进行数据校验，但是这样做会增加大约10%的性能消耗，如果希望获取到最大的性能提升，可以关闭此功能。</p></li><li><p>dbfilename：设置快照的文件名，默认是 dump.rdb</p></li><li><p>dir：设置快照文件的存放路径</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"># By default Redis will stop accepting writes if RDB snapshots are enabled</span><br><span class="line"># (at least one save point) and the latest background save failed.</span><br><span class="line"># This will make the user aware (in a hard way) that data is not persisting</span><br><span class="line"># on disk properly, otherwise chances are that no one will notice and some</span><br><span class="line"># disaster will happen.</span><br><span class="line">#</span><br><span class="line"># If the background saving process will start working again Redis will</span><br><span class="line"># automatically allow writes again.</span><br><span class="line">#</span><br><span class="line"># However if you have setup your proper monitoring of the Redis server</span><br><span class="line"># and persistence, you may want to disable this feature so that Redis will</span><br><span class="line"># continue to work as usual even if there are problems with disk,</span><br><span class="line"># permissions, and so forth.</span><br><span class="line">stop-writes-on-bgsave-error yes</span><br><span class="line"></span><br><span class="line"># Compress string objects using LZF when dump .rdb databases?</span><br><span class="line"># For default that&apos;s set to &apos;yes&apos; as it&apos;s almost always a win.</span><br><span class="line"># If you want to save some CPU in the saving child set it to &apos;no&apos; but</span><br><span class="line"># the dataset will likely be bigger if you have compressible values or keys.</span><br><span class="line">rdbcompression yes  # 是否使用使用CRC64算法来进行数据校验</span><br><span class="line"></span><br><span class="line"># Since version 5 of RDB a CRC64 checksum is placed at the end of the file.</span><br><span class="line"># This makes the format more resistant to corruption but there is a performance</span><br><span class="line"># hit to pay (around 10%) when saving and loading RDB files, so you can disable it</span><br><span class="line"># for maximum performances.</span><br><span class="line">#</span><br><span class="line"># RDB files created with checksum disabled have a checksum of zero that will</span><br><span class="line"># tell the loading code to skip the check.</span><br><span class="line">rdbchecksum yes</span><br><span class="line"></span><br><span class="line"># The filename where to dump the DB</span><br><span class="line">dbfilename dump.rdb   # 设置快照的文件名</span><br><span class="line"></span><br><span class="line"># The working directory.</span><br><span class="line">#</span><br><span class="line"># The DB will be written inside this directory, with the filename specified</span><br><span class="line"># above using the &apos;dbfilename&apos; configuration directive.</span><br><span class="line">#</span><br><span class="line"># The Append Only File will also be created inside this directory.</span><br><span class="line">#</span><br><span class="line"># Note that you must specify a directory here, not a file name.</span><br><span class="line">dir ./</span><br></pre></td></tr></table></figure><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>除了save m n以外，还有一些其他情况会触发bgsave：</p><ol><li>如果从节点执行<code>全量复制操作</code>，主节点自动执行<code>BGSAVE</code>生成<code>RDB</code>文件并发送给从节点。</li><li>执行<code>debug reload</code>命令重新加载<code>Redis</code>时，也会自动触发<code>save</code>操作。</li><li>默认情况下执行<code>shutdown</code>命令时，如果没有开启<code>AOF持久化功能</code>则自动执行<code>BGSAVE</code>。</li></ol><h2 id="RDB的优劣"><a href="#RDB的优劣" class="headerlink" title="RDB的优劣"></a>RDB的优劣</h2><p><strong>优势</strong></p><ul><li><p>RDB是一次全量备份，存储的是内存数据的二进制序列化形式，存储上非常紧凑，非常适合用于进行备份和灾难恢复</p></li><li><p>生成RDB文件的时候，redis主进程会<code>fork()</code>一个子进程来处理所有保存工作，主进程不需要进行任何磁盘<code>IO</code>操作</p></li><li><p>RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快</p></li></ul><p><strong>劣势</strong></p><p>父进程修改内存子进程不会反应出来。进行快照持久化时，会开启一个子进程专门负责快照持久化，子进程会拥有父进程的内存数据，但在快照持久化期间父进程修改的数据不会反应在子进程种被保存，可能丢失数据</p><h1 id="Append-Only-File-AOF"><a href="#Append-Only-File-AOF" class="headerlink" title="Append Only File(AOF)"></a>Append Only File(AOF)</h1><p>全量备份总是耗时的，Redis还提供一种更加高效的方式AOF</p><h2 id="持久化步骤"><a href="#持久化步骤" class="headerlink" title="持久化步骤"></a>持久化步骤</h2><ol><li><p><strong>记录写操作：</strong>将每一个收到的写命令都通过<code>write</code>函数追加到文件中，就像日志记录一样</p><p><img alt="img" data-src="//orangesching.github.io/2020/08/19/数据库/非关系型数据库/Redis/Redis进阶之一：Redis持久化/32fa828ba61ea8d3c2502e396b1b3848251f58b0.jpeg" class="lazyload"></p></li><li><p><strong>AOF重写：</strong>持久化文件会变的越来越大。为了压缩AOF的持久化文件。redis提供了<strong><code>bgrewriteaof</code></strong>命令。将内存中的数据以命令的方式保存到临时文件中，同时会<code>fork</code>出一条<strong>新进程</strong>来将文件重写，重写aof文件的操作，并没有读取旧的AOF文件，而是<strong>将整个内存中的数据库内容用命令的方式重写了一个新的AOF文件</strong>，这点和快照有点类似。</p></li></ol><p><img alt="img" data-src="//orangesching.github.io/2020/08/19/数据库/非关系型数据库/Redis/Redis进阶之一：Redis持久化/09fa513d269759ee28454d2c4cea4b106c22dfd3.jpeg" class="lazyload"></p><h2 id="触发机制-1"><a href="#触发机制-1" class="headerlink" title="触发机制"></a>触发机制</h2><p>多久将内存的数据写入文件中</p><ul><li><p>每修改同步always：同步持久化 每次发生数据变更会被立即记录到磁盘 性能较差但数据完整性比较好</p></li><li><p>每秒同步everysec：异步操作，每秒记录 如果一秒内宕机，有数据丢失</p></li><li><p>不同no：从不同步</p></li></ul><div class="table-container"><table><thead><tr><th></th><th>always</th><th>exyerysec</th><th>mo</th></tr></thead><tbody><tr><td>优点</td><td>不丢失数据</td><td>每秒一次fsync，丢一秒数据</td><td>不可管</td></tr><tr><td>缺点</td><td>IO开销较大</td><td>丢一秒数据</td><td>不可控</td></tr></tbody></table></div><p>对应配置文件中的配置项如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># appendfsync always#一直记录，每次有变更就记录</span><br><span class="line"># appendfsync everysec#每秒记录一次</span><br><span class="line"># appendfsync no    #每隔一段时间记录一次，根据系统里面算法决定，不安全</span><br></pre></td></tr></table></figure><h1 id="RDB和AOF对比及选择"><a href="#RDB和AOF对比及选择" class="headerlink" title="RDB和AOF对比及选择"></a>RDB和AOF对比及选择</h1><div class="table-container"><table><thead><tr><th></th><th>RDB</th><th>AOF</th></tr></thead><tbody><tr><td>启动优先级</td><td>低</td><td>高</td></tr><tr><td>体积</td><td>小</td><td>大</td></tr><tr><td>恢复速度</td><td>快</td><td>慢</td></tr><tr><td>数据安全性</td><td>丢数据</td><td>根据策略决定</td></tr><tr><td>轻重</td><td>重</td><td>轻</td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> 非关系型数据库 </category>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 缓存 </tag>
            
            <tag> Redis </tag>
            
            <tag> 持久化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue入门</title>
      <link href="/2020/08/19/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/Vue/Vue%E5%85%A5%E9%97%A8/"/>
      <url>/2020/08/19/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/Vue/Vue%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Vue-js-目录结构"><a href="#Vue-js-目录结构" class="headerlink" title="Vue.js 目录结构"></a>Vue.js 目录结构</h1><p>在 IDE 中打开目录，结构如下所示：</p><p><img alt="Vue目录结构" data-src="//orangesching.github.io/2020/08/19/前端框架/Vue/Vue入门/Vue目录结构.jpg" class="lazyload"></p><div class="table-container"><table><thead><tr><th style="text-align:left">目录/文件</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">build</td><td style="text-align:left">项目构建(webpack)相关代码</td></tr><tr><td style="text-align:left">config</td><td style="text-align:left">配置目录，包括端口号等。我们初学可以使用默认的。</td></tr><tr><td style="text-align:left">node_modules</td><td style="text-align:left">npm 加载的项目依赖模块</td></tr><tr><td style="text-align:left">src</td><td style="text-align:left">这里是我们要开发的目录，基本上要做的事情都在这个目录里。里面包含了几个目录及文件：assets: 放置一些图片，如logo等。<br>components: 目录里面放了一个组件文件，可以不用。<br>App.vue: 项目入口文件，我们也可以直接将组件写这里，而不使用 components 目录。<br>main.js: 项目的核心文件。</td></tr><tr><td style="text-align:left">static</td><td style="text-align:left">静态资源目录，如图片、字体等。</td></tr><tr><td style="text-align:left">test</td><td style="text-align:left">初始测试目录，可删除</td></tr><tr><td style="text-align:left">.xxxx文件</td><td style="text-align:left">这些是一些配置文件，包括语法配置，git配置等。</td></tr><tr><td style="text-align:left">index.html</td><td style="text-align:left">首页入口文件，你可以添加一些 meta 信息或统计代码啥的。</td></tr><tr><td style="text-align:left">package.json</td><td style="text-align:left">项目配置文件。</td></tr><tr><td style="text-align:left">README.md</td><td style="text-align:left">项目的说明文档，markdown 格式</td></tr></tbody></table></div><h1 id="Vue构造器"><a href="#Vue构造器" class="headerlink" title="Vue构造器"></a>Vue构造器</h1><h2 id="Vue构造器初识"><a href="#Vue构造器初识" class="headerlink" title="Vue构造器初识"></a>Vue构造器初识</h2><p><strong>每个 Vue 应用都需要通过实例化 Vue 来实现。</strong></p><p>语法格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var vm = new Vue(&#123;</span><br><span class="line">  // 选项</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p> Vue 构造器简单使用例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;vue_det&quot;&gt;    </span><br><span class="line">    &lt;h1&gt;name : &#123; &#123;name&#125; &#125;&lt;/h1&gt;     &lt;!-- &#123; &#123; &#125; &#125; 用于输出对象属性和函数返回值 --&gt;</span><br><span class="line">    &lt;h1&gt;message : &#123; &#123;msg&#125; &#125;&lt;/h1&gt;     </span><br><span class="line">    &lt;h1&gt;&#123; &#123;details()&#125; &#125;&lt;/h1&gt; </span><br><span class="line">&lt;/div&gt; </span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;     </span><br><span class="line">    var vm = new Vue(&#123;         </span><br><span class="line">        el: &apos;#vue_det&apos;,       // DOM 元素中的 id，说明接下来的改动全部在指定div内，div外部不受影响</span><br><span class="line">        data: &#123;               // data用于定义属性，实例中有两个属性分别为：name、msg。 </span><br><span class="line">            msg: &quot;HelloWorld&quot;,             </span><br><span class="line">            name: &quot;orange&quot;      </span><br><span class="line">        &#125;,         </span><br><span class="line">        methods: &#123;            // methods用于定义的函数，可以通过 return 来返回函数值。</span><br><span class="line">            details: function() &#123;                 </span><br><span class="line">                return  this.name + &quot; Hello！&quot;;             </span><br><span class="line">            &#125;         </span><br><span class="line">        &#125;     </span><br><span class="line">    &#125;) </span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--另一种data赋值法展示出来的特性:无论改哪个结果一样--&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt; </span><br><span class="line">    var data = &#123; </span><br><span class="line">        msg: &quot;HelloWorld&quot;,             </span><br><span class="line">        name: &quot;orange&quot;</span><br><span class="line">    &#125; </span><br><span class="line">    var vm = new Vue(&#123;</span><br><span class="line">        el: &apos;#vue_det&apos;,    </span><br><span class="line">        data: data    // 可理解为vm.data指向了data内存，所以下面无论修改vm.data还是data结果都一样</span><br><span class="line">    &#125;) // 它们引用相同的对象！ </span><br><span class="line">    document.write(vm.msg === data.msg) // true </span><br><span class="line">    document.write(&quot;&lt;br&gt;&quot;) // 设置属性也会影响到原始数据 </span><br><span class="line">    vm.msg = &quot;Hello&quot; </span><br><span class="line">    document.write(data.site + &quot;&lt;br&gt;&quot;) // Hello</span><br><span class="line">    data.name = &quot;leaf&quot; </span><br><span class="line">    document.write(vm.name) // leaf</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><p>当一个 Vue 实例被创建时，它向 Vue 的响应式系统中加入了其 data 对象中能找到的所有的属性。当这些属性的值发生改变时，html 视图将也会产生相应的变化</p></blockquote><h2 id="Vue构造器属性"><a href="#Vue构造器属性" class="headerlink" title="Vue构造器属性"></a>Vue构造器属性</h2><p>这些属性可使用<code>vm.$属性名访问</code></p><div class="table-container"><table><thead><tr><th>属性名</th><th>作用</th><th>备注</th></tr></thead><tbody><tr><td><code>el</code></td><td>申明vue控制范围，为实例提供挂在元素</td><td></td></tr><tr><td><code>data</code></td><td>模板数据</td><td></td></tr><tr><td><code>components</code></td><td>Vue实例配置局部注册组件</td><td></td></tr><tr><td><code>methods</code></td><td>实例方法</td><td></td></tr><tr><td><code>watch</code></td><td>侦听属性，监测变化</td><td></td></tr><tr><td><code>computed</code></td><td>计算属性，也会监测变化，但有返回值</td><td>当数据发生变化时才调用，可提升性能</td></tr><tr><td><code>filters</code></td><td>过滤器</td><td></td></tr><tr><td><code>mouted</code></td><td>钩子函数</td><td></td></tr><tr><td><code>render</code></td><td>渲染函数，创建虚拟DOM</td></tr></tbody></table></div><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">"#app"</span> <span class="comment">//为实例提供挂载元素，该元素下被vue控制</span></span><br><span class="line">    data: &#123;</span><br><span class="line">        firstName: <span class="string">'Foo'</span>,</span><br><span class="line">        lastName: <span class="string">'Bar'</span>,</span><br><span class="line">        fullName: <span class="string">'Foo Bar'</span> <span class="comment">//初始化实例属性</span></span><br><span class="line">    &#125;,</span><br><span class="line">    props: [<span class="string">"content"</span>], <span class="comment">//父组件向子组件传值</span></span><br><span class="line">    methods: &#123;</span><br><span class="line">        getHandle()&#123;</span><br><span class="line">            <span class="comment">//该属性中申明方法</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    mounted: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 钩子函数</span></span><br><span class="line">    &#125;,</span><br><span class="line">    computed: &#123;</span><br><span class="line">        <span class="comment">//计算属性，当数据发生变化时才调用，否则直接调用缓存。提升性能</span></span><br><span class="line">        fullName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.firstName + <span class="string">' '</span> + <span class="keyword">this</span>.lastName</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    watch: &#123;</span><br><span class="line">        <span class="comment">//监测变化。</span></span><br><span class="line">        firstName: <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.fullName = val + <span class="string">' '</span> + <span class="keyword">this</span>.lastName</span><br><span class="line">        &#125;,</span><br><span class="line">        lastName: <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.fullName = <span class="keyword">this</span>.firstName + <span class="string">' '</span> + val</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="属性操作"><a href="#属性操作" class="headerlink" title="属性操作"></a>属性操作</h3><p>Vue 不允许在已经创建的实例上动态添加新的根级响应式属性，如果我们需要在运行过程中实现属性的添加或删除，则可以使用全局 Vue.set<code>和</code>Vue.delete` 方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Vue.set( target, key, value )</span><br><span class="line">Vue.delete( target, key )</span><br></pre></td></tr></table></figure><h3 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h3><p> methods 同 computed效果上是一样的，但 <strong>computed 是基于它的依赖缓存，只有相关依赖发生改变时才会重新取值</strong>。而使用 methods ，在重新渲染的时候，函数总会重新调用执行。所以<strong>使用 computed 性能会更好</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">  &lt;p&gt;原始字符串: &#123; &#123; message &#125; &#125;&lt;/p&gt;</span><br><span class="line">  &lt;p&gt;计算后反转字符串: &#123; &#123; reversedMessage &#125; &#125;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"> </span><br><span class="line">&lt;script&gt;</span><br><span class="line">var vm = new Vue(&#123;</span><br><span class="line">  el: &apos;#app&apos;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: &apos;Runoob!&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    // 计算属性的 getter</span><br><span class="line">    reversedMessage: function () &#123;</span><br><span class="line">      // `this` 指向 vm 实例</span><br><span class="line">      return this.message.split(&apos;&apos;).reverse().join(&apos;&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  methods: &#123;     // methods 与 computed效果一样，但是computed只有数据发生变化时才会执行</span><br><span class="line">    reversedMessage2: function () &#123;</span><br><span class="line">      return this.message.split(&apos;&apos;).reverse().join(&apos;&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>getter与setter方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    name: <span class="string">'Google'</span>,</span><br><span class="line">    url: <span class="string">'http://www.google.com'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    site: &#123;</span><br><span class="line">      <span class="comment">// getter 如果只要getter方法时可直接写方法体，不要get</span></span><br><span class="line">      <span class="keyword">get</span>: function () &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name + <span class="string">' '</span> + <span class="keyword">this</span>.url</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// setter</span></span><br><span class="line">      <span class="keyword">set</span>: function (newValue) &#123;</span><br><span class="line">        <span class="keyword">var</span> names = newValue.split(<span class="string">' '</span>)</span><br><span class="line">        <span class="keyword">this</span>.name = names[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">this</span>.url = names[names.length - <span class="number">1</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="监听属性"><a href="#监听属性" class="headerlink" title="监听属性"></a>监听属性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id = &quot;app&quot;&gt;</span><br><span class="line">    &lt;p style = &quot;font-size:25px;&quot;&gt;计数器: &#123; &#123; counter &#125; &#125;&lt;/p&gt;</span><br><span class="line">    &lt;button @click = &quot;counter++&quot; style = &quot;font-size:25px;&quot;&gt;点我&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script type = &quot;text/javascript&quot;&gt;</span><br><span class="line">    var vm = new Vue(&#123;</span><br><span class="line">        el: &apos;#app&apos;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            counter: 1</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    vm.$watch(&apos;counter&apos;, function(nval, oval) &#123;</span><br><span class="line">        alert(&apos;计数器值的变化 :&apos; + oval + &apos; 变为 &apos; + nval + &apos;!&apos;);</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h1 id="Vue模板"><a href="#Vue模板" class="headerlink" title="Vue模板"></a>Vue模板</h1><h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><p><strong>指令是带有 v- 前缀的特殊属性</strong></p><div class="table-container"><table><thead><tr><th>类型</th><th>语法</th><th>示例</th></tr></thead><tbody><tr><td>插文本值</td><td><code>{ {message} }</code></td><td><code>&lt;p&gt;{ { message } }&lt;/p&gt;</code></td></tr><tr><td>HTML指令值</td><td><code>v-html</code></td><td><code>&lt;div v-html=&quot;msg&quot;&gt;&lt;/div&gt;</code></td></tr><tr><td>属性指令</td><td><code>v-bind</code>（可缩写为<code>:class</code>）</td><td><code>&lt;div v-bind:class=&quot;{&#39;class1&#39;: use}&quot;&gt;&lt;/div&gt;</code></td></tr><tr><td>条件指令</td><td><code>v-if</code><br><code>v-else</code><br><code>v-else-if</code><br><code>v-show</code>根据条件展示</td><td><code>&lt;div v-if=&quot;type === &#39;A&#39;&quot;&gt; A &lt;/div&gt;</code><br><code>&lt;div v-else-if=&quot;type === &#39;B&#39;&quot;&gt; B &lt;/div&gt;</code>  <br> <code>&lt;div v-else&gt; C &lt;/div&gt;</code><br><code>&lt;h1 v-show=&quot;ok&quot;&gt; Hello! &lt;/h1&gt;</code></td></tr><tr><td>循环指令</td><td><code>v-for</code></td><td><code>&lt;li v-for=&quot;site in sites&quot;&gt; { { site.name } } &lt;/li&gt;</code><br><code>&lt;li v-for=&quot;(v, k) in object&quot;&gt; { { k } } : { { v } } &lt;/li&gt;</code><br><code>&lt;li v-for=&quot;(v, k, i) in object&quot;&gt; { { i } } . { { k } } : { { v} } &lt;/li&gt;</code></td></tr><tr><td>用户输入双向绑定</td><td><code>v-model</code>双向绑定</td><td><code>&lt;input v-model=&quot;message&quot;&gt;</code></td></tr><tr><td>事件处理器指令</td><td><code>v-on</code></td><td><code>&lt;button v-on:click=&quot;reverseMessage&quot;&gt;反转&lt;/button&gt;</code></td></tr><tr><td>修饰符</td><td>以半角句号<code>.</code>指明的特殊后缀</td><td><code>&lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt;</code></td></tr></tbody></table></div><h3 id="文本"><a href="#文本" class="headerlink" title="文本 { { } }"></a>文本 { { } }</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;   </span><br><span class="line">&lt;p&gt;&#123; &#123; message &#125; &#125;&lt;/p&gt; </span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><h3 id="HTML-v-html"><a href="#HTML-v-html" class="headerlink" title="HTML v-html"></a>HTML v-html</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;div v-html=&quot;message&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">    </span><br><span class="line">&lt;script&gt;</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &apos;#app&apos;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: &apos;&lt;h1&gt;hello&lt;/h1&gt;&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="属性-V-bind"><a href="#属性-V-bind" class="headerlink" title="属性 V-bind"></a>属性 V-bind</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;   </span><br><span class="line">    &lt;label for=&quot;r1&quot;&gt;修改颜色&lt;/label&gt;</span><br><span class="line">    &lt;!--单值形式--&gt;</span><br><span class="line">    &lt;div v-bind:class=&quot;&#123;&apos;class1&apos;: use &#125;&quot;&gt;      </span><br><span class="line">    &lt;/div&gt; </span><br><span class="line">    &lt;!--数组形式--&gt;</span><br><span class="line">    &lt;div v-bind:class=&quot;[activeClass, errorClass]&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;!--内联样式绑定--&gt;</span><br><span class="line">    &lt;div v-bind:style=&quot;[baseStyles, overridingStyles]&quot;&gt;   &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;      </span><br><span class="line">&lt;script&gt; </span><br><span class="line">    new Vue(&#123;     </span><br><span class="line">        el: &apos;#app&apos;,   </span><br><span class="line">        data:&#123;       </span><br><span class="line">            use: false   </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;); </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="事件处理指令-v-on"><a href="#事件处理指令-v-on" class="headerlink" title="事件处理指令 v-on"></a>事件处理指令 v-on</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">  &lt;button v-on:click=&quot;counter += 1&quot;&gt;增加 1&lt;/button&gt;</span><br><span class="line">  &lt;p&gt;这个按钮被点击了 &#123; &#123; counter &#125; &#125; 次。&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"> </span><br><span class="line">&lt;script&gt;</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &apos;#app&apos;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    counter: 0</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h4><p>Vue.js 为 v-on 提供了事件修饰符来处理 DOM 事件细节，通过由点(<code>.</code>)表示的指令后缀来调用修饰符。</p><ul><li><code>.stop</code></li><li><code>.prevent</code></li><li><code>.capture</code></li><li><code>.self</code></li><li><code>.once</code></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 阻止单击事件冒泡 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click.stop</span>=<span class="string">"doThis"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 提交事件不再重载页面 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">v-on:submit.prevent</span>=<span class="string">"onSubmit"</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 修饰符可以串联  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click.stop.prevent</span>=<span class="string">"doThat"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 只有修饰符 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">v-on:submit.prevent</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 添加事件侦听器时使用事件捕获模式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:click.capture</span>=<span class="string">"doThis"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 只当事件在该元素本身（而不是子元素）触发时触发回调 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:click.self</span>=<span class="string">"doThat"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- click 事件只能点击一次，2.1.4版本新增 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click.once</span>=<span class="string">"doThis"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="按钮修饰符"><a href="#按钮修饰符" class="headerlink" title="按钮修饰符"></a>按钮修饰符</h4><p>Vue 允许为 v-on 在监听键盘事件时添加按键修饰符</p><ul><li><code>.enter</code></li><li><code>.tab</code></li><li><p><code>.delete</code> (捕获 “删除” 和 “退格” 键)</p></li><li><p><code>.esc</code></p></li><li><p><code>.space</code></p></li><li><p><code>.up</code></p></li><li><p><code>.down</code></p></li><li><p><code>.left</code></p></li><li><p><code>.right</code></p></li><li><p><code>.ctrl</code></p></li><li><p><code>.alt</code></p></li><li><p><code>.shift</code></p></li><li><p><code>.meta</code></p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 同上 --&gt;</span><br><span class="line">&lt;input v-on:keyup.enter=&quot;submit&quot;&gt;</span><br><span class="line">&lt;!-- 缩写语法 --&gt;</span><br><span class="line">&lt;input @keyup.enter=&quot;submit&quot;&gt;</span><br></pre></td></tr></table></figure><h3 id="表单双向绑定-v-model"><a href="#表单双向绑定-v-model" class="headerlink" title="表单双向绑定 v-model"></a>表单双向绑定 v-model</h3><p><img alt="双向绑定" data-src="//orangesching.github.io/2020/08/19/前端框架/Vue/Vue入门/双向绑定.png" class="lazyload"></p><p>以下是对不同DOM元素的绑定</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;!-- 文本输入框用单个变量绑定 --&gt;</span><br><span class="line">    &lt;input v-model=&quot;message&quot; placeholder=&quot;编辑我……&quot;&gt;</span><br><span class="line">    &lt;p&gt;消息是: &#123; &#123; message &#125; &#125;&lt;/p&gt;</span><br><span class="line">    &lt;textarea v-model=&quot;message2&quot; placeholder=&quot;多行文本输入……&quot;&gt;&lt;/textarea&gt;</span><br><span class="line">    &lt;p&gt;&#123; &#123; message2 &#125; &#125;&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 单个复选框用单个变量绑定 --&gt;</span><br><span class="line">    &lt;input type=&quot;checkbox&quot; id=&quot;checkbox&quot; v-model=&quot;checked&quot;&gt;</span><br><span class="line">    &lt;label&gt;&#123; &#123; checked &#125; &#125;&lt;/label&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 多个复选框用数组绑定 --&gt;</span><br><span class="line">    &lt;input type=&quot;checkbox&quot; id=&quot;baidu&quot; value=&quot;Baidu&quot; v-model=&quot;checkedNames&quot;&gt;</span><br><span class="line">    &lt;label&gt;Runoob&lt;/label&gt;</span><br><span class="line">    &lt;input type=&quot;checkbox&quot; id=&quot;google&quot; value=&quot;Google&quot; v-model=&quot;checkedNames&quot;&gt;</span><br><span class="line">    &lt;label&gt;Google&lt;/label&gt;</span><br><span class="line">    &lt;input type=&quot;checkbox&quot; id=&quot;taobao&quot; value=&quot;Taobao&quot; v-model=&quot;checkedNames&quot;&gt;</span><br><span class="line">    &lt;label&gt;taobao&lt;/label&gt;</span><br><span class="line">    &lt;span&gt;&#123; &#123; checkedNames &#125; &#125;&lt;/span&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;!--单选框用单个变量绑定--&gt;</span><br><span class="line">    &lt;input type=&quot;radio&quot; id=&quot;baidu&quot; value=&quot;Baidu&quot; v-model=&quot;picked&quot;&gt;</span><br><span class="line">  &lt;label for=&quot;baidu&quot;&gt;baidu&lt;/label&gt;</span><br><span class="line">  &lt;input type=&quot;radio&quot; id=&quot;google&quot; value=&quot;Google&quot; v-model=&quot;picked&quot;&gt;</span><br><span class="line">  &lt;label for=&quot;google&quot;&gt;Google&lt;/label&gt;</span><br><span class="line">  &lt;span&gt;&#123; &#123; picked &#125; &#125;&lt;/span&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;!--select用单个变量绑定--&gt;</span><br><span class="line">    &lt;select v-model=&quot;selected&quot; name=&quot;fruit&quot;&gt;</span><br><span class="line">        &lt;option value=&quot;&quot;&gt;选择一个网站&lt;/option&gt;</span><br><span class="line">        &lt;option value=&quot;www.baidu.com&quot;&gt;Baidu&lt;/option&gt;</span><br><span class="line">        &lt;option value=&quot;www.google.com&quot;&gt;Google&lt;/option&gt;</span><br><span class="line">  &lt;/select&gt;</span><br><span class="line">    &lt;span&gt;&#123; &#123; selected &#125; &#125;&lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    new Vue(&#123;</span><br><span class="line">      el: &apos;#app&apos;,</span><br><span class="line">      data: &#123;</span><br><span class="line">        message: &apos;hello&apos;,</span><br><span class="line">        message2: &apos;orange&apos;</span><br><span class="line">        checked : false,</span><br><span class="line">        checkedNames: []</span><br><span class="line">        picked : &apos;baidu&apos;</span><br><span class="line">        selected: &apos;&apos; </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h4><p>在默认情况下， v-model 在 input 事件中同步输入框的值与数据（即边input框输入数据发生改变时就会触发）</p><p><strong><code>.lazy</code></strong></p><p>添加<code>lazy</code>修饰符 后 ，将把 <code>oninput</code> 事件改成 <code>onchange</code> 事件（即全部输入完成焦点不在input框上时触发）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在 "change" 而不是 "input" 事件中更新 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model.lazy</span>=<span class="string">"msg"</span> &gt;</span></span><br></pre></td></tr></table></figure><p><strong><code>.number</code></strong></p><p>如果想自动将用户的输入值转为 Number 类型（如果原值的转换结果为 NaN 则返回原值），可以添加一个修饰符 <code>number</code> 给 <code>v-model</code>来处理输入值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-model.number=&quot;age&quot; type=&quot;number&quot;&gt;&lt;!--输入123aaa age的值为123； 输入为aaa123 age的值为123aaa---&gt;</span><br></pre></td></tr></table></figure><blockquote><p>需要注意的是，如果输入的第一个字是字符串，那<code>number</code>修饰符就不会生效，会返回原值<br>输入的第一个只能是数字或者小数点或者是正负号</p></blockquote><p><strong><code>.trim</code></strong></p><p>如果要自动过滤用户输入的首尾空格，可以添加 trim 修饰符到 v-model 上过滤输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-model.trim=&quot;msg&quot;&gt;</span><br></pre></td></tr></table></figure><h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h2><p>Vue提供完全的 JS 表达式支持</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;     </span><br><span class="line">    &#123; &#123;5+5&#125; &#125;&lt;br&gt;     </span><br><span class="line">    &#123; &#123; ok ? &apos;YES&apos; : &apos;NO&apos; &#125; &#125;&lt;br&gt;     </span><br><span class="line">    &#123; &#123; message.split(&apos;&apos;).reverse().join(&apos;&apos;) &#125; &#125;     </span><br><span class="line">    &lt;div v-bind:id=&quot;&apos;list-&apos; + id&quot;&gt;helloWorld&lt;/div&gt; </span><br><span class="line">&lt;/div&gt;      </span><br><span class="line">&lt;script&gt; </span><br><span class="line">    new Vue(&#123;   </span><br><span class="line">        el: &apos;#app&apos;,   </span><br><span class="line">        data: &#123;     </span><br><span class="line">            ok: true,     </span><br><span class="line">            message: &apos;hello&apos;,     </span><br><span class="line">            id : 1   </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;) </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><p>过滤器是 JavaScript 函数，可自定义，被用作一些常见的文本格式化。由”管道符”指示, 用法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 过滤器函数接受表达式的值作为第一个参数 --&gt;</span><br><span class="line">&#123; &#123; message | capitalize &#125; &#125;</span><br><span class="line">&lt;!-- 可串联 --&gt;</span><br><span class="line">&#123; &#123; message | filterA | filterB &#125; &#125;</span><br><span class="line">&lt;!--可接受参数,message 是第一个参数，字符串 &apos;arg1&apos; 将传给过滤器作为第二个参数， arg2 表达式的值将被求值然后传给过滤器作为第三个参数--&gt;</span><br><span class="line">&#123; &#123; message | filterA(&apos;arg1&apos;, arg2) &#125; &#125;</span><br><span class="line">&lt;!-- 在 v-bind 指令中 --&gt;</span><br><span class="line">&lt;div v-bind:id=&quot;rawId | formatId&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>以下实例对输入的字符串第一个字母转为大写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;   </span><br><span class="line">    &#123; &#123; message | capitalize &#125; &#125; </span><br><span class="line">&lt;/div&gt;      </span><br><span class="line">&lt;script&gt; </span><br><span class="line">    new Vue(&#123;</span><br><span class="line">        el: &apos;#app&apos;,   </span><br><span class="line">        data: &#123;     </span><br><span class="line">            message: &apos;hello&apos;   </span><br><span class="line">        &#125;,   </span><br><span class="line">        filters: &#123;     </span><br><span class="line">            capitalize: function (value) &#123;       </span><br><span class="line">                if (!value) </span><br><span class="line">                    return &apos;&apos;       </span><br><span class="line">                value = value.toString()       </span><br><span class="line">                return value.charAt(0).toUpperCase() + value.slice(1)     </span><br><span class="line">            &#125;   </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;) </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h1 id="Vue-组件"><a href="#Vue-组件" class="headerlink" title="Vue 组件"></a>Vue 组件</h1><h2 id="组件是什么"><a href="#组件是什么" class="headerlink" title="组件是什么"></a>组件是什么</h2><p>组件封装了HTML代码，可扩展 HTML 元素。</p><p>组件系统让我们可以用独立可复用的小组件来构建大型应用，几乎任意类型的应用的界面都可以抽象为一个组件树</p><p><img alt="组件示意图" data-src="//orangesching.github.io/2020/08/19/前端框架/Vue/Vue入门/组件示意图.png" class="lazyload"></p><h2 id="定义组件"><a href="#定义组件" class="headerlink" title="定义组件"></a>定义组件</h2><p>全局组件使用<code>Vue.component</code>创建，可以用在任何新创建的vue根实例(<code>new Vue</code>)中。全局组件必须写在根实例的前面才会生效。局部组件可以减少无谓的JS下载，但局部组件默认不能在子组件中调用</p><h3 id="全局组件"><a href="#全局组件" class="headerlink" title="全局组件"></a>全局组件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;orange&gt;&lt;/orange&gt;  &lt;!--调用组件--&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"> </span><br><span class="line">&lt;script&gt;</span><br><span class="line">// 注册</span><br><span class="line">Vue.component(&apos;orange&apos;, &#123;</span><br><span class="line">  template: &apos;&lt;h1&gt;自定义组件!&lt;/h1&gt;&apos;</span><br><span class="line">&#125;)</span><br><span class="line">// 创建根实例</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &apos;#app&apos;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="局部组件"><a href="#局部组件" class="headerlink" title="局部组件"></a>局部组件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;orange&gt;&lt;/orange&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"> </span><br><span class="line">&lt;script&gt;</span><br><span class="line">var orangeComponent = &#123;</span><br><span class="line">    template: &apos;&lt;h1&gt;自定义组件!&lt;/h1&gt;&apos;</span><br><span class="line">&#125;    </span><br><span class="line">    </span><br><span class="line">// 创建根实例</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &apos;#app&apos;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    // &lt;orange&gt; 将只在父模板可用</span><br><span class="line">    &apos;orange&apos;: orangeComponent</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="组件之间的数据传递"><a href="#组件之间的数据传递" class="headerlink" title="组件之间的数据传递"></a><h2 id="组件之间的数据传递">组件之间的数据传递</h2></h2><h3 id="父组件-gt-子组件-prop"><a href="#父组件-gt-子组件-prop" class="headerlink" title="父组件-&gt;子组件   prop"></a>父组件-&gt;子组件   prop</h3><h4 id="prop"><a href="#prop" class="headerlink" title="prop"></a>prop</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;     </span><br><span class="line">    &lt;child message=&quot;hello!&quot;&gt;&lt;/child&gt; </span><br><span class="line">&lt;/div&gt;   </span><br><span class="line">&lt;script&gt; </span><br><span class="line">    // 注册 </span><br><span class="line">    Vue.component(</span><br><span class="line">        &apos;child&apos;, &#123;   </span><br><span class="line">            // 声明 props   </span><br><span class="line">            props: [&apos;message&apos;],   // 同样也可以在 vm 实例中像 &quot;this.message&quot; 这样使用   </span><br><span class="line">            template: &apos;&lt;span&gt;&#123; &#123; message &#125; &#125;&lt;/span&gt;&apos; </span><br><span class="line">    &#125;) </span><br><span class="line">    // 创建根实例 </span><br><span class="line">    new Vue(&#123;   el: &apos;#app&apos; &#125;) </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="动态-Prop"><a href="#动态-Prop" class="headerlink" title="动态 Prop"></a>动态 Prop</h4><p>可以用 v-bind 动态绑定 props 的值到父组件的数据中。每当父组件的数据变化时，该变化也会传导给子组件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;input v-model=&quot;parentMsg&quot;&gt;</span><br><span class="line">      &lt;br&gt;</span><br><span class="line">      &lt;child v-bind:message=&quot;parentMsg&quot;&gt;&lt;/child&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"> </span><br><span class="line">&lt;script&gt;</span><br><span class="line">// 注册</span><br><span class="line">Vue.component(&apos;child&apos;, &#123;</span><br><span class="line">  // 声明 props</span><br><span class="line">  props: [&apos;message&apos;],</span><br><span class="line">  // 同样也可以在 vm 实例中像 &quot;this.message&quot; 这样使用</span><br><span class="line">  template: &apos;&lt;span&gt;&#123; &#123; message &#125; &#125;&lt;/span&gt;&apos;</span><br><span class="line">&#125;)</span><br><span class="line">// 创建根实例</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &apos;#app&apos;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    parentMsg: &apos;父组件内容&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="prop的验证"><a href="#prop的验证" class="headerlink" title="prop的验证"></a>prop的验证</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'my-component'</span>, &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    <span class="comment">// 基础的类型检查 (`null` 和 `undefined` 会通过任何类型验证)</span></span><br><span class="line">    propA: <span class="built_in">Number</span>,</span><br><span class="line">    <span class="comment">// 多个可能的类型</span></span><br><span class="line">    propB: [<span class="built_in">String</span>, <span class="built_in">Number</span>],</span><br><span class="line">    <span class="comment">// 必填的字符串</span></span><br><span class="line">    propC: &#123;</span><br><span class="line">      type: <span class="built_in">String</span>,</span><br><span class="line">      required: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 带有默认值的数字</span></span><br><span class="line">    propD: &#123;</span><br><span class="line">      type: <span class="built_in">Number</span>,</span><br><span class="line">      <span class="keyword">default</span>: <span class="number">100</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 带有默认值的对象</span></span><br><span class="line">    propE: &#123;</span><br><span class="line">      type: <span class="built_in">Object</span>,</span><br><span class="line">      <span class="comment">// 对象或数组默认值必须从一个工厂函数获取</span></span><br><span class="line">      <span class="keyword">default</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">message</span>: <span class="string">'hello'</span> &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 自定义验证函数</span></span><br><span class="line">    propF: &#123;</span><br><span class="line">      validator: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 这个值必须匹配下列字符串中的一个</span></span><br><span class="line">        <span class="keyword">return</span> [<span class="string">'success'</span>, <span class="string">'warning'</span>, <span class="string">'danger'</span>].indexOf(value) !== <span class="number">-1</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="子组件-gt-父组件-自定义事件"><a href="#子组件-gt-父组件-自定义事件" class="headerlink" title="子组件-&gt;父组件  自定义事件"></a>子组件-&gt;父组件  自定义事件</h3><p>父组件是使用 props 传递数据给子组件，但如果子组件要把数据传递回去，就需要使用自定义事件！</p><p>我们可以使用 v-on 绑定自定义事件, 每个 Vue 实例都实现了事件接口(Events interface)，即：</p><ul><li>使用 <code>$on(eventName)</code> 监听事件</li><li>使用 <code>$emit(eventName)</code> 触发事件</li></ul><p>另外，父组件可以在使用子组件的地方直接用 v-on 来监听子组件触发的事件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;div id=&quot;counter-event-example&quot;&gt;</span><br><span class="line">      &lt;p&gt;&#123; &#123; total &#125; &#125;&lt;/p&gt;</span><br><span class="line">      &lt;button-counter v-on:increment=&quot;incrementTotal&quot;&gt;&lt;/button-counter&gt;</span><br><span class="line">      &lt;button-counter v-on:increment=&quot;incrementTotal&quot;&gt;&lt;/button-counter&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"> </span><br><span class="line">&lt;script&gt;</span><br><span class="line">Vue.component(&apos;button-counter&apos;, &#123;</span><br><span class="line">  template: &apos;&lt;button v-on:click=&quot;incrementHandler&quot;&gt;&#123; &#123; counter &#125; &#125;&lt;/button&gt;&apos;,</span><br><span class="line">  data: function () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      counter: 0</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    incrementHandler: function () &#123;</span><br><span class="line">      this.counter += 1</span><br><span class="line">      this.$emit(&apos;increment&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &apos;#counter-event-example&apos;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    total: 0</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    incrementTotal: function () &#123;</span><br><span class="line">      this.total += 1</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h1 id="Vue-Ajax-axios"><a href="#Vue-Ajax-axios" class="headerlink" title="Vue Ajax(axios)"></a>Vue Ajax(axios)</h1><h2 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      info: <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted () &#123;</span><br><span class="line">    axios</span><br><span class="line">      .get(<span class="string">'https://www.runoob.com/try/ajax/json_demo.json'</span>)</span><br><span class="line">      .then(<span class="function"><span class="params">response</span> =&gt;</span> (<span class="keyword">this</span>.info = response))</span><br><span class="line">      .catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123; <span class="comment">// 请求失败处理</span></span><br><span class="line">        <span class="built_in">console</span>.log(error);</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>传递参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接在 URL 上添加参数 ID=12345</span></span><br><span class="line">axios.get(<span class="string">'/user?ID=12345'</span>)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">  &#125;);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 也可以通过 params 设置参数：</span></span><br><span class="line">axios.get(<span class="string">'/user'</span>, &#123;</span><br><span class="line">    params: &#123;</span><br><span class="line">      ID: <span class="number">12345</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h2 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      info: <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted () &#123;</span><br><span class="line">    axios</span><br><span class="line">      .post(<span class="string">'https://www.runoob.com/try/ajax/demo_axios_post.php'</span>)</span><br><span class="line">      .then(<span class="function"><span class="params">response</span> =&gt;</span> (<span class="keyword">this</span>.info = response))</span><br><span class="line">      .catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123; <span class="comment">// 请求失败处理</span></span><br><span class="line">        <span class="built_in">console</span>.log(error);</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>传递参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">axios.post(<span class="string">'/user'</span>, &#123;</span><br><span class="line">    firstName: <span class="string">'Fred'</span>,        <span class="comment">// 参数 firstName</span></span><br><span class="line">    lastName: <span class="string">'Flintstone'</span>    <span class="comment">// 参数 lastName</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">axios.request(config)</span><br><span class="line">axios.get(url[, config])</span><br><span class="line">axios.delete(url[, config])</span><br><span class="line">axios.head(url[, config])</span><br><span class="line">axios.post(url[, data[, config]])</span><br><span class="line">axios.put(url[, data[, config]])</span><br><span class="line">axios.patch(url[, data[, config]])</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端框架 </category>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jave8骚操作</title>
      <link href="/2020/08/18/Java/Java%E5%89%8D%E6%B2%BF%E6%8A%80%E6%9C%AF/Java8%E9%AA%9A%E6%93%8D%E4%BD%9C/"/>
      <url>/2020/08/18/Java/Java%E5%89%8D%E6%B2%BF%E6%8A%80%E6%9C%AF/Java8%E9%AA%9A%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h1><h2 id="lambda表达式是什么"><a href="#lambda表达式是什么" class="headerlink" title="lambda表达式是什么"></a>lambda表达式是什么</h2><blockquote><p><strong>为什么需要Lambda表达式?</strong></p><p>在Java8之前，一个方法能接收的参数都是变量，如果你想传递一段代码（动作/方法）到另一个方法里，你需要构建一个属于某个类的对象，由它的某个方法来放置你想传递的代码块。这种方式很不方便</p></blockquote><p>lambda表达式允许函数作为一个方法的参数。lambda表达式其实完成了定义接口并且实现接口里的方法这一功能，也可以认为lambda表达式代表一种动作，可以直接传递这种特殊的动作。</p><h2 id="lambda表达式的语法"><a href="#lambda表达式的语法" class="headerlink" title="lambda表达式的语法"></a>lambda表达式的语法</h2><p><code>(parameters) -&gt; expression</code></p><p><code>(parameters) -&gt;{ statements; }</code> </p><p> <code>parameter -&gt; expression</code></p><p><code>parameter -&gt;{ statements; }</code></p><ul><li><strong>可选类型声明：</strong>不需要声明参数类型，编译器可以统一识别参数值。</li><li><strong>可选的参数圆括号：</strong>一个参数无需定义圆括号，但多个参数需要定义圆括号。</li><li><strong>可选的大括号：</strong>如果主体包含了一个语句，就不需要使用大括号。</li><li><strong>可选的返回关键字：</strong>如果主体只有一个表达式返回值则编译器会自动返回值，大括号需要指定明表达式返回了一个数值。</li></ul><h2 id="有无lambda对比"><a href="#有无lambda对比" class="headerlink" title="有无lambda对比"></a>有无lambda对比</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无lambda表达式版，为了开启新的线程创建了myThread</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> </span>&#123;    </span><br><span class="line">myThread t = <span class="keyword">new</span> myThread(); </span><br><span class="line">&#125; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;    </span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"放入你想执行的代码"</span>);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// lambda表达式版，无需创建新的类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"这是一个线程"</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h2><h3 id="使用lambda表达式对列表进行迭代"><a href="#使用lambda表达式对列表进行迭代" class="headerlink" title="使用lambda表达式对列表进行迭代"></a>使用lambda表达式对列表进行迭代</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java 8之前：</span></span><br><span class="line">List features = Arrays.asList(<span class="string">"Lambdas"</span>, <span class="string">"Default Method"</span>, <span class="string">"Stream API"</span>, <span class="string">"Date and Time API"</span>);</span><br><span class="line"><span class="keyword">for</span> (String feature : features) &#123;</span><br><span class="line">    System.out.println(feature);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Java 8之后：</span></span><br><span class="line">List features = Arrays.asList(<span class="string">"Lambdas"</span>, <span class="string">"Default Method"</span>, <span class="string">"Stream API"</span>, <span class="string">"Date and Time API"</span>);</span><br><span class="line">features.forEach(n -&gt; System.out.println(n));</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 使用Java 8的方法引用更方便，方法引用由::双冒号操作符标示</span></span><br><span class="line">features.forEach(System.out::println);</span><br></pre></td></tr></table></figure><h3 id="使用lambda表达式替代匿名内部类"><a href="#使用lambda表达式替代匿名内部类" class="headerlink" title="使用lambda表达式替代匿名内部类"></a>使用lambda表达式替代匿名内部类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java 8之前：</span></span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Before Java8, too much code for too little to do"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="comment">//Java 8方式：使用()-&gt;&#123;&#125;替代了匿名内部类</span></span><br><span class="line"><span class="keyword">new</span> Thread( () -&gt; System.out.println(<span class="string">"In Java8, Lambda expression rocks !!"</span>) ).start();</span><br></pre></td></tr></table></figure><h3 id="使用lambda表达式的Map和Reduce示例"><a href="#使用lambda表达式的Map和Reduce示例" class="headerlink" title="使用lambda表达式的Map和Reduce示例"></a>使用lambda表达式的Map和Reduce示例</h3><p>map允许将对象进行转换。例如在本例中，我们将 costBeforeTax 列表的每个元素转换成为税后的值。将lambda表达式传到 map() 方法，后者将其应用到流中的每一个元素。然后用 forEach() 将列表元素打印出来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不使用lambda表达式为每个订单加上12%的税</span></span><br><span class="line">List costBeforeTax = Arrays.asList(<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>, <span class="number">400</span>, <span class="number">500</span>);</span><br><span class="line"><span class="keyword">for</span> (Integer cost : costBeforeTax) &#123;</span><br><span class="line">    <span class="keyword">double</span> price = cost + .<span class="number">12</span>*cost;</span><br><span class="line">    System.out.println(price);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 使用lambda表达式</span></span><br><span class="line">List costBeforeTax = Arrays.asList(<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>, <span class="number">400</span>, <span class="number">500</span>);</span><br><span class="line">costBeforeTax.stream().map((cost) -&gt; cost + .<span class="number">12</span>*cost).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不使用lambda表达式为每个订单加上12%的税并计算总价</span></span><br><span class="line">List costBeforeTax = Arrays.asList(<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>, <span class="number">400</span>, <span class="number">500</span>);</span><br><span class="line"><span class="keyword">double</span> total = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (Integer cost : costBeforeTax) &#123;</span><br><span class="line">    <span class="keyword">double</span> price = cost + .<span class="number">12</span>*cost;</span><br><span class="line">    total = total + price;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"Total : "</span> + total);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 使用lambda表达式</span></span><br><span class="line">List costBeforeTax = Arrays.asList(<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>, <span class="number">400</span>, <span class="number">500</span>);</span><br><span class="line"><span class="keyword">double</span> bill = costBeforeTax.stream().map((cost) -&gt; cost + .<span class="number">12</span>*cost).reduce((sum, cost) -&gt; sum + cost).get();</span><br><span class="line">System.out.println(<span class="string">"Total : "</span> + bill);</span><br></pre></td></tr></table></figure><h3 id="复制不同的值，创建一个子列表"><a href="#复制不同的值，创建一个子列表" class="headerlink" title="复制不同的值，创建一个子列表"></a>复制不同的值，创建一个子列表</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用所有不同的数字创建一个正方形列表</span></span><br><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">9</span>, <span class="number">10</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">List&lt;Integer&gt; distinct = numbers.stream().map( i -&gt; i*i).distinct().collect(Collectors.toList());</span><br><span class="line">System.out.printf(<span class="string">"Original List : %s,  Square Without duplicates : %s %n"</span>, numbers, distinct);</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总的来说，所有的lambda表达式都是延迟执行的，如果你希望立即执行一段代码，那就没必要使用lambda表达式了，延迟执行代码的原因有很多种：</p><ul><li>在另一个线程中运行代码</li><li>多次运行代码</li><li>在某个算法的正确时间点上运行代码（如排序中的比较逻辑）</li><li>某些条件触发时运行代码（数据到达，接口回调等）</li></ul><h1 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>函数式接口(Functional Interface)就是一个有且仅有一个抽象方法，但是可以有多个非抽象方法的接口。<br>Java中的函数式编程体现就是Lambda表达式，所以函数式接口就是可以适用于Lambda使用的接口。如果方法的参数是一个函数式接口， 我们可以使用 lambda表达式作为参数传递</p><p>函数式接口都用@FunctionalInterface注解进行标注了，当一个接口打上@FunctionalInterface注解之后就声明为一个函数式接口，这个接口中就只能有一个抽象方法，大于一个抽象方法就会报错。</p><p><strong>如何检测一个接口是不是函数式接口</strong><br>@Functionallnterface放在接口定义的上方:如果接口是函数式接口，编译通过;如果不是,编译失败</p><p>自己定义 函数式接口的时候，@Functionallnterface是可选的， 就算我不写这个注解，只要保证满足函数式接口定<br>义的条件，也照样是函数式接口。但是,建议加上该注解</p><h2 id="常用的四个内置函数式接口"><a href="#常用的四个内置函数式接口" class="headerlink" title="常用的四个内置函数式接口"></a>常用的四个内置函数式接口</h2><p>Java 8在java.util.function包下预定义了大量的函数式接口供我们使用</p><div class="table-container"><table><thead><tr><th>接口名</th><th>描述</th><th></th></tr></thead><tbody><tr><td>Supplier</td><td><strong>供给型接口</strong><br>无参数，返回任意泛型值<br><code>T get()</code></td><td><code>Supplier&lt;String&gt; supplier=()-&gt;{return &quot;供给&quot;;}</code><br><code>System.out.println(supplier.get())</code></td></tr><tr><td>Consumer</td><td><strong>消费型接口</strong><br>一个参数，无返回值<br><code>void accept (T t)</code></td><td><code>Consumer&lt;String&gt; consumer = x-&gt;System.out.println(x);</code><br><code>consumer.accept(&quot;消费&quot;)</code></td></tr><tr><td>Predicate</td><td><strong>断言型接口</strong><br>用于做判断操作<br>一个参数，返回布尔值<br><code>boolean test(T t)</code></td><td><code>Predicate&lt;String&gt; p = (x)-&gt;{return x.contains(&quot;a&quot;)};</code><br><code>System.out.println(p.test(&quot;hha&quot;));</code></td></tr><tr><td>Function</td><td><strong>函数型接口</strong><br>一个参数，返回任意泛型值<br><code>R apply(T t)</code></td><td><code>Function&lt;String,Integer&gt; f=(x)-&gt;{return x.length();}</code><br><code>System.out.println(f.apply(&quot;haha&quot;))</code></td></tr></tbody></table></div><h1 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h1><p>Java 8 中的 Stream 是对集合（Collection）对象功能的增强，它专注于对集合对象进行各种非常便利、高效的聚合操作（aggregate operation），或者大批量数据操作 (bulk data operation)</p><h2 id="Stream相关定义"><a href="#Stream相关定义" class="headerlink" title="Stream相关定义"></a>Stream相关定义</h2><p>Stream 不是集合元素，它不是数据结构并不保存数据，它是有关算法和计算的。它更像一个高级版本的Iterator，单向，不可往复，数据只能遍历一次，遍历过一次后即用尽了，就好比流水从面前流过，一去不复返。</p><blockquote><p><strong>Iterator</strong></p><ul><li>只能显式地一个一个遍历元素并对其执行某些操作。 </li><li>只能命令式地、串行化操作</li></ul><p><strong>Stream</strong></p><ul><li>只要给出需要对其包含的元素执行什么操作，比如“获取每个字符串的首字母”等，Stream 会隐式地在内部进行遍历，做出相应的数据转换。</li><li>能并行化操作，使用并行去遍历时，数据会被分成多个段，其中每一个都在不同的线程中处理，然后将结果一起输出。（依赖于 Java7 中引入的 Fork/Join 框架来拆分任务和加速处理过程）</li></ul></blockquote><h4 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h4><p>什么是操作符呢？操作符就是对数据进行的一种处理工作，一道加工程序；就好像工厂的工人对流水线上的产品进行一道加工程序一样。</p><h2 id="Stream的使用"><a href="#Stream的使用" class="headerlink" title="Stream的使用"></a>Stream的使用</h2><p>当我们使用一个流的时候，通常包括三个基本步骤：</p><ol><li>获取一个数据源（source）</li><li>数据转换</li><li>执行操作获取想要的结果</li></ol><p>每次转换原有 Stream 对象不改变，返回一个新的 Stream 对象（可以有多次转换），这就允许对其操作可以像链条一样排列，变成一个管道</p><h2 id="生成Stream的方式"><a href="#生成Stream的方式" class="headerlink" title="生成Stream的方式"></a>生成Stream的方式</h2><ul><li>从Collection 和数组生成<br>  <code>Collection.stream()</code><br>  <code>Collection.parallelStream()</code><br>  <code>Arrays.stream(T array)</code><br>  <code>Stream.of(T t)</code></li><li>从 BufferedReader<br>  <code>java.io.BufferedReader.lines()</code></li><li>静态工厂<br>  <code>java.util.stream.IntStream.range()</code><br>  <code>java.nio.file.Files.walk()</code></li><li>自己构建<br>  <code>java.util.Spliterator</code></li><li>其它<br>  <code>Random.ints()</code><br>  <code>BitSet.stream()</code><br>  <code>Pattern.splitAsStream(java.lang.CharSequence)</code><br>  <code>JarFile.stream()</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、从Collection 和数组生成</span></span><br><span class="line">Stream stream = Stream.of(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>);</span><br><span class="line"></span><br><span class="line">String [] strArray = <span class="keyword">new</span> String[] &#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;;</span><br><span class="line">stream = Stream.of(strArray);</span><br><span class="line">stream = Arrays.stream(strArray);</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; list = Arrays.asList(strArray);</span><br><span class="line">stream = list.stream();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、数值流的构造</span></span><br><span class="line"><span class="comment">// 对于基本数值型，目前有三种对应的包装类型 Stream：IntStream、LongStream、DoubleStream</span></span><br><span class="line">IntStream.of(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;).forEach(System.out::println);</span><br><span class="line">IntStream.range(<span class="number">1</span>, <span class="number">3</span>).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 3、流转换为其他数据结构</span></span><br><span class="line">Stream&lt;String&gt; stream3 = Stream.of(<span class="keyword">new</span> String[]&#123;<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>&#125;);</span><br><span class="line">String str = stream3.collect(Collectors.joining());</span><br><span class="line">System.out.println(str);</span><br></pre></td></tr></table></figure><h2 id="Stream的使用-1"><a href="#Stream的使用-1" class="headerlink" title="Stream的使用"></a>Stream的使用</h2><h3 id="Stream的操作类型"><a href="#Stream的操作类型" class="headerlink" title="Stream的操作类型"></a>Stream的操作类型</h3><ul><li>中间操作(Intermediate Operation)：一个流可以后面跟随零个或多个 intermediate 操作。其目的主要是打开流，做出某种程度的数据映射/过滤，然后返回一个新的流，交给下一个操作使用。这类操作都是惰性化的（lazy），就是说，仅仅调用到这类方法，并没有真正开始流的遍历。</li><li>终止操作(Terminal Operation)：一个流只能有一个 terminal 操作，当这个操作执行后，流就被使用“光”了，无法再被操作。所以这必定是流的最后一个操作。Terminal 操作的执行，才会真正开始流的遍历，并且会生成一个结果。</li><li>无状态：指元素的处理不受之前元素的影响；</li><li>有状态：指该操作只有拿到所有元素之后才能继续下去。</li><li>非短路操作：指必须处理所有元素才能得到最终结果；</li><li>短路操作：指遇到某些符合条件的元素就可以得到最终结果，如 A || B，只要A为true，则无需判断B的结果。</li></ul><h3 id="中间操作"><a href="#中间操作" class="headerlink" title="中间操作"></a>中间操作</h3><div class="table-container"><table><thead><tr><th>操作</th><th>详情</th></tr></thead><tbody><tr><td><code>map(mapToInt,mapToLong,mapToDouble)</code></td><td>转换操作符，把比如A-&gt;B，这里默认提供了转int，long，double的操作符。</td></tr><tr><td><code>flatmap(flatmapToInt,flatmapToLong,flatmapToDouble)</code></td><td>拍平操作符，把 int[]{2,3,4} 拍平 变成 2，3，4 也就是从原来的一个数据变成了3个数据，这里默认提供了拍平成int,long,double的操作符。</td></tr><tr><td><code>limit(int n)</code></td><td>限流操作符，用于获取指定数量的流，比如数据流中有10个 我只要出前3个就可以使用。</td></tr><tr><td><code>distint</code></td><td>去重操作，对重复元素去重，底层使用了equals方法。</td></tr><tr><td><code>filter</code></td><td>过滤操作，把不想要的数据过滤。</td></tr><tr><td><code>peek</code></td><td>挑出操作，如果想对数据进行某些操作，如：读取、编辑修改等。</td></tr><tr><td><code>skip</code></td><td>跳过操作，跳过某些元素。</td></tr><tr><td><code>sorted(unordered)</code></td><td>排序操作，对元素排序，前提是实现Comparable接口，当然也可以自定义比较器。</td></tr></tbody></table></div><h3 id="结束操作"><a href="#结束操作" class="headerlink" title="结束操作"></a>结束操作</h3><div class="table-container"><table><thead><tr><th>操作</th><th>详情</th></tr></thead><tbody><tr><td><code>collect</code></td><td>收集操作，将所有数据收集起来，这个操作非常重要，官方的提供的Collectors 提供了非常多收集器，可以说Stream 的核心在于Collectors</td></tr><tr><td><code>count</code></td><td>统计操作，统计最终的数据个数</td></tr><tr><td><code>findFirst findAny</code></td><td>查找操作，查找第一个、查找任何一个 返回的类型为Optional</td></tr><tr><td><code>noneMatch allMatch anyMatch</code></td><td>匹配操作，数据流中是否存在符合条件的元素 返回值为bool 值</td></tr><tr><td><code>min max</code></td><td>最值操作，需要自定义比较器，返回数据流中最大最小的值</td></tr><tr><td><code>reduce</code></td><td>规约操作，将整个数据流的值规约为一个值，count、min、max底层就是使用reduce</td></tr><tr><td><code>forEach forEachOrdered</code></td><td>遍历操作，这里就是对最终的数据进行消费了</td></tr><tr><td><code>toArray</code></td><td>数组操作，将数据流的元素转换成数组</td></tr></tbody></table></div><h3 id="Stream的典型用法"><a href="#Stream的典型用法" class="headerlink" title="Stream的典型用法"></a>Stream的典型用法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">      <span class="comment">// 4、流的典型用法</span></span><br><span class="line">        <span class="comment">// 1&gt; map/flatMap</span></span><br><span class="line">        <span class="comment">// map 生成的是个 1:1 映射，每个输入元素，都按照规则转换成为另外一个元素</span></span><br><span class="line">        Stream&lt;String&gt; stream4 = Stream.of(<span class="keyword">new</span> String[]&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;);</span><br><span class="line">        stream4.map(String::toUpperCase).forEach(System.out::println);</span><br><span class="line">        <span class="comment">// 还有一些场景，是一对多映射关系的，这时需要 flatMap</span></span><br><span class="line">        Stream&lt;List&lt;Integer&gt;&gt; inputStream = Stream.of(</span><br><span class="line">                Arrays.asList(<span class="number">1</span>),</span><br><span class="line">                Arrays.asList(<span class="number">2</span>, <span class="number">3</span>),</span><br><span class="line">                Arrays.asList(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line">        );</span><br><span class="line"><span class="comment">//        Stream&lt;Integer&gt; mapStream = inputStream.map(List::size);</span></span><br><span class="line"><span class="comment">//        mapStream.forEach(System.out::println);</span></span><br><span class="line">        Stream&lt;Integer&gt; flatMapStream = inputStream.flatMap(Collection::stream);</span><br><span class="line">        flatMapStream.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2&gt; filter</span></span><br><span class="line">        <span class="comment">// filter 对原始 Stream 进行某项测试，通过测试的元素被留下来生成一个新 Stream</span></span><br><span class="line">        Integer[] nums = <span class="keyword">new</span> Integer[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">        Arrays.stream(nums).filter(n -&gt; n&lt;<span class="number">3</span>).forEach(System.out::println);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 3&gt; forEach</span></span><br><span class="line">        <span class="comment">// forEach 是 terminal 操作，因此它执行后，Stream 的元素就被“消费”掉了,无法对一个 Stream 进行两次terminal 运算</span></span><br><span class="line">        Stream stream13 = Arrays.stream(nums);</span><br><span class="line">        stream13.forEach(System.out::print);</span><br><span class="line"><span class="comment">//        stream13.forEach(System.out::print); // 上面forEach已经消费掉了，不能再调用</span></span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">// 具有相似功能的 intermediate 操作 peek 可以达到上述目的</span></span><br><span class="line">        Stream stream14 = Arrays.stream(nums);</span><br><span class="line">        stream14.peek(System.out::print)</span><br><span class="line">   .peek(System.out::print)</span><br><span class="line">              .collect(Collectors.toList());</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4&gt; reduce 主要作用是把 Stream 元素组合起来,字符串拼接、数值的 sum、min、max、average 都是特殊的 reduce</span></span><br><span class="line">        <span class="comment">// Stream 的 sum 就相当于：</span></span><br><span class="line">        Integer sum = Arrays.stream(nums).reduce(<span class="number">0</span>, (integer, integer2) -&gt; integer + integer2);</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">        <span class="comment">// 有初始值</span></span><br><span class="line">        Integer sum1 = Arrays.stream(nums).reduce(<span class="number">0</span>, Integer::sum);</span><br><span class="line">        <span class="comment">// 无初始值</span></span><br><span class="line">        Integer sum2 = Arrays.stream(nums).reduce(Integer::sum).get();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5&gt; limit/skip</span></span><br><span class="line">        <span class="comment">// limit 返回 Stream 的前面 n 个元素；skip 则是扔掉前 n 个元素。</span></span><br><span class="line">        Arrays.stream(nums).limit(<span class="number">3</span>).forEach(System.out::print);</span><br><span class="line">        System.out.println();</span><br><span class="line">        Arrays.stream(nums).skip(<span class="number">2</span>).forEach(System.out::print);</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6&gt; sorted</span></span><br><span class="line"><span class="comment">//        对 Stream 的排序通过 sorted 进行，它比数组的排序更强之处在于你可以首先对 Stream 进行各类 map、filter、</span></span><br><span class="line"><span class="comment">//        limit、skip 甚至 distinct 来减少元素数量后，再排序，这能帮助程序明显缩短执行时间。</span></span><br><span class="line">        Arrays.stream(nums).sorted((i1, i2) -&gt; i2.compareTo(i1)).limit(<span class="number">3</span>).forEach(System.out::print);</span><br><span class="line">        System.out.println();</span><br><span class="line">        Arrays.stream(nums).sorted((i1, i2) -&gt; i2.compareTo(i1)).skip(<span class="number">2</span>).forEach(System.out::print);</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7&gt; min/max/distinct</span></span><br><span class="line">        System.out.println(Arrays.stream(nums).min(Comparator.naturalOrder()).get());</span><br><span class="line">        System.out.println(Arrays.stream(nums).max(Comparator.naturalOrder()).get());</span><br><span class="line">        Arrays.stream(nums).distinct().forEach(System.out::print);</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 8&gt; Match</span></span><br><span class="line"><span class="comment">//        Stream 有三个 match 方法，从语义上说：</span></span><br><span class="line"><span class="comment">//        allMatch：Stream 中全部元素符合传入的 predicate，返回 true</span></span><br><span class="line"><span class="comment">//        anyMatch：Stream 中只要有一个元素符合传入的 predicate，返回 true</span></span><br><span class="line"><span class="comment">//        noneMatch：Stream 中没有一个元素符合传入的 predicate，返回 true</span></span><br><span class="line"><span class="comment">//        它们都不是要遍历全部元素才能返回结果。例如 allMatch 只要一个元素不满足条件，就 skip 剩下的所有元素，返回 false。</span></span><br><span class="line">        Integer[] nums1 = <span class="keyword">new</span> Integer[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line">        System.out.println(Arrays.stream(nums1).allMatch(integer -&gt; integer &lt; <span class="number">7</span>));</span><br><span class="line">        System.out.println(Arrays.stream(nums1).anyMatch(integer -&gt; integer &lt; <span class="number">2</span>));</span><br><span class="line">        System.out.println(Arrays.stream(nums1).noneMatch(integer -&gt; integer &lt; <span class="number">0</span>));</span><br></pre></td></tr></table></figure><h2 id="Stream总结"><a href="#Stream总结" class="headerlink" title="Stream总结"></a>Stream总结</h2><ol><li>不是数据结构，它没有内部存储，它只是用操作管道从 source（数据结构、数组、generator function、IO channel）抓取数据</li><li>它绝不修改自己所封装的底层数据结构的数据。例如 Stream 的 filter 操作会产生一个不包含被过滤元素的新 Stream，而不是从 source 删除那些元素</li><li>所有 Stream 的操作必须以 lambda 表达式为参数</li><li>惰性化，很多 Stream 操作是向后延迟的，一直到它弄清楚了最后需要多少数据才会开始，Intermediate操作永远是惰性化的</li><li>当一个 Stream 是并行化的，就不需要再写多线程代码，所有对它的操作会自动并行进行的</li></ol><h1 id="接口的默认方法"><a href="#接口的默认方法" class="headerlink" title="接口的默认方法"></a>接口的默认方法</h1><p>在接口中用<strong>default</strong>修饰的方法称为<strong>默认方法</strong>。<br>接口中的默认方法一定要有默认实现（方法体），接口实现者可以继承它，也可以覆盖它。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 接口的默认方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> s</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> String <span class="title">methodDefault</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"res--"</span> + s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在接口中用<strong>static</strong>修饰的方法称为<strong>静态方法</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 接口的静态方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> b</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> String <span class="title">methodStatic</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h1><div class="table-container"><table><thead><tr><th></th><th>引用方式</th><th>示例</th></tr></thead><tbody><tr><td>引用方法</td><td><code>实例对象::实例方法名</code><br><code>类名::静态方法名</code> <br><code>类名::实例方法名</code></td><td><code>Consumer&lt;String&gt; consumer1 = s -&gt; System.out.println(s);</code><br><code>Consumer&lt;String&gt; consumer2 = System.out::println;</code><br><code>consumer2.accept(&quot;呵呵&quot;);</code></td></tr><tr><td>引用构造方法</td><td><code>类名::new</code></td><td><code>Function&lt;Integer, StringBuffer&gt; fun = n -&gt; new StringBuffer(n);</code><br><code>Function&lt;Integer, StringBuffer&gt; fun = StringBuffer::new;</code></td></tr><tr><td>引用数组</td><td><code>类型[]::new</code></td><td><code>Function&lt;Integer, int[]&gt; fun = n -&gt; new int[n];</code><br><code>Function&lt;Integer, int[]&gt; fun1 = int[]::new;</code></td></tr></tbody></table></div><h1 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h1><p>Optional实际上是个容器：它可以保存类型T的值，或者仅仅保存null。</p><p>Optional提供很多有用的方法，这样我们就不用显式进行空值检测。</p><h2 id="创建Optional对象方法"><a href="#创建Optional对象方法" class="headerlink" title="创建Optional对象方法"></a>创建Optional对象方法</h2><ol><li><code>Optional.of(T value)</code>， 返回一个Optional对象，value不能为空，否则会出空指针异常</li><li><code>Optional.ofNullable(T value)</code>， 返回一个Optional对象，value可以为空</li><li><code>Optional.empty()</code>，代表空</li></ol><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><p>其他API:</p><ol><li><code>optional.isPresent()</code>，是否存在值（不为空）</li><li><code>optional.ifPresent(Consumer&lt;? super T&gt; consumer)</code>, 如果存在值则执行consumer</li><li><code>optional.get()</code>，获取value</li><li><code>optional.orElse(T other)</code>，如果没值则返回other</li><li><code>optional.orElseGet(Supplier&lt;? extends T&gt; other)</code>，如果没值则执行other并返回</li><li><code>optional.orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier)</code>，如果没值则执行<code>exceptionSupplier</code>，并抛出异常</li></ol><blockquote><p>使用 <code>Optional</code> 时尽量不直接调用 <code>Optional.get()</code>方法, <code>Optional.isPresent()</code> 更应该被视为一个私有方法, 应依赖于其他像 <code>Optional.orElse()</code>, <code>Optional.orElseGet()</code>, <code>Optional.map()</code>等这样的方法。</p></blockquote><p>高级API：</p><ol><li><code>optional.map(Function&lt;? super T, ? extends U&gt; mapper)</code>，映射，映射规则由<code>function</code>指定，返回映射值的<code>Optional</code>，所以可以继续使用<code>Optional</code>的API。</li><li><code>optional.flatMap(Function&lt;? super T, Optional&lt; U &gt; &gt; mapper)</code>，同<code>map</code>类似，区别在于<code>map</code>中获取的返回值自动被<code>Optional</code>包装，<code>flatMap</code>中返回值保持不变,但入参必须是Optional类型。</li><li><code>optional.filter(Predicate&lt;? super T&gt; predicate)</code>，过滤，按predicate指定的规则进行过滤，不符合规则则返回<code>empty</code>，也可以继续使用<code>Optional</code>的API。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 防止空指针，使用Optional</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> person</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getPersonNameOptional</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用Optional对person进行包装</span></span><br><span class="line">    <span class="keyword">return</span> Optional.ofNullable(person).map((per) -&gt; per.getName()).orElse(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 防止空指针，原有实现方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> person</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getPersonName</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 防止空指针，进行非空判断</span></span><br><span class="line">    <span class="keyword">if</span> (person == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> person.getName();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Date-Time-API"><a href="#Date-Time-API" class="headerlink" title="Date/Time API"></a>Date/Time API</h1><p>Java 8通过发布新的Date-Time API (JSR 310)来进一步加强对日期与时间的处理。Joda-Time是一个可替换标准日期/时间处理且功能非常强大的Java API的诞生。Java 8新的Date-Time API (JSR 310)在很大程度上受到Joda-Time的影响，并且吸取了其精髓。</p><h2 id="LocalDate类"><a href="#LocalDate类" class="headerlink" title="LocalDate类"></a>LocalDate类</h2><h2 id="LocalTime类"><a href="#LocalTime类" class="headerlink" title="LocalTime类"></a>LocalTime类</h2><h2 id="ZoneDateTime类"><a href="#ZoneDateTime类" class="headerlink" title="ZoneDateTime类"></a>ZoneDateTime类</h2><h2 id="Clock类"><a href="#Clock类" class="headerlink" title="Clock类"></a>Clock类</h2><h2 id="Duration类"><a href="#Duration类" class="headerlink" title="Duration类"></a>Duration类</h2><h1 id="其他特性"><a href="#其他特性" class="headerlink" title="其他特性"></a>其他特性</h1><h2 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h2><p>当我们Javer说异步调用时，我们自然会想到Future，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ExecutorService executor = Executors.newCachedThreadPool();</span><br><span class="line">        Future&lt;Integer&gt; result = executor.submit(<span class="keyword">new</span> Callable&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"正在计算..."</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++) &#123;</span><br><span class="line">                    sum = sum + i;</span><br><span class="line">                &#125;</span><br><span class="line">                Thread.sleep(TimeUnit.SECONDS.toSeconds(<span class="number">3000</span>));</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"计算完了！"</span>);</span><br><span class="line">                <span class="keyword">return</span> sum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"做其他事情..."</span>);</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"计算结果："</span> + result.get());</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"事情都做完了！"</span>);</span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">main做其他事情...</span><br><span class="line">pool-1-thread-1正在计算...</span><br><span class="line">pool-1-thread-1计算完了！</span><br><span class="line">main计算结果：4950</span><br><span class="line">main事情都做完了！</span><br></pre></td></tr></table></figure><p>那么现在如果想实现异步计算完成之后，立马能拿到这个结果继续异步做其他事情呢？这个问题就是一个线程依赖另外一个线程，这个时候Future就不方便，我们来看一下CompletableFuture的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompletableFutureTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService executor = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        CompletableFuture result = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"正在计算..."</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++) &#123;</span><br><span class="line">                sum = sum + i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(TimeUnit.SECONDS.toSeconds(<span class="number">3000</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"计算完了！"</span>);</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;, executor).thenApplyAsync(sum -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"打印："</span>+sum);</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;, executor);</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"做其他事情..."</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"计算结果："</span> + result.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"事情都做完了！"</span>);</span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">main做其他事情...</span><br><span class="line">pool-1-thread-1正在计算...</span><br><span class="line">pool-1-thread-1计算完了！</span><br><span class="line">pool-1-thread-2打印：4950</span><br><span class="line">main计算结果：4950</span><br><span class="line">main事情都做完了！</span><br></pre></td></tr></table></figure><p>只需要简单的使用<code>thenApplyAsync</code>就可以实现了。</p><h2 id="JVM的新特性"><a href="#JVM的新特性" class="headerlink" title="JVM的新特性"></a>JVM的新特性</h2><p><code>PermGen</code>空间被移除了，取而代之的是<code>Metaspace（JEP 122）</code></p><p>JVM选项 <code>-XX:PermSize</code>与<code>-XX:MaxPermSize</code>分别被<code>-XX:MetaSpaceSize</code>与<code>-XX:MaxMetaspaceSize</code>所代替。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Java前沿技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java8 </tag>
            
            <tag> lambda表达式 </tag>
            
            <tag> Stream </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>菜谱</title>
      <link href="/2020/08/12/%E7%83%B9%E9%A5%AA/%E8%8F%9C%E8%B0%B1/"/>
      <url>/2020/08/12/%E7%83%B9%E9%A5%AA/%E8%8F%9C%E8%B0%B1/</url>
      
        <content type="html"><![CDATA[<h1 id="早餐"><a href="#早餐" class="headerlink" title="早餐"></a>早餐</h1><h1 id="午餐"><a href="#午餐" class="headerlink" title="午餐"></a>午餐</h1><h1 id="晚餐"><a href="#晚餐" class="headerlink" title="晚餐"></a>晚餐</h1>]]></content>
      
      
      <categories>
          
          <category> 烹饪 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 菜谱 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单元测试基础</title>
      <link href="/2020/08/12/%E6%B5%8B%E8%AF%95/%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"/>
      <url>/2020/08/12/%E6%B5%8B%E8%AF%95/%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="单元测试的任务"><a href="#单元测试的任务" class="headerlink" title="单元测试的任务"></a>单元测试的任务</h1><p>单元测试只针对功能点进行测试，不包括对业务流程正确性的测试</p><ol><li><p>接口功能性测试：保证接口能够被正常使用，并输出有效数据</p><ul><li><p>是否被顺利调用</p></li><li><p>参数是否符合预期</p></li></ul></li><li><p>局部数据结构测试：保证数据结构的正确性</p><ul><li><p>变量是否有初始值或在某场景下是否有默认值</p></li><li><p>变量是否溢出</p></li></ul></li><li><p>边界条件测试：测试</p><ul><li>变量无赋值(null)</li><li>变量是数值或字符</li><li>主要边界：最大值，最小值，无穷大</li><li>溢出边界：在边界外面取值+/-1</li><li>临近边界：在边界值之内取值+/-1</li><li>字符串的边界，引用 “变量字符”的边界</li><li>字符串的设置，空字符串</li><li>字符串的应用长度测试</li><li>空白集合</li><li>目标集合的类型和应用边界</li><li>集合的次序</li><li>变量是规律的，测试无穷大的极限，无穷小的极限</li></ul></li><li><p>代码覆盖测试：保证每一句代码，所有分支都测试完成，主要包括代码覆盖率，异常处理通路测试</p><ul><li>语句覆盖率：每个语句都执行到了</li><li>判定覆盖率：每个分支都执行到了</li><li>条件覆盖率：每个条件都返回布尔</li><li>路径覆盖率：每个路径都覆盖到了</li></ul></li><li><p>异常模块测试：保证每一个异常都经过测试，后续处理模块测试：是否包闭当前异常或者对异常形成消化,是否影响结果!</p></li></ol><h1 id="单元测试的数据准备"><a href="#单元测试的数据准备" class="headerlink" title="单元测试的数据准备"></a>单元测试的数据准备</h1><p>正常数据-数据量最大，最关键，正案例反案例都属于正常数据</p><p>边界数据-介于正常数据和异常数据之间的一种数据</p><p>异常数据-设计输入参数是测试案例进入异常分支，校验程序处理异常的能力</p><h1 id="代码覆盖测试用例设计方法"><a href="#代码覆盖测试用例设计方法" class="headerlink" title="代码覆盖测试用例设计方法"></a>代码覆盖测试用例设计方法</h1><h2 id="代码覆盖定义"><a href="#代码覆盖定义" class="headerlink" title="代码覆盖定义"></a>代码覆盖定义</h2><p>以下段测试代码为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a&gt;<span class="number">1</span> &amp;&amp; b ==<span class="number">0</span>) &#123;</span><br><span class="line">        x = x/a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a==<span class="number">2</span> || x&gt;<span class="number">1</span>) &#123;</span><br><span class="line">        x = x+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img alt="例子流程图" data-src="//orangesching.github.io/2020/08/12/测试/测试理论/单元测试基础/example.png" class="lazyload"></p><div class="table-container"><table><thead><tr><th></th><th>语句覆盖</th><th>判定覆盖</th><th>条件覆盖</th><th>判定/条件覆盖</th><th>组合覆盖</th><th>路径覆盖</th></tr></thead><tbody><tr><td>覆盖范围</td><td>每条<strong>语句</strong>至少被执行一次</td><td>每个<strong>判定</strong>真假至少出现一次</td><td>每个<strong>条件</strong>真假至少出现一次</td><td>每个<strong>条件</strong>真假至少出现一次，且每个<strong>判定</strong>本身真假也至少出现一次</td><td>每个<strong>条件的所有可能组合</strong>至少出现一次</td><td>所有可能的<strong>路径</strong>至少出现一次（可画出流程图方便设计）</td></tr><tr><td>缺点</td><td>最弱的覆盖，难以发现程序中的错误</td><td>当判定由多个条件组合构成时，它未必能发现每个条件的错误</td><td>条件覆盖并不一定总能覆盖全部分支</td><td>条件覆盖和判定/条件覆盖不一定会发现逻辑表达式中的错误</td><td>组合覆盖不一定能覆盖到每条路径</td><td>路径覆盖不一定把所有的条件组合情况都覆盖，复杂程序的用例数呈指数级上升，路径覆盖无法发现程序不符合设计规范的错误</td></tr><tr><td>例子</td><td>a=2 b=0 x=1<em><code>ace</code></em></td><td>a=2 b=0 x=1<em><code>ace</code></em><br>a=1 b=0 x=1<em><code>abd</code></em></td><td>a=1 b=0 x=3<em><code>abe</code></em><br>a=2 b=1 x=1<em><code>abe</code></em></td><td>a=2，b=0，x=4<em><code>ace</code></em> <br>a=1，b=1，x=1<em><code>abd</code></em></td><td>a=2，b=0，x=4 <em><code>ace</code></em><br>a=2，b=1，x=1<em><code>abe</code></em><br>a=1，b=0，x=2 <em><code>abe</code></em><br>a=1，b=1，x=1<em><code>abd</code></em></td><td>a=1，b=0，x=1 <em><code>abd</code></em><br>a=1，b=0，x=2 <em><code>abe</code></em><br>a=3，b=0，x=1 <em><code>acd</code></em><br>a=2，b=0，x=3 <em><code>ace</code></em></td></tr></tbody></table></div><h2 id="根据场景选择测试方式："><a href="#根据场景选择测试方式：" class="headerlink" title="根据场景选择测试方式："></a>根据场景选择测试方式：</h2><p><img alt="根据场景选择测试方式" data-src="//orangesching.github.io/2020/08/12/测试/测试理论/单元测试基础/clip_image001.png" class="lazyload"></p><p>逻辑简单、分支较少、代码架子比较小的代码使用语句覆盖（50%）</p><p>业务价值比较高、逻辑代码比较复杂的使用判定覆盖条件覆盖甚至判定条件覆盖（30%）</p><p>最核心底层算法、框架类的代码使用组合覆盖、路径覆盖（20%）</p>]]></content>
      
      
      <categories>
          
          <category> 测试 </category>
          
          <category> 测试理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单元测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mock技术概述</title>
      <link href="/2020/08/12/%E6%B5%8B%E8%AF%95/%E6%B5%8B%E8%AF%95%E6%8A%80%E6%9C%AF/Mock%E6%8A%80%E6%9C%AF/Mock%E6%8A%80%E6%9C%AF%E6%A6%82%E8%BF%B0/"/>
      <url>/2020/08/12/%E6%B5%8B%E8%AF%95/%E6%B5%8B%E8%AF%95%E6%8A%80%E6%9C%AF/Mock%E6%8A%80%E6%9C%AF/Mock%E6%8A%80%E6%9C%AF%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Mock技术概述"><a href="#Mock技术概述" class="headerlink" title="Mock技术概述"></a>Mock技术概述</h1><ul><li>mockito官网：<a href="http://site.mockito.org/#how" target="_blank" rel="noopener">http://site.mockito.org/#how</a></li><li>mockito中文文档：<a href="http://blog.csdn.net/bboyfeiyu/article/details/52127551#2" target="_blank" rel="noopener">http://blog.csdn.net/bboyfeiyu/article/details/52127551#2</a></li></ul><p>在测试过程中，对于某些不容易构造或者不容易获取的对象，可使用mock来虚拟一个对象来创建以便测试的测试方法。</p><p>常见mock框架</p><p>EasyMock、Mockito、PowerMock、Jmockit</p><p>常见的mock场景：</p><p>对象 模拟一些再应用中不容易构造或比较复杂的对象</p><p>接口 调用别的接口中的方法必须mock，达到隔离的效果</p><p>静态方法 工具类中的静态方法建议mock，单独测试</p><p>Dao层方法 Dao层操作数据库的方法必须Mock，隔离数据库</p><p>私有方法 建议通过共有方法直接覆盖私有方法的方法来测试，也可以将司有关方法mock，之后用反射的方法单独测试</p>]]></content>
      
      
      <categories>
          
          <category> 测试 </category>
          
          <category> 测试技术 </category>
          
          <category> Mock技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mock </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mock技术概述</title>
      <link href="/2020/08/12/%E6%B5%8B%E8%AF%95/%E6%B5%8B%E8%AF%95%E6%8A%80%E6%9C%AF/%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95/Jmeter/"/>
      <url>/2020/08/12/%E6%B5%8B%E8%AF%95/%E6%B5%8B%E8%AF%95%E6%8A%80%E6%9C%AF/%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95/Jmeter/</url>
      
        <content type="html"><![CDATA[<h1 id="Mock技术概述"><a href="#Mock技术概述" class="headerlink" title="Mock技术概述"></a>Mock技术概述</h1><ul><li>mockito官网：<a href="http://site.mockito.org/#how" target="_blank" rel="noopener">http://site.mockito.org/#how</a></li><li>mockito中文文档：<a href="http://blog.csdn.net/bboyfeiyu/article/details/52127551#2" target="_blank" rel="noopener">http://blog.csdn.net/bboyfeiyu/article/details/52127551#2</a></li></ul><p>在测试过程中，对于某些不容易构造或者不容易获取的对象，可使用mock来虚拟一个对象来创建以便测试的测试方法。</p><p>常见mock框架</p><p>EasyMock、Mockito、PowerMock、Jmockit</p><p>常见的mock场景：</p><p>对象 模拟一些再应用中不容易构造或比较复杂的对象</p><p>接口 调用别的接口中的方法必须mock，达到隔离的效果</p><p>静态方法 工具类中的静态方法建议mock，单独测试</p><p>Dao层方法 Dao层操作数据库的方法必须Mock，隔离数据库</p><p>私有方法 建议通过共有方法直接覆盖私有方法的方法来测试，也可以将司有关方法mock，之后用反射的方法单独测试</p>]]></content>
      
      
      <categories>
          
          <category> 测试 </category>
          
          <category> 测试技术 </category>
          
          <category> Mock技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mock </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码覆盖率检测</title>
      <link href="/2020/08/12/%E6%B5%8B%E8%AF%95/%E6%B5%8B%E8%AF%95%E6%8A%80%E6%9C%AF/%E6%B5%8B%E8%AF%95%E6%8A%A5%E5%91%8A/%E4%BB%A3%E7%A0%81%E8%A6%86%E7%9B%96%E7%8E%87%E6%A3%80%E6%B5%8B/"/>
      <url>/2020/08/12/%E6%B5%8B%E8%AF%95/%E6%B5%8B%E8%AF%95%E6%8A%80%E6%9C%AF/%E6%B5%8B%E8%AF%95%E6%8A%A5%E5%91%8A/%E4%BB%A3%E7%A0%81%E8%A6%86%E7%9B%96%E7%8E%87%E6%A3%80%E6%B5%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Jacoco代码覆盖率检测工具"><a href="#Jacoco代码覆盖率检测工具" class="headerlink" title="Jacoco代码覆盖率检测工具"></a>Jacoco代码覆盖率检测工具</h1><p>一个测试覆盖率的插件</p>]]></content>
      
      
      <categories>
          
          <category> 测试 </category>
          
          <category> 测试技术 </category>
          
          <category> 测试报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Jacoco </tag>
            
            <tag> 代码覆盖率检测 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUNIT测试框架</title>
      <link href="/2020/08/12/%E6%B5%8B%E8%AF%95/%E6%B5%8B%E8%AF%95%E6%8A%80%E6%9C%AF/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/JUNIT%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/"/>
      <url>/2020/08/12/%E6%B5%8B%E8%AF%95/%E6%B5%8B%E8%AF%95%E6%8A%80%E6%9C%AF/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/JUNIT%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="JUNIT的使用"><a href="#JUNIT的使用" class="headerlink" title="JUNIT的使用"></a>JUNIT的使用</h1><h2 id="依赖添加"><a href="#依赖添加" class="headerlink" title="依赖添加"></a>依赖添加</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>         </span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>         </span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>         </span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>4.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span>         </span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span>     </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Test"><a href="#Test" class="headerlink" title="@Test"></a>@Test</h2><p>@Test(expected = Exception.class) 预期会抛出Exception.class异常</p><p>@Test(timeout=100)预期方法执行不会超过100毫秒，控制死循环</p><h2 id="Runwith"><a href="#Runwith" class="headerlink" title="@Runwith"></a>@Runwith</h2><p>@RunWith(Parameterized.class) 使用参数化测试方式运行</p><p>@RunWith(SpringRunner.class)   使用Spring测试方式运行</p><h2 id="Parameters"><a href="#Parameters" class="headerlink" title="@Parameters"></a>@Parameters</h2><p>@Parameterized.Parameters 申明当前方法为测试数据来源</p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><h3 id="被测试类"><a href="#被测试类" class="headerlink" title="被测试类"></a>被测试类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloJunit</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_FACT = <span class="number">50</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">fact</span><span class="params">(<span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"复数不能阶乘"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n&gt;MAX_FACT) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"暂不支持50以上的阶乘"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> r = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            r = r * i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="默认测试方式"><a href="#默认测试方式" class="headerlink" title="默认测试方式"></a>默认测试方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Before;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.*;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloJunitTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HelloJunit j;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实例化被测试类</span></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        j = <span class="keyword">new</span> HelloJunit();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正常功能测试</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fact</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> n = <span class="number">1L</span>;</span><br><span class="line">        <span class="keyword">long</span> result = j.fact(n);</span><br><span class="line">        assertEquals(expResult, result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异常的测试</span></span><br><span class="line">    <span class="meta">@Test</span>(expected = RuntimeException.class)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">factExceptionTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">long</span> n = -<span class="number">1L</span>;</span><br><span class="line">            <span class="keyword">long</span> result = j.fact(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参数化测试方式"><a href="#参数化测试方式" class="headerlink" title="参数化测试方式"></a>参数化测试方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Before;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.junit.runners.Parameterized;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(Parameterized.class)   </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloJunitTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HelloJunit j;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> n;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> expResult;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用参数化测试方式时，必须声明构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloJunitTest</span><span class="params">(<span class="keyword">long</span> n, <span class="keyword">long</span> expResult)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">        <span class="keyword">this</span>.expResult = expResult;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        j = <span class="keyword">new</span> HelloJunit();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建测试参数，创建的测试参数将通过类属性n和expResult传入测试方法</span></span><br><span class="line">    <span class="meta">@Parameterized</span>.Parameters   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Collection <span class="title">data</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.asList(<span class="keyword">new</span> Object[][]&#123;&#123;-<span class="number">1L</span>,<span class="number">1L</span>&#125;,&#123;-<span class="number">3L</span>,<span class="number">6L</span>&#125;,&#123;-<span class="number">5L</span>,<span class="number">120L</span>&#125;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正常功能测试</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fact</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> result = j.fact(n);</span><br><span class="line">        assertEquals(expResult, result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异常的测试</span></span><br><span class="line">    <span class="meta">@Test</span>(expected = RuntimeException.class)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">factExceptionTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> result = j.fact(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在spring框架下的测试方式"><a href="#在spring框架下的测试方式" class="headerlink" title="在spring框架下的测试方式"></a>在spring框架下的测试方式</h3><p>导入相关依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>         </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>         </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>         </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span>         </span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span>     </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Before;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.junit.runners.Parameterized;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用spring框架的Test，会自动搜索相关依赖并实例。支持test环境下的配置文件，放在test中的resources中自动使用</span></span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)   </span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloJunitTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span>  <span class="comment">// 使用注入方式实例化</span></span><br><span class="line">    <span class="keyword">private</span> HelloJunit j;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> n;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> expResult;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloJunitTest</span><span class="params">(<span class="keyword">long</span> n, <span class="keyword">long</span> expResult)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">        <span class="keyword">this</span>.expResult = expResult;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Parameterized</span>.Parameters</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Collection <span class="title">data</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.asList(<span class="keyword">new</span> Object[][]&#123;&#123;-<span class="number">1L</span>,<span class="number">1L</span>&#125;,&#123;-<span class="number">3L</span>,<span class="number">6L</span>&#125;,&#123;-<span class="number">5L</span>,<span class="number">120L</span>&#125;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正常功能测试</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fact</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> result = j.fact(n);</span><br><span class="line">        assertEquals(expResult, result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异常的测试</span></span><br><span class="line">    <span class="meta">@Test</span>(expected = RuntimeException.class)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">factExceptionTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> result = j.fact(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h1><div class="table-container"><table><thead><tr><th>注释名</th><th>放置位置</th><th>功能</th></tr></thead><tbody><tr><td>@Test</td><td>方法</td><td>标记测试方法，在这里可以测试期望异常和超时时间</td></tr><tr><td>@Ignore</td><td>方法</td><td>标记忽略的测试方法</td></tr><tr><td>@BeforeClass</td><td>public static void方法</td><td>运行测试类中的所有用例前都会运行该方法，可在该方法中做一些前置操作，如创建数据库连接，初始化数据等</td></tr><tr><td>@AfterClass</td><td>public static void方法</td><td>和@BeforeClass注解对应，在运行完测试类中的所有测试用例后执行，可在该方法中做一些后续工作，如回复数据库，断开数据库连接等</td></tr><tr><td>@Before</td><td>public void方法</td><td>会在每个用例运行之前都运行一次该方法。主要用于一些独立与用例之间的准备工作</td></tr><tr><td>@After</td><td>public void方法</td><td>与@Before注解对应，会在每个用例运行之后运行一次</td></tr><tr><td>@Runwith</td><td>类</td><td>用来确定这个类如何运行，也可以不标注，会使用默认运行器</td></tr><tr><td>@Parameters</td><td>类</td><td>用于参数化测试</td></tr></tbody></table></div><p>一个JUNIT的单元测试用例执行顺序</p><p>@BeforeClass -&gt; @Before -&gt; @Test -&gt; @After -&gt; @AfterClass</p><p>每个测试方法的调用顺序</p><p>@Before -&gt; @Test -&gt; @After</p><h1 id="常用断言"><a href="#常用断言" class="headerlink" title="常用断言"></a>常用断言</h1><div class="table-container"><table><thead><tr><th>断言</th><th>描述</th></tr></thead><tbody><tr><td>void assertEquals([String message], expected value, actual value)</td><td>断言两个值相等。值可能是类型有 int, short, long, byte, char or java.lang.Object. 第一个参数是一个可选的字符串消息</td></tr><tr><td>void assertTrue([String message], boolean condition)</td><td>断言一个条件为真</td></tr><tr><td>void assertFalse([String message],boolean condition)</td><td>断言一个条件为假</td></tr><tr><td>void assertNotNull([String message], java.lang.Object object)</td><td>断言一个对象不为空(null)</td></tr><tr><td>void assertNull([String message], java.lang.Object object)</td><td>断言一个对象为空(null)</td></tr><tr><td>void assertSame([String message], java.lang.Object expected, java.lang.Object actual)</td><td>断言，两个对象引用相同的对象，类似==判断</td></tr><tr><td>void assertNotSame([String message], java.lang.Object unexpected, java.lang.Object actual)</td><td>断言，两个对象不是引用同一个对象，类似!=判断</td></tr><tr><td>void assertArrayEquals([String message], expectedArray, resultArray)</td><td>断言预期数组和结果数组相等。数组的类型可能是 int, long, short, char, byte or java.lang.Object.</td></tr><tr><td>void assertThat(actual, matcher)</td><td>查看实际值是否满足指定条件</td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> 测试 </category>
          
          <category> 测试技术 </category>
          
          <category> 单元测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单元测试 </tag>
            
            <tag> JUNIT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式系统——分布式文件系统</title>
      <link href="/2020/06/26/%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
      <url>/2020/06/26/%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="分布式存储的难点——万恶的副本"><a href="#分布式存储的难点——万恶的副本" class="headerlink" title="分布式存储的难点——万恶的副本"></a>分布式存储的难点——万恶的副本</h1><p>分布式存储的初衷是将数据存储在多个服务器上从而获得高性能</p><blockquote><p>分布式基本逻辑：</p><p>高性能-&gt;分片数据存储在多个服务器上实现</p><p>多服务器-&gt;持续故障-&gt;需要容错</p><p>容错-&gt;复制</p><p>复制-&gt;潜在的不一致</p><p>强一致性-&gt;降低性能</p></blockquote><p>强一致性极端例子：单个服务器，服务器使用磁盘存储的行为相同，容错能力差</p><p>实现强一致性需要确保副本之间的同步，这需要以性能为代价</p><p>由此可见分布式系统需要在性能和一致性之间折中</p><h1 id="GFS（Google-File-System）"><a href="#GFS（Google-File-System）" class="headerlink" title="GFS（Google File System）"></a>GFS（Google File System）</h1><h1 id="HDFS（Hadoop-Distribute-File-System）"><a href="#HDFS（Hadoop-Distribute-File-System）" class="headerlink" title="HDFS（Hadoop Distribute File System）"></a>HDFS（Hadoop Distribute File System）</h1><h1 id="GFS与HDFS的异同"><a href="#GFS与HDFS的异同" class="headerlink" title="GFS与HDFS的异同"></a>GFS与HDFS的异同</h1><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>[1] Sanjay Ghemawat, Howard Gobioff, and Shun-Tak Leung. The Google File System</p><p>[2] Hadoop Documentation. HDFS Architecture.</p><p>[3] Robert Chansler, Hairong Kuang, Sanjay Radia, Konstantin Shvachko, and Suresh Srinivas. The Hadoop Distributed File System</p><p>[3] <a href="https://blog.csdn.net/mindfloating/article/details/49103611" target="_blank" rel="noopener">https://blog.csdn.net/mindfloating/article/details/49103611</a></p><p>[4] <a href="http://nil.csail.mit.edu/6.824/2020/notes/l-gfs.txt" target="_blank" rel="noopener">http://nil.csail.mit.edu/6.824/2020/notes/l-gfs.txt</a> MIT分布式系统课程</p>]]></content>
      
      
      <categories>
          
          <category> 数据系统理论 </category>
          
          <category> 分布式系统案例分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GFS </tag>
            
            <tag> HDFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式系统理论———概要</title>
      <link href="/2020/06/26/%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E2%80%94%E2%80%94%E6%A6%82%E8%A6%81/"/>
      <url>/2020/06/26/%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E2%80%94%E2%80%94%E6%A6%82%E8%A6%81/</url>
      
        <content type="html"><![CDATA[<p>什么是分布式系统？<br>是类似P2P文件交换系统、MapReduce、DNS等。</p><p>为何选择分布式架构？</p><ul><li>联通物理上分散的节点</li><li>通过各个节点的资源隔离保证安全</li><li>通过备份实现高可用</li><li>方便横向资源扩展</li></ul><p>但是分布式系统实现很复杂，需要解决各个层次上的并发，肯定会出现部分节点失效的情况，还需要有很强的系统性能优化能力（操作系统、文件系统、网络Lan-&gt;Wan、数据库等底层的优化使用）。本质上还是解决体系结构的老问题。体系结构无非三大领域：计算、存储、网络。这三大领域中关于分布式系统工程实现都有一些共性的需要解决的问题，包括</p><ul><li>基础组件实现：RPC机制、线程机制、并发控制等如何高效实现</li><li>线性横向扩展：节点越多越难实现，比如负载不均衡、部分逻辑无法并发、共享资源形成瓶颈等情况都怎么处理</li><li>容错性：肯定会出现节点失效，如何故障隔离，如何保证高可用。</li><li>一致性保证：各个节点都有可能出问题的情况下，通信存在延迟的情况下，包括网络分割等情况都如何处理；强一致又必然损耗性能，如何做到性能与一致性之间的设计平衡</li></ul><p>这些都是分布式系统设计与实现中需要考虑研究的问题。</p>]]></content>
      
      
      <categories>
          
          <category> 数据系统理论 </category>
          
          <category> 分布式系统案例分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式理论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>强化学习算法</title>
      <link href="/2019/12/06/%E7%AE%97%E6%B3%95/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/"/>
      <url>/2019/12/06/%E7%AE%97%E6%B3%95/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Q学习（离线学习）"><a href="#Q学习（离线学习）" class="headerlink" title="Q学习（离线学习）"></a>Q学习（离线学习）</h1><p>Q学习是一种基于TD(0)的离线策略时序差分算法。</p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="算法理论——Q值更新公式"><a href="#算法理论——Q值更新公式" class="headerlink" title="算法理论——Q值更新公式"></a>算法理论——Q值更新公式</h3><p>Q学习使用一张Q表来存储当前状态-行为价值，即存储在当前状态做这个行为未来可获得的收益。为了更新这张表，我们需要计算这个预估的未来奖励（Q值）和我们实际获得的奖励有多大的误差。</p><ul><li><p>预估的未来奖励，就是Q表中的数值</p></li><li><p>实际获得的奖励</p><p>直观上想，可以使用从这一步出发到终点的奖励来计算。但是这样需要整个奖励序列，不利于学习（这个思想是基于蒙托卡罗的思想）。</p><p>换一种思路，我们只利用当前步的奖励，再加上<strong>下一步的预估未来奖励（下一步的Q值）</strong>，不就是有点实际的实际获得奖励吗</p></li></ul><p>用公式表示这个误差就是</p><script type="math/tex; mode=display">R _ { t + 1 } + \gamma Q \left( S'  , A ^ { \prime } \right) - Q \left( S _ { t } , A _ { t } \right)</script><p>由于下一步的预估未来奖励与具体的行动有关系，而我们要获取的是一个具体的值，所以我们在下一步选择行动的时候才用纯贪婪算法，即在下一状态$S_{t+1}$时选择动作的策略变成了贪婪Q最大：</p><script type="math/tex; mode=display">\pi \left( S _ { t + 1 } \right) = \underset { a ^ { \prime } } { \operatorname { argmax } } Q \left( S ' , a ^ { \prime } \right)</script><p>这样$Q \left( S <em> { t + 1 } , A ^ { \prime } \right)$就可以变成具体的$\underset { a ^ { \prime } } { \operatorname { max } } Q \left( S </em> { t + 1 } , a ^ { \prime } \right)$，Q值更新公式就变成了</p><script type="math/tex; mode=display">Q ( S , A ) \leftarrow Q ( S , A ) + \alpha \left( R + \gamma \max _ { a ^ { \prime } } Q \left( S ^ { \prime } , a ^ { \prime } \right) - Q ( S , A ) \right)</script><h3 id="算法伪代码"><a href="#算法伪代码" class="headerlink" title="算法伪代码"></a>算法伪代码</h3><p><img alt="Q学习算法" data-src="//orangesching.github.io/2019/12/06/算法/机器学习/强化学习/强化学习算法/Q学习算法.png" class="lazyload"></p><p>Q学习中动作的选择策略是这样的：当前在状态$S$选择行动使用的是Ɛ-贪婪策略，获得了奖励R到达了状态 $s’$ 。现在要评估误差时，需要使用下一步的状态-行为值，这时对$s’$的策略决策使用的是纯贪婪算法，才能获得具体的下一步状态-行为值$\max _ { a ^ { \prime } } Q \left( S ^ { \prime } , a ^ { \prime } \right) $</p><p>$\alpha$是学习率, 来决定这次的误差有多少是要被学习的, $\alpha$是一个小于1 的数. </p><p>$\gamma$ 是 reward 的衰减衰减系数</p><h2 id="例"><a href="#例" class="headerlink" title="例"></a>例</h2><p>举给女朋友送礼物的例子，你女朋友的状态有三种（高兴/没反应/不高兴）下面是获得的奖励（奖励只与状态有关，离开这个状态就能获得）</p><div class="table-container"><table><thead><tr><th>状态</th><th>奖励（R）</th></tr></thead><tbody><tr><td>高兴</td><td>1</td></tr><tr><td>没反应</td><td>0</td></tr><tr><td>不高兴</td><td>0</td></tr></tbody></table></div><p>为了记录我在这个情况下做某件事可能获得多少的好感度，这样方便我以后决策，我就可以画一个Q表，假设你当前的Q表是这样的</p><div class="table-container"><table><thead><tr><th>当前状态（S）</th><th>送礼物</th><th>不送礼物</th><th>揍一顿</th></tr></thead><tbody><tr><td>高兴</td><td>5</td><td>1</td><td>0</td></tr><tr><td>没反应</td><td>4</td><td>1</td><td>0</td></tr><tr><td>不高兴</td><td>3</td><td>1</td><td>0</td></tr></tbody></table></div><p>现在，你女朋友来姨妈不高兴了，你想做点什么。看看Q表。诶！送礼物的价值最大，送个礼物。然后你送了他一个热水瓶。女朋友看完就放那了（女朋友的状态取决于女朋友，你不知道他会变成什么状态）。进过这次事之后，你想更新下你的Q表。怎么更新？看看公式</p><script type="math/tex; mode=display">Q ( S , A ) \leftarrow Q ( S , A ) + \alpha \left( R + \gamma \max _ { a ^ { \prime } } Q \left( S ^ { \prime } , a ^ { \prime } \right) - Q ( S , A ) \right)</script><p>首先我理想中会获得的好感度$Q(S,A)$是3；现实是离开【不高兴】这个状态，获得了奖励0，到达了新的状态【没反应】，我预估下我在【没反应】能做的最有意义的事还是送礼，没反应-送礼这个操作Q值是4，即$\max _ { a ^ { \prime } } Q \left( S ^ { \prime } , a ^ { \prime } \right) = 4$。假设$\gamma,\alpha=1$，那现实和理想的差距就是$（0+1<em>4-3）$，更新$Q（不高兴，送礼物）= 3+1</em>(0+1*4-3)=4$</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><img alt="Q学习算法例" data-src="//orangesching.github.io/2019/12/06/算法/机器学习/强化学习/强化学习算法/Q学习算法例.png" class="lazyload"></p><p>玩上述游戏，黄色圆为宝藏，黑色方框为黑洞，进入黑洞奖励为-1，获得宝藏奖励+1，其他情况奖励为0。</p><p>迭代代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 学习 100 回合</span></span><br><span class="line">    <span class="keyword">for</span> episode <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">        <span class="comment"># 初始化 state 的观测值</span></span><br><span class="line">        observation = env.reset()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="comment"># 更新可视化环境</span></span><br><span class="line">            env.render()</span><br><span class="line"></span><br><span class="line">            <span class="comment"># RL 大脑根据 state 的观测值挑选 action</span></span><br><span class="line">            action = RL.choose_action(str(observation))</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 探索者在环境中实施这个 action, 并得到环境返回的下一个 state 观测值, reward 和 done (是否是掉下地狱或者升上天堂)</span></span><br><span class="line">            observation_, reward, done = env.step(action)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># RL 从这个序列 (state, action, reward, state_) 中学习</span></span><br><span class="line">            RL.learn(str(observation), action, reward, str(observation_))</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 将下一个 state 的值传到下一次循环</span></span><br><span class="line">            observation = observation_</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 如果掉下地狱或者升上天堂, 这回合就结束了</span></span><br><span class="line">            <span class="keyword">if</span> done:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment"># 结束游戏并关闭窗口</span></span><br><span class="line">    print(<span class="string">'game over'</span>)</span><br><span class="line">    env.destroy()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="comment"># 定义环境 env 和 RL 方式</span></span><br><span class="line">    env = Maze()</span><br><span class="line">    RL = QLearningTable(actions=list(range(env.n_actions)))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 开始可视化环境 env</span></span><br><span class="line">    env.after(<span class="number">100</span>, update)</span><br><span class="line">    env.mainloop()</span><br></pre></td></tr></table></figure><p>Q学习代码（个体类）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QLearningTable</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, actions, learning_rate=<span class="number">0.01</span>, reward_decay=<span class="number">0.9</span>, e_greedy=<span class="number">0.9</span>)</span>:</span></span><br><span class="line">        self.actions = actions  <span class="comment"># a list</span></span><br><span class="line">        self.lr = learning_rate <span class="comment">#学习速率</span></span><br><span class="line">        self.gamma = reward_decay <span class="comment">#衰减系数</span></span><br><span class="line">        self.epsilon = e_greedy <span class="comment">#以多少概率去探索</span></span><br><span class="line">        self.q_table = pd.DataFrame(columns=self.actions, dtype=np.float64)  <span class="comment">#Q表，Q学习的关键！</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#依据策略（ε-贪婪策略）选择一个动作</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">choose_action</span><span class="params">(self, observation)</span>:</span></span><br><span class="line">        self.check_state_exist(observation)<span class="comment">#如果状态没遇到过就加入Q表</span></span><br><span class="line">        <span class="comment"># action selection</span></span><br><span class="line">        <span class="keyword">if</span> np.random.uniform() &lt; self.epsilon: </span><br><span class="line">            <span class="comment"># choose best action</span></span><br><span class="line">            state_action = self.q_table.loc[observation, :]</span><br><span class="line">            <span class="comment"># 不直接使用max函数，防止相同值时每次都选择同一个动作</span></span><br><span class="line">            action = np.random.choice(state_action[state_action == np.max(state_action)].index)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># choose random action</span></span><br><span class="line">            action = np.random.choice(self.actions)</span><br><span class="line">        <span class="keyword">return</span> action</span><br><span class="line"></span><br><span class="line">    <span class="comment">#更新Q表中的值</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">learn</span><span class="params">(self, s, a, r, s_)</span>:</span></span><br><span class="line">        self.check_state_exist(s_)</span><br><span class="line">        q_predict = self.q_table.loc[s, a]  <span class="comment">#估计值</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">#计算现实值</span></span><br><span class="line">        <span class="keyword">if</span> s_ != <span class="string">'terminal'</span>:</span><br><span class="line">            q_target = r + self.gamma * self.q_table.loc[s_, :].max()  <span class="comment"># next state is not terminal</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            q_target = r  <span class="comment"># next state is terminal</span></span><br><span class="line">        self.q_table.loc[s, a] += self.lr * (q_target - q_predict)  <span class="comment"># update</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#检查是否有此状态，没有就添加</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">check_state_exist</span><span class="params">(self, state)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> state <span class="keyword">not</span> <span class="keyword">in</span> self.q_table.index:</span><br><span class="line">            <span class="comment"># append new state to q table</span></span><br><span class="line">            self.q_table = self.q_table.append(</span><br><span class="line">                pd.Series(</span><br><span class="line">                    [<span class="number">0</span>]*len(self.actions),</span><br><span class="line">                    index=self.q_table.columns,</span><br><span class="line">                    name=state,</span><br><span class="line">                )</span><br><span class="line">            )</span><br></pre></td></tr></table></figure><h1 id="Sarsa"><a href="#Sarsa" class="headerlink" title="Sarsa"></a>Sarsa</h1><h2 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h2><h3 id="算法理论——Q值更新公式-1"><a href="#算法理论——Q值更新公式-1" class="headerlink" title="算法理论——Q值更新公式"></a>算法理论——Q值更新公式</h3><p>SARSA的名称来源于一个的序列描述：针对一个状态$S$，以及一个特定的行为，$A$进而产生一个状态行为对($SA$)，与环境交互，环境收到个体的行为后会告诉个体即时奖励 $R$ 以及后续进入的状态 $S’$；接下来个体遵循<strong>现有策略</strong>产生一个行为 $A’$（下一次行动），根据当前的<strong>状态行为价值函数</strong>得到后一个状态行为对($S’A’$)的价值（$Q$），利用这个 $Q$ 值更新前一个状态行为对( $SA$ )的价值。Sarsa使用的是单步更新</p><p>Sarsa与Q学习类似同样使用<strong>Ɛ-贪婪探索</strong>的形式来改善策略，但Q表的更新公式不同。Q学习在$S’$状态的决策策略是纯贪婪策略，且决策出的动作不一定是真实执行的动作所以Q学习中Q现实的计算为$R+\gamma\underset { a ^ { \prime } } { \operatorname { max } } Q \left( S _ { t + 1 } , a ^ { \prime } \right)$；而Sarsa在$S$状态和$S’$状态的决策策略都是Ɛ-贪婪策略，且在$S’$决策出来的动作就是下一个执行的动作，所以Sarsa中Q现实的计算为$R + \gamma Q \left( S ^ { \prime } , A ^ { \prime } \right)$，有这个特性Sarsa也是一个On-policy学习算法</p><script type="math/tex; mode=display">Q ( S , A ) \leftarrow Q ( S , A ) + \alpha \left( R + \gamma Q \left( S ^ { \prime } , A ^ { \prime } \right) - Q ( S , A ) \right)</script><p>这个公式决定了Q学习比Sarsa更加大胆的特性</p><h3 id="算法伪代码-1"><a href="#算法伪代码-1" class="headerlink" title="算法伪代码"></a>算法伪代码</h3><p><img alt="Sarsa算法" data-src="//orangesching.github.io/2019/12/06/算法/机器学习/强化学习/强化学习算法/Sarsa算法.png" class="lazyload"></p><p>$\alpha$是学习率, 来决定这次的误差有多少是要被学习的, $\alpha$是一个小于1 的数. </p><p>$\gamma$ 是 reward 的衰减衰减系数</p><h2 id="例-1"><a href="#例-1" class="headerlink" title="例"></a>例</h2><p>还是上面的例子，重新写一遍</p><p>举给女朋友送礼物的例子，你女朋友的状态有三种（高兴/没反应/不高兴）下面是获得的奖励（奖励只与状态有关，离开这个状态就能获得）</p><div class="table-container"><table><thead><tr><th>状态</th><th>奖励（R）</th></tr></thead><tbody><tr><td>高兴</td><td>1</td></tr><tr><td>没反应</td><td>0</td></tr><tr><td>不高兴</td><td>0</td></tr></tbody></table></div><p>为了记录我在这个情况下做某件事可能获得多少的好感度，这样方便我以后决策，我就可以画一个Q表，假设你当前的Q表是这样的</p><div class="table-container"><table><thead><tr><th>当前状态（S）</th><th>送礼物</th><th>不送礼物</th><th>揍一顿</th></tr></thead><tbody><tr><td>高兴</td><td>5</td><td>1</td><td>0</td></tr><tr><td>没反应</td><td>4</td><td>1</td><td>0</td></tr><tr><td>不高兴</td><td>3</td><td>1</td><td>0</td></tr></tbody></table></div><p>现在，你女朋友来姨妈不高兴了，你想做点什么。看看Q表。诶！送礼物的价值最大，送个礼物。然后你送了他一个热水瓶。女朋友看完就放那了（女朋友的状态取决于女朋友，你不知道他会变成什么状态）。进过这次事之后，你想更新下你的Q表。怎么更新？看看公式</p><script type="math/tex; mode=display">Q ( S , A ) \leftarrow Q ( S , A ) + \alpha \left( R + \gamma Q \left( S ^ { \prime } , A ^ { \prime } \right) - Q ( S , A ) \right)</script><p>首先我理想中会获得的好感度$Q(S,A)$是3；现实是离开【不高兴】这个状态，获得了奖励0，到达了新的状态【没反应】，我在【没反应】能做的事可以有两种：一是随便做件事看看反应，二是选Q值最大的动作（送礼）。我最后决定随便做件事（揍她一顿）没反应-揍一顿这个操作Q值是0，即$Q \left( S ^ { \prime } , A ^ { \prime } \right)=0$。假设$\gamma,\alpha=1$，那现实和理想的差距就是$（0+1<em>0-3）$，更新$Q（不高兴，送礼）= 3+1</em>(0+1*0-3)=0$，下一步我要做的事是揍一顿</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p><img alt="Q学习算法例" data-src="//orangesching.github.io/2019/12/06/算法/机器学习/强化学习/强化学习算法/Q学习算法例.png" class="lazyload"></p><p>玩上述游戏，黄色圆为宝藏，黑色方框为黑洞，进入黑洞奖励为-1，获得宝藏奖励+1，其他情况奖励为0。</p><p>迭代代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 学习 100 回合</span></span><br><span class="line">    <span class="keyword">for</span> episode <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">        <span class="comment"># 初始化 state 的观测值</span></span><br><span class="line">        observation = env.reset()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="comment"># 更新可视化环境</span></span><br><span class="line">            env.render()</span><br><span class="line"></span><br><span class="line">            <span class="comment"># RL 大脑根据 state 的观测值挑选 action</span></span><br><span class="line">            action = RL.choose_action(str(observation))</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 探索者在环境中实施这个 action, 并得到环境返回的下一个 state 观测值, reward 和 done (是否是掉下地狱或者升上天堂)</span></span><br><span class="line">            observation_, reward, done = env.step(action)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 决策下一个行动，与Q学习不同</span></span><br><span class="line">            action_ = RL.choose_action(str(observation_))</span><br><span class="line"></span><br><span class="line">            <span class="comment"># RL 从这个序列 (state, action, reward, state_) 中学习</span></span><br><span class="line">            RL.learn(str(observation), action, reward, str(observation_), action_)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 将下一个 state 的值传到下一次循环</span></span><br><span class="line">            observation = observation_</span><br><span class="line">            action = action_ <span class="comment">#与Q学习不同，这个动作真实执行了</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 如果掉下地狱或者升上天堂, 这回合就结束了</span></span><br><span class="line">            <span class="keyword">if</span> done:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment"># 结束游戏并关闭窗口</span></span><br><span class="line">    print(<span class="string">'game over'</span>)</span><br><span class="line">    env.destroy()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="comment"># 定义环境 env 和 RL 方式</span></span><br><span class="line">    env = Maze()</span><br><span class="line">    RL = QLearningTable(actions=list(range(env.n_actions)))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 开始可视化环境 env</span></span><br><span class="line">    env.after(<span class="number">100</span>, update)</span><br><span class="line">    env.mainloop()</span><br></pre></td></tr></table></figure><p>Sarsa学习代码（个体类）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SarsaTable</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, actions, learning_rate=<span class="number">0.01</span>, reward_decay=<span class="number">0.9</span>, e_greedy=<span class="number">0.9</span>)</span>:</span></span><br><span class="line">        self.actions = actions  <span class="comment"># a list</span></span><br><span class="line">        self.lr = learning_rate <span class="comment">#学习速率</span></span><br><span class="line">        self.gamma = reward_decay <span class="comment">#衰减系数</span></span><br><span class="line">        self.epsilon = e_greedy <span class="comment">#以多少概率去探索</span></span><br><span class="line">        self.q_table = pd.DataFrame(columns=self.actions, dtype=np.float64)  <span class="comment">#Q表，学习的关键！</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#依据策略（ε-贪婪策略）选择一个动作</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">choose_action</span><span class="params">(self, observation)</span>:</span></span><br><span class="line">        self.check_state_exist(observation)<span class="comment">#如果状态没遇到过就加入Q表</span></span><br><span class="line">        <span class="comment"># action selection</span></span><br><span class="line">        <span class="keyword">if</span> np.random.uniform() &lt; self.epsilon: </span><br><span class="line">            <span class="comment"># choose best action</span></span><br><span class="line">            state_action = self.q_table.loc[observation, :]</span><br><span class="line">            <span class="comment"># 不直接使用max函数，防止相同值时每次都选择同一个动作</span></span><br><span class="line">            action = np.random.choice(state_action[state_action == np.max(state_action)].index)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># choose random action</span></span><br><span class="line">            action = np.random.choice(self.actions)</span><br><span class="line">        <span class="keyword">return</span> action</span><br><span class="line"></span><br><span class="line">    <span class="comment">#更新Q表中的值</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">learn</span><span class="params">(self, s, a, r, s_， a_)</span>:</span></span><br><span class="line">        self.check_state_exist(s_)</span><br><span class="line">        q_predict = self.q_table.ix[s, a]  <span class="comment">#估计值</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">#计算现实值</span></span><br><span class="line">        <span class="keyword">if</span> s_ != <span class="string">'terminal'</span>:</span><br><span class="line">            q_target = r + self.gamma * self.q_table.ix[s_, a_] <span class="comment"># next state is not terminal</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            q_target = r  <span class="comment"># next state is terminal</span></span><br><span class="line">        self.q_table.loc[s, a] += self.lr * (q_target - q_predict)  <span class="comment"># update</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#检查是否有此状态，没有就添加</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">check_state_exist</span><span class="params">(self, state)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> state <span class="keyword">not</span> <span class="keyword">in</span> self.q_table.index:</span><br><span class="line">            <span class="comment"># append new state to q table</span></span><br><span class="line">            self.q_table = self.q_table.append(</span><br><span class="line">                pd.Series(</span><br><span class="line">                    [<span class="number">0</span>]*len(self.actions),</span><br><span class="line">                    index=self.q_table.columns,</span><br><span class="line">                    name=state,</span><br><span class="line">                )</span><br><span class="line">            )</span><br></pre></td></tr></table></figure><h1 id="Sarsa-λ"><a href="#Sarsa-λ" class="headerlink" title="Sarsa(λ)"></a>Sarsa(λ)</h1><h2 id="算法-2"><a href="#算法-2" class="headerlink" title="算法"></a>算法</h2><h3 id="算法理论"><a href="#算法理论" class="headerlink" title="算法理论"></a>算法理论</h3><p>Q-Learning 和 Sarsa 都是在得到奖励后只更新上一步状态和动作对应的 Q 表值，是单步更新算法，也就是 Sarsa(0)。但是在得到当前奖励值后之前所走的每一步（即一个轨迹）都多多少少和最终得到的奖励值有关，所以不应该只更新上一步状态对应的 Q 值。于是就有了多步更新算法——Sarsa(n)。当 n 的值为一个回合（episode）的步数时就变成了回合更新。对于多步更新的 Sarsa 算法我们用 Sarsa(λ)来统一表示，其中 $\lambda$ 的取值范围是 [ 0 , 1 ]，其本质是一个衰减值。</p><h4 id="n步sarsa"><a href="#n步sarsa" class="headerlink" title="n步sarsa"></a>n步sarsa</h4><p>之前的sarsa只使用一步的真实奖励来估计现实Q收货，如果我多用几步呢？</p><p>定义<strong>n-步Q收获（Q-return）</strong>为前n个奖励的总和加上在n个步骤中达到的状态的估计值，每个步骤都适当地折扣：</p><script type="math/tex; mode=display">G _ { t:t+n }= R _ { t + 1 } + \gamma R _ { t + 2 } + \ldots + \gamma ^ { n - 1 } R _ { t + n } + \gamma ^ { n } Q_{t+n-1} \left( S _ { t + n } , A_{t+n}\right)</script><p>则可以把Sarsa用n-步Q收获来表示得到n步Sarsa更新公式，如下式：</p><script type="math/tex; mode=display">Q \left( S _ { t } , A _ { t } \right) \leftarrow Q \left( S _ { t } , A _ { t } \right) + \alpha \left( G _ { t:t+n } - Q \left( S _ { t } , A _ { t } \right) \right)</script><h4 id="sarsa-λ"><a href="#sarsa-λ" class="headerlink" title="sarsa(λ)"></a>sarsa(λ)</h4><p>后来注意到有效更新不仅可以针对任何 $n$ 步回报， 而且可以针对不同 $n$ 的任何平均 $n$ 步返回。 例如，可以对目标进行更新，该目标是两步回报的一半和四步回报的一半： $\frac{1}{2}G<em>{t:t+2}+\frac{1}{2}G</em>{t:t+4}$。 任何一组 $n$ 步返回都可以用这种方式平均，即使是无限集，<strong>只要分量返回的权重为正并且总和为1</strong>。</p><p>sarsa(λ)算法可以理解为平均 $n$ 步更新的一种特定方式。 该平均值包含所有 $n$ 步更新，每个更新按比例加权到 $\lambda^{n-1}$（其中$ \lambda \in [0,1]$），并按因子 $1−\lambda$ 归一化，以确保权重总和为1。 结果更新是针对回报，称为 λ回报：</p><script type="math/tex; mode=display">q _ { t } ^ { \lambda } = ( 1 - \lambda ) \sum _ { n = 1 } ^ { \infty } \lambda ^ { n - 1 } G _ { t:t+n }</script><p>同上面说的$\frac{1}{2}G<em>{t:t+2}+\frac{1}{2}G</em>{t:t+4}$例子一样，这个公式只是给每一步的G加了权值而已，且这个权值按照距离当前状态的远近程度赋值，距离远的权值大，距离近的权值小</p><p>现在用这个λ回报来更新Q值，则可以得到Sarsa(λ)的更新公式</p><script type="math/tex; mode=display">Q \left( S _ { t } , A _ { t } \right) \leftarrow Q \left( S _ { t } , A _ { t } \right) + \alpha \left( q _ { t } ^ { \lambda } - Q \left( S _ { t } , A _ { t } \right) \right)</script><p>但这个公式太复杂了，还得存所有Episode，不方便学习。为了解决这个问题，我们引入效用追踪（Eligibility Trace）概念。不同的是这次的E值针对的不是一个状态，而是一个状态行为对：</p><script type="math/tex; mode=display">\begin{array} { c } { E _ { 0 } ( s , a ) = 0 } \\ { E _ { t } ( s , a ) = \gamma \lambda E _ { t - 1 } ( s , a ) + 1 \left( S _ { t } = s , A _ { t } = a \right) } \end{array}</script><p>它体现的是一个结果与某一个状态行为对的因果关系，与得到结果最近的状态行为对，以及那些在此之前频繁发生的状态行为对对得到这个结果的影响最大。</p><p>下式是引入ET概念的SARSA(λ)之后的Q值更新描述：</p><script type="math/tex; mode=display">\begin{aligned} E _ { t } ( s , a ) &= \gamma \lambda E _ { t - 1 } ( s , a ) + 1 \left( S _ { t } = s , A _ { t } = a \right)\\\delta _ { t } = & R _ { t + 1 } + \gamma Q \left( S _ { t + 1 } , A _ { t + 1 } \right) - Q \left( S _ { t } , A _ { t } \right) \\ & Q ( s , a ) \leftarrow Q ( s , a ) + \alpha \delta _ { t } E _ { t } ( s , a ) \end{aligned}</script><p>引入ET概念，同时使用SARSA(λ)将可以更有效的在线学习，因为不必要学习完整的Episode，数据用完即可丢弃。ET通常也是更多应用在在线学习算法中(online algorithm)。</p><h3 id="算法伪代码-2"><a href="#算法伪代码-2" class="headerlink" title="算法伪代码"></a>算法伪代码</h3><p><img alt="Sarsa(λ)算法" data-src="//orangesching.github.io/2019/12/06/算法/机器学习/强化学习/强化学习算法/Sarsa(λ" class="lazyload">算法.png)</p><p>Sarsa(λ)在算法中引入了E表，更新时要更新Q表和E表</p><h2 id="例-2"><a href="#例-2" class="headerlink" title="例"></a>例</h2><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><p><img alt="Q学习算法例" data-src="//orangesching.github.io/2019/12/06/算法/机器学习/强化学习/强化学习算法/Q学习算法例.png" class="lazyload"></p><p>玩上述游戏，黄色圆为宝藏，黑色方框为黑洞，进入黑洞奖励为-1，获得宝藏奖励+1，其他情况奖励为0。</p><p>迭代代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 学习 100 回合</span></span><br><span class="line">    <span class="keyword">for</span> episode <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">        <span class="comment"># 初始化 state 的观测值</span></span><br><span class="line">        observation = env.reset()</span><br><span class="line">    RL.eligibility_trace *= <span class="number">0</span>   <span class="comment">#eligibility trace 只是记录每个回合的每一步, 新回合开始的时候需要将 Trace 清零</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="comment"># 更新可视化环境</span></span><br><span class="line">            env.render()</span><br><span class="line"></span><br><span class="line">            <span class="comment"># RL 大脑根据 state 的观测值挑选 action</span></span><br><span class="line">            action = RL.choose_action(str(observation))</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 探索者在环境中实施这个 action, 并得到环境返回的下一个 state 观测值, reward 和 done (是否是掉下地狱或者升上天堂)</span></span><br><span class="line">            observation_, reward, done = env.step(action)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 决策下一个行动，与Q学习不同</span></span><br><span class="line">            action_ = RL.choose_action(str(observation_))</span><br><span class="line"></span><br><span class="line">            <span class="comment"># RL 从这个序列 (state, action, reward, state_) 中学习</span></span><br><span class="line">            RL.learn(str(observation), action, reward, str(observation_), action_)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 将下一个 state 的值传到下一次循环</span></span><br><span class="line">            observation = observation_</span><br><span class="line">            action = action_ <span class="comment">#与Q学习不同，这个动作真实执行了</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 如果掉下地狱或者升上天堂, 这回合就结束了</span></span><br><span class="line">            <span class="keyword">if</span> done:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment"># 结束游戏并关闭窗口</span></span><br><span class="line">    print(<span class="string">'game over'</span>)</span><br><span class="line">    env.destroy()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="comment"># 定义环境 env 和 RL 方式</span></span><br><span class="line">    env = Maze()</span><br><span class="line">    RL = QLearningTable(actions=list(range(env.n_actions)))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 开始可视化环境 env</span></span><br><span class="line">    env.after(<span class="number">100</span>, update)</span><br><span class="line">    env.mainloop()</span><br></pre></td></tr></table></figure><p>Sarsa(λ)学习代码（个体类）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SarsaLambdaTable</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, actions, learning_rate=<span class="number">0.01</span>, reward_decay=<span class="number">0.9</span>, e_greedy=<span class="number">0.9</span>, trace_decay=<span class="number">0.1</span>)</span>:</span></span><br><span class="line">        self.actions = actions  <span class="comment"># a list</span></span><br><span class="line">        self.lr = learning_rate  <span class="comment"># 学习速率</span></span><br><span class="line">        self.gamma = reward_decay  <span class="comment"># 衰减系数</span></span><br><span class="line">        self.epsilon = e_greedy  <span class="comment"># 以多少概率去探索</span></span><br><span class="line">        self.q_table = pd.DataFrame(columns=self.actions, dtype=np.float64)  <span class="comment"># Q表，学习的关键！</span></span><br><span class="line">        self.lambda_ = trace_decay</span><br><span class="line">        self.eligibility_trace = self.q_table.copy()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 依据策略（ε-贪婪策略）选择一个动作</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">choose_action</span><span class="params">(self, observation)</span>:</span></span><br><span class="line">        self.check_state_exist(observation)  <span class="comment"># 如果状态没遇到过就加入Q表</span></span><br><span class="line">        <span class="comment"># action selection</span></span><br><span class="line">        <span class="keyword">if</span> np.random.uniform() &lt; self.epsilon:</span><br><span class="line">            <span class="comment"># choose best action</span></span><br><span class="line">            state_action = self.q_table.loc[observation, :]</span><br><span class="line">            <span class="comment"># 不直接使用max函数，防止相同值时每次都选择同一个动作</span></span><br><span class="line">            action = np.random.choice(state_action[state_action == np.max(state_action)].index)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># choose random action</span></span><br><span class="line">            action = np.random.choice(self.actions)</span><br><span class="line">        <span class="keyword">return</span> action</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 更新Q表中的值</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">learn</span><span class="params">(self, s, a, r, s_, a_)</span>:</span></span><br><span class="line">        self.check_state_exist(s_)</span><br><span class="line">        q_predict = self.q_table.ix[s, a]  <span class="comment"># 估计值</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计算现实值</span></span><br><span class="line">        <span class="keyword">if</span> s_ != <span class="string">'terminal'</span>:</span><br><span class="line">            q_target = r + self.gamma * self.q_table.ix[s_, a_]  <span class="comment"># next state is not terminal</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            q_target = r  <span class="comment"># next state is terminal</span></span><br><span class="line">        error = q_target - q_predict  <span class="comment"># update</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Method 1:</span></span><br><span class="line">        self.eligibility_trace.ix[s, a] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Method 2:</span></span><br><span class="line">        self.eligibility_trace.ix[s, a] *= <span class="number">0</span></span><br><span class="line">        self.eligibility_trace.ix[s, a] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Q update</span></span><br><span class="line">        self.q_table += self.lr * error * self.eligibility_trace</span><br><span class="line"></span><br><span class="line">        self.eligibility_trace *= self.gamma * self.lambda_</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 检查是否有此状态，没有就添加</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">check_state_exist</span><span class="params">(self, state)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> state <span class="keyword">not</span> <span class="keyword">in</span> self.q_table.index:</span><br><span class="line">            to_be_append = pd.Series(</span><br><span class="line">                [<span class="number">0</span>] * len(self.actions),</span><br><span class="line">                index=self.q_table.columns,</span><br><span class="line">                name=state,</span><br><span class="line">            )</span><br><span class="line">            <span class="comment"># append new state to q table</span></span><br><span class="line">            self.q_table = self.q_table.append(to_be_append)</span><br><span class="line">            <span class="comment"># append new state to e table</span></span><br><span class="line">            self.eligibility_trace = self.eligibility_trace.append(to_be_append)</span><br></pre></td></tr></table></figure><p><img alt="Sarsa(λ)两种更新算法" data-src="//orangesching.github.io/2019/12/06/算法/机器学习/强化学习/强化学习算法/Sarsa(λ" class="lazyload">两种更新算法.png)</p><h1 id="DQN（Deep-Q-learning）"><a href="#DQN（Deep-Q-learning）" class="headerlink" title="DQN（Deep Q learning）"></a>DQN（Deep Q learning）</h1>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 机器学习 </category>
          
          <category> 强化学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 强化学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>强化学习实践——程序建模模板及Gym使用</title>
      <link href="/2019/12/05/%E7%AE%97%E6%B3%95/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B51%E2%80%94%E2%80%94%E7%A8%8B%E5%BA%8F%E5%BB%BA%E6%A8%A1%E6%A8%A1%E6%9D%BF%E5%8F%8AGym%E4%BD%BF%E7%94%A8/"/>
      <url>/2019/12/05/%E7%AE%97%E6%B3%95/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B51%E2%80%94%E2%80%94%E7%A8%8B%E5%BA%8F%E5%BB%BA%E6%A8%A1%E6%A8%A1%E6%9D%BF%E5%8F%8AGym%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="强化学习解决问题的设计流程"><a href="#强化学习解决问题的设计流程" class="headerlink" title="强化学习解决问题的设计流程"></a>强化学习解决问题的设计流程</h1><ol><li>将实际问题建模成马尔可夫决策过程，抽象出五元组（状态集、动作集、状态转移概率、奖励函数、折扣因子），  其中奖励与实际目标相关联</li><li>根据动作是否连续选择对应的算法</li></ol><h1 id="强化学习的两类对象"><a href="#强化学习的两类对象" class="headerlink" title="强化学习的两类对象"></a>强化学习的两类对象</h1><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>需要存储的信息</p><ol><li>所有可能状态集</li><li>智能体的行动集</li><li>智能体当前状态</li></ol><p>需要做的事</p><ol><li>响应智能体行为，更新环境，给予智能体即时奖励</li><li>给予个体观测值</li><li>终止交互的条件</li></ol><p>环境模板就不给出了，gym库在设计环境和个体交互时有规范的接口，可以借鉴他们的规范和接口</p><h2 id="个体"><a href="#个体" class="headerlink" title="个体"></a>个体</h2><p>需要存储的信息</p><ol><li>环境对象信息</li><li>状态信息</li></ol><p>需要做的事：</p><ol><li>观察功能：获得环境信息，哪些行为是允许的，获得的奖励</li><li>决策功能：根据当前观测来判断下一时刻该采取什么行为，按照一个策略产生一个行动</li><li>执行行动功能</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Agent</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, env: Env， )</span>:</span></span><br><span class="line">        self.env = env      <span class="comment"># 个体持有环境的引用</span></span><br><span class="line">        self.state = <span class="literal">None</span>   <span class="comment"># 个体当前的观测，最好写成obs.</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">choose_action</span><span class="params">(self, state)</span>:</span> <span class="keyword">pass</span> <span class="comment"># 执行一个策略，选择一个行为</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">act</span><span class="params">(self, a)</span>:</span>       <span class="comment"># 执行一个行为</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">learn</span><span class="params">(self， s, a, r, s_)</span>:</span> <span class="keyword">pass</span>   <span class="comment"># 学习过程</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">check_state_exist</span><span class="params">(self, state)</span></span></span><br></pre></td></tr></table></figure><h1 id="Gym"><a href="#Gym" class="headerlink" title="Gym"></a>Gym</h1><p>gym主要用于生成常见的强化学习环境，方便学习，即相当于给你写好了上面的环境类，你只需要写智能体类了。</p><p>gym的官方网址在：<a href="https://link.zhihu.com/?target=https%3A//gym.openai.com/" target="_blank" rel="noopener">这里</a>，其库代码托管地址在：<a href="https://link.zhihu.com/?target=https%3A//github.com/openai/gym/tree/master/gym" target="_blank" rel="noopener">这里</a></p><h2 id="Gym的安装"><a href="#Gym的安装" class="headerlink" title="Gym的安装"></a>Gym的安装</h2><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p>OpenAI官网没有说支持Windows，最好不要在Window上跑，因为我看视频写博客都在Windows了，就硬着头皮装了 ，没想到居然好像能用</p><p>找到Anaconda3的开始菜单目录，找到指令终端：<strong>Anaconda Prompt</strong>。</p><p>较老版本的Anaconda3这里没有这一项，无妨，可以去Anaconda3的安装文件夹下去找。运行这个cmd.exe，切记以管理员身份运行。</p><p>在指令终端输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install gym</span><br></pre></td></tr></table></figure><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><p>Anaconda创建虚拟环境 conda create –-name 你要创建的名字 python=版本号，例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create –-name gymlab python=3.5</span><br></pre></td></tr></table></figure><p>操作完此步之后，会在anaconda3/envs文件夹下多一个gymlab。Python3.5就在gymlab下得lib文件夹中。</p><p>开一个新的终端激活虚拟环境</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source activate gymlab</span><br></pre></td></tr></table></figure><p>下载gym</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone [openai/gym](https://github.com/openai/gym.git)</span><br></pre></td></tr></table></figure><p>安装gym，会装一系列的库，如果报错可以先安装依赖项，键入命令sudo apt-get install -y python-numpy python-dev cmake zlib1g-dev libjpeg-dev xvfb libav-tools xorg-dev python-opengl libboost-all-dev libsdl2-dev swig</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd gym</span><br><span class="line">pip install –e &apos;.[all]&apos;</span><br></pre></td></tr></table></figure><p>装完后可以将你的gym安装文件的目录写到环境变量中，打开.bashrc文件，在末尾加入语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PYTHONPATH= [your gymPath]：$PYTHONPATH</span><br></pre></td></tr></table></figure><h3 id="验证安装成功"><a href="#验证安装成功" class="headerlink" title="验证安装成功"></a>验证安装成功</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gym env = gym.make(<span class="string">'CartPole-v0'</span>) </span><br><span class="line">env.reset() </span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">1000</span>):    </span><br><span class="line">    env.render()    </span><br><span class="line">    env.step(env.action_space.sample())</span><br></pre></td></tr></table></figure><h2 id="Gym的使用"><a href="#Gym的使用" class="headerlink" title="Gym的使用"></a>Gym的使用</h2><p>使用gym编写自己的Agent代码，需要在在Agent类中声明一个env变量，指向对应的环境类，个体使用自己的代码产生一个行为，将该行为送入env的step方法中，可通过 render()显示图像</p><p>重要的四个函数</p><ul><li>env = gym.make(‘环境名’);</li><li>env.reset()</li><li>env.render()</li><li>env.step()</li></ul><h3 id="gym-make-‘环境名’-：建立环境类对象"><a href="#gym-make-‘环境名’-：建立环境类对象" class="headerlink" title="gym.make(‘环境名’)：建立环境类对象"></a>gym.make(‘环境名’)：建立环境类对象</h3><p>在自己的代码中建立环境类对象呢</p><ol><li>在gym库里注册了的对象，你只要使用下面的语句：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import gym</span><br><span class="line">env = gym.make(&quot;registered_env_name&quot;)</span><br></pre></td></tr></table></figure><p>其中不同的环境类有不同的注册名，只要把make方法内的字符串改成对应的环境名就可以了。</p><ol><li>使用自己编写的未注册的环境类，这种很简单，同一般的建立对象的语句没什么区别：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">env = MyEnvClassName()</span><br></pre></td></tr></table></figure><h3 id="reset-：重新初始化函数"><a href="#reset-：重新初始化函数" class="headerlink" title="reset()：重新初始化函数"></a>reset()：重新初始化函数</h3><p>在强化学习算法中，智能体需要一次次地尝试，累积经验，然后从经验中学到好的动作。一次尝试我们称之为一条轨迹或一个episode. 每次尝试都要到达终止状态. 一次尝试结束后，智能体需要从头开始，这就需要智能体具有重新初始化的功能。函数reset()就是这个作用。</p><p>reset()的源代码为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_reset</span><span class="params">()</span></span></span><br><span class="line">    self.state = self.np_random.uniform(low=-0.05, high=0.05, size=(4,))  #利用均匀随机分布初试化环境的状态</span><br><span class="line">    self.steps_beyond_done = <span class="literal">None</span>  <span class="comment">#设置当前步数为None</span></span><br><span class="line">    <span class="keyword">return</span> np.array(self.state)  <span class="comment">#返回环境的初始化状态</span></span><br></pre></td></tr></table></figure><h3 id="render-：图像引擎"><a href="#render-：图像引擎" class="headerlink" title="render()：图像引擎"></a>render()：图像引擎</h3><p>render()函数在这里扮演图像引擎的角色。一个仿真环境必不可少的两部分是物理引擎和图像引擎。物理引擎模拟环境中物体的运动规律；图像引擎用来显示环境中的物体图像。其实，对于强化学习算法，该函数可以没有。但是，为了便于直观显示当前环境中物体的状态，图像引擎还是有必要的。另外，加入图像引擎可以方便我们调试代码。</p><h3 id="step-：物理引擎"><a href="#step-：物理引擎" class="headerlink" title="step()：物理引擎"></a>step()：物理引擎</h3><p>该函数在仿真器中扮演物理引擎的角色。它描述了智能体与环境交互的所有信息，是环境文件中最重要的函数。在该函数中，一般利用智能体的运动学模型和动力学模型计算下一步的状态和立即回报，并判断是否达到终止状态。</p><ul><li><p>输入：动作a</p></li><li><p>输出：下一步状态，立即回报，是否终止，调试项。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">state, reward, is_done, info = env.step(a)</span><br></pre></td></tr></table></figure><p>state 是一个元组或numpy数组，其提供的信息维度应与观测空间的维度一样、每一个维度的具体指在制定的low与high之间，保证state信息符合这些条件是env类的_step方法负责的事情。</p><p>reward 则是根据环境的动力学给出的即时奖励，它就是一个数值。</p><p>is_done 是一个布尔变量，True或False，你可以根据具体的值来安排个体的后续动作。</p><p>info 提供的数据因环境的不同差异很大，通常它的结构是一个字典：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;key1&quot;:data1,&quot;key2&quot;:data2,...&#125;</span><br></pre></td></tr></table></figure><h3 id="例"><a href="#例" class="headerlink" title="例"></a>例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gym <span class="keyword">import</span> time </span><br><span class="line">env = gym.make(<span class="string">'CartPole-v0'</span>)   <span class="comment">#创造环境 </span></span><br><span class="line">observation = env.reset()   <span class="comment">#初始化环境，observation为环境状态</span></span><br><span class="line">count = <span class="number">0</span> </span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> range(<span class="number">100</span>):    </span><br><span class="line">    action = env.action_space.sample()  <span class="comment">#随机采样动作    </span></span><br><span class="line">    observation, reward, done, info = env.step(action)  <span class="comment">#与环境交互，获得下一步的时刻的观察值，奖励    </span></span><br><span class="line">    <span class="keyword">if</span> done:                     </span><br><span class="line">        <span class="keyword">break</span>    </span><br><span class="line">    env.render()         <span class="comment">#绘制场景    </span></span><br><span class="line">    count+=<span class="number">1</span>    </span><br><span class="line">    time.sleep(<span class="number">0.2</span>)      <span class="comment">#每次等待0.2s </span></span><br><span class="line">print(count)             <span class="comment">#打印该次尝试的步数</span></span><br></pre></td></tr></table></figure><h2 id="自定义环境类"><a href="#自定义环境类" class="headerlink" title="自定义环境类"></a>自定义环境类</h2><p>gym库的核心在文件core.py里，里面定义了两个最基本的类Env和Space。前者是所有环境类的基类，后者是所有空间类的基类。</p><h3 id="Env类"><a href="#Env类" class="headerlink" title="Env类"></a>Env类</h3><p>自定义类的时候继承这个Env基类，并重写里面的一些方法，就可以实现自己的环境类了</p><p>要实现的方法有：</p><ul><li><strong>_reset(self)</strong>：初始化，开启个体与环境交互前调用该方法，确定个体的初始状态以及其他可能的一些初始化设置</li><li><strong>_step(self, action)</strong>：物理引擎（重要部分），确定个体的下一个状态、奖励信息、是否Episode终止，以及一些额外的信息</li><li><strong>_render(self, mode=’human’, close=False)</strong>：图像引擎，如果需要将个体与环境的交互以动画的形式展示出来的话，需要重写该方法。简单的UI设计可以用gym包装好了的pyglet方法来实现，这些方法在rendering.py文件里定义。具体使用这些方法进行UI绘制需要了解基本的OpenGL编程思想和接口</li><li><strong>_seed(self, seed=None)</strong> ：设置随机数种子</li><li><strong>_close（可选）</strong>：可以不实现</li></ul><p>要设置的参数有：</p><ul><li><strong>action_space 动作空间</strong>：一个描述所有有效动作的Space对象</li><li><strong>observation_space 观察空间</strong>：一个描述所有有效观察的Space对象</li><li><strong>reward_range 奖励范围</strong>：一个包含最大最小可能奖励的元组</li></ul><p>环境基类的一段解释：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">class Env(object):</span><br><span class="line">    &quot;&quot;&quot;The main OpenAI Gym class. It encapsulates an environment with</span><br><span class="line">    arbitrary behind-the-scenes dynamics. An environment can be</span><br><span class="line">    partially or fully observed.</span><br><span class="line">    The main API methods that users of this class need to know are:</span><br><span class="line">        step</span><br><span class="line">        reset</span><br><span class="line">        render</span><br><span class="line">        close</span><br><span class="line">        seed</span><br><span class="line">    When implementing an environment, override the following methods</span><br><span class="line">    in your subclass:</span><br><span class="line">        _step</span><br><span class="line">        _reset</span><br><span class="line">        _render</span><br><span class="line">        _close</span><br><span class="line">        _seed</span><br><span class="line">    And set the following attributes:</span><br><span class="line">        action_space: The Space object corresponding to valid actions</span><br><span class="line">        observation_space: The Space object corresponding to valid observations</span><br><span class="line">        reward_range: A tuple corresponding to the min and max possible rewards</span><br><span class="line">    Note: a default reward range set to [-inf,+inf] already exists. Set it if you want a narrower range.</span><br><span class="line">    The methods are accessed publicly as &quot;step&quot;, &quot;reset&quot;, etc.. The</span><br><span class="line">    non-underscored versions are wrapper methods to which we may add</span><br><span class="line">    functionality over time.</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    # Override in SOME subclasses</span><br><span class="line">    def _close(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    # Set these in ALL subclasses</span><br><span class="line">    action_space = None</span><br><span class="line">    observation_space = None</span><br><span class="line"></span><br><span class="line">    # Override in ALL subclasses</span><br><span class="line">    def _step(self, action): raise NotImplementedError</span><br><span class="line">    def _reset(self): raise NotImplementedError</span><br><span class="line">    def _render(self, mode=&apos;human&apos;, close=False): return</span><br><span class="line">    def _seed(self, seed=None): return []</span><br></pre></td></tr></table></figure><h3 id="Space类"><a href="#Space类" class="headerlink" title="Space类"></a>Space类</h3><p>用来描述空间的，比如行为空间，状态空间等。从Space基类衍生出几个常用的空间类，其中最主要的是<strong>Discrete类</strong>和<strong>Box</strong>类。前者对应于一维离散空间，后者对应于多维连续空间。它们既可以应用在行为空间中，也可以用来描述状态空间，具体怎么用看问题本身。</p><p>例如：</p><p>如果我要描述上篇提到的一个4*4的格子世界，其一共有16个状态，每一个状态只需要用一个数字来描述，这样我可以把这个问题的状态空间用Discrete(16)对象来描述就可以了。</p><p>对于另外一个经典的小车爬山的问题，小车的状态是用两个变量来描述的，一个是小车对应目标旗杆的水平距离，另一个是小车的速度（是沿坡度切线方向的速率还是速度在水平方向的分量这个没仔细研究），因此环境要描述小车的状态需要2个连续的变量。由于描述小车的状态数据对个体完全可见，因此小车的状态空间即是小车的观测空间，此时再用Discrete来描述就不行了，要用Box类，Box空间可以定义多维空间，每一个维度可以用一个最低值和最大值来约束。同时小车作为个体可以执行的行为只有3个：左侧加速、不加速、右侧加速。因此行为空间可以用Discrete来描述。最终，该环境类的观测空间和行为空间描述如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">self.min_position = <span class="number">-1.2</span></span><br><span class="line">self.max_position = <span class="number">0.6</span></span><br><span class="line">self.max_speed = <span class="number">0.07</span></span><br><span class="line">self.goal_position = <span class="number">0.5</span> </span><br><span class="line">self.low = np.array([self.min_position, -self.max_speed])</span><br><span class="line">self.high = np.array([self.max_position, self.max_speed])</span><br><span class="line">self.action_space = spaces.Discrete(<span class="number">3</span>)  <span class="comment">#一个参数n</span></span><br><span class="line">self.observation_space = spaces.Box(self.low, self.high)  <span class="comment">#每个维度的最小最大值</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 机器学习 </category>
          
          <category> 强化学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 强化学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>强化学习基础5——总结</title>
      <link href="/2019/12/04/%E7%AE%97%E6%B3%95/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%805%E2%80%94%E2%80%94%E6%80%BB%E7%BB%93/"/>
      <url>/2019/12/04/%E7%AE%97%E6%B3%95/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%805%E2%80%94%E2%80%94%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="强化学习问题提出"><a href="#强化学习问题提出" class="headerlink" title="强化学习问题提出"></a>强化学习问题提出</h1><p>强化学习是解决<strong>序列决策问题</strong>，即<strong>状态-&gt;行动-&gt;新状态…..-&gt;终点</strong> 这一系列动作的决策，做出的决策要<strong>最大化总的奖励</strong>，</p><p>其中有很多概念，要理解清楚：</p><ul><li>历史：【观察，行为，奖励】构成的序列</li><li>状态：对历史信息的总结，决定奖励啊行为的信息，不等于观察值</li><li>行动：智能体做的动作</li><li>奖励：环境对智能体动作的即时反馈</li><li>策略：决定智能体行为的机制，状态到行为的映射</li><li>价值函数：未来奖励的预测，用来评价当前状态的好坏程度</li><li>模型：智能体对环境的建模。至少要解决 状态转移概率 和 预测可获得的即时奖励 两个问题</li></ul><p>其中智能体可由三个部分组成：策略、价值函数、模型</p><h1 id="马尔科夫全家桶"><a href="#马尔科夫全家桶" class="headerlink" title="马尔科夫全家桶"></a>马尔科夫全家桶</h1><h2 id="马尔科夫性"><a href="#马尔科夫性" class="headerlink" title="马尔科夫性"></a>马尔科夫性</h2><p>定义：未来只依赖于最近给定的状态，则认为这个状态有<strong>马尔科夫性</strong></p><p><strong>转移概率公式</strong>和<strong>转移概率矩阵</strong>可用来表示当前任意状态转移到其他状态的概率</p><script type="math/tex; mode=display">\mathcal{P}_{s s^{\prime}}=\mathrm{P}\left[S_{t+1}=s^{\prime} | S_{t}=s\right]</script><h2 id="马尔科夫过程（马尔科夫链）"><a href="#马尔科夫过程（马尔科夫链）" class="headerlink" title="马尔科夫过程（马尔科夫链）"></a>马尔科夫过程（马尔科夫链）</h2><p>由有限具有马尔科夫性的状态和状态转移概率组成的马尔科夫链</p><p>可以用一个元组$<s, \mathcal{p}>$表示</s,></p><ul><li>$S$ 是具有马尔科夫性的有限随机状态集${\mathrm{S}_1，\mathrm{S}_2，\cdots}$</li><li>$\mathcal{P}$是状态之间的转移概率矩阵</li></ul><h2 id="马尔科夫奖励过程"><a href="#马尔科夫奖励过程" class="headerlink" title="马尔科夫奖励过程"></a>马尔科夫奖励过程</h2><p>在马尔科夫过程的基础上加入奖励和衰减系数，我们要做的是评价这个策略</p><p>可以用四元组$<s, p, r, \gamma>$表示</s,></p><ul><li>$S$ 是具有马尔科夫性的有限随机状态集${\mathrm{S}_1，\mathrm{S}_2，\cdots}$</li><li>$\mathcal{P}$是状态之间的转移概率矩阵</li><li>$R$是<strong>即时奖励</strong>，即离开状态s可获得的奖励，与下一刻去哪无关，$R<em>{s}=E\left[R</em>{t+1} | S_{t}=s\right]$</li><li>$\gamma$是衰减系数，用在计算收益中</li></ul><p>由于即时奖励$R$，与具体的下一状态没有关系，引入<strong>收益（Return）$G_t$</strong>，来量化一个片段（Episode）的奖励和</p><script type="math/tex; mode=display">G_{t}=R_{t+1}+\gamma R_{t+2}+\ldots=\sum_{k=0}^{\infty} \gamma^{k} R_{t+k+1}</script><p>又因为收益$G_t$只是针对一个Episode，不是针对长期的过程，不能用来评估整个马尔科夫奖励过程的收益，所以引入<strong>价值函数（Value Function）</strong>来衡量某一状态或行为的长期价值（计算方式：只要一个Episode出现了状态s，就把这个Episode的收益加进去，最后除以加进去Episode的数量）</p><script type="math/tex; mode=display">v(s)=E\left[G_{t} | S_{t}=s\right]</script><p>因为这个价值函数的公式算起来很复杂（要记录所有Episode），所以引入Bellman方程，得到<strong>价值函数的Bellman期望方程</strong>（计算方式：该状态的即时奖励 + 遍历该状态的各个后继状态，对于每一个后继状态：$\gamma$  × 状态转移概率  × 后继状态的值函数 求和）</p><script type="math/tex; mode=display">v(s)=\mathcal{R}_{s}+\gamma \sum_{s^{\prime} \in \mathcal{S}} \mathcal{P}_{s s^{\prime}} v\left(s^{\prime}\right)</script><p>这个公式把刚刚复杂的公式分成了两个部分：状态s的即时奖励和下一时刻的价值期望，这样就可以很方便的用递归或者迭代的方式求解</p><p>再进一步，转化为矩阵形式</p><script type="math/tex; mode=display">\begin{aligned} v & = \mathcal { R } + \gamma \mathcal { P } v \\ ( I - \gamma \mathcal { P } ) v & = \mathcal { R } \\ v & = ( l - \gamma \mathcal { P } ) ^ { - 1 } \mathcal { R } \end{aligned}</script><h2 id="马尔科夫决策过程（最终用来描述强化学习问题）"><a href="#马尔科夫决策过程（最终用来描述强化学习问题）" class="headerlink" title="马尔科夫决策过程（最终用来描述强化学习问题）"></a>马尔科夫决策过程（最终用来描述强化学习问题）</h2><p>在马尔科夫奖励过程的基础上加入动作</p><p>可以用一个五元组$M=(S,A,P,R,\gamma)$描述</p><ul><li><p>$ S $：表示状态集(states)，有$s \in S$，$s_i$ 表示第 $i$ 步的状态。</p></li><li><p>$A$：表示一组动作(actions)，有$a \in A$，$a_i$ 表示第 $i$ 步的动作。</p></li><li><p>$P$：表示状态转移概率。表示的是在当前$s \in S$状态下，经过$a \in A$作用后，会转移到的其他状态的概率分布情况。比如，在状态$s$下执行动作$a$，转移到$s’$的概率可以表示为$p(s’|s,a)$，具体的数学表达式如下：</p><script type="math/tex; mode=display">\mathcal{P}_{s s^{\prime}}^{a}=\mathbb{P}\left[S_{t+1}=s^{\prime} | S_{t}=s, A_{t}=a\right]</script><p>（个人理解：马尔科夫奖励过程是在当前状态下选择到下一状态，而马尔可夫决策过程是在当前状态下先选择一个动作，这个动作会有不同的概率导向不同的新状态，智能体只能做这个动作，不能控制这个动作导向的状态，这个动作导向的结果由环境决定，所以马尔可夫决策过程很适合描述强化学习场景。这里的状态转移概率矩阵是三维的，第一维是当前状态，第二维是所做动作，第三维是下一状态，下面的回报函数同理）</p></li><li><p>$R$：回报函数(reward function)。$R(s, a)$ 描述了在状态 $s$做动作 $a$的奖励。与MRP的奖励与状态对应不同，<strong>MDP的奖励是与动作对应的</strong>，具体的数学表达式如下：</p><script type="math/tex; mode=display">\mathcal{R}_{s}^{a}=\mathbb{E}\left[R_{t+1} | S_{t}=s, A_{t}=a\right]</script></li><li><p>$\gamma$ ：衰减系数</p></li></ul><p>上述的状态转移概率只是做了某个动作后，从临时状态到某具体状态的转移概率。在某个状态做某一个动作的概率用<strong>策略(Policy)</strong>来表示。策略是概率的集合或分布，其元素是在某一状态s才去可能的行为a的概率：</p><script type="math/tex; mode=display">\pi ( a | s ) = \mathbb { P } \left[ A _ { t } = a | S _ { t } = s \right]</script><h3 id="评估策略"><a href="#评估策略" class="headerlink" title="评估策略"></a>评估策略</h3><h4 id="价值函数"><a href="#价值函数" class="headerlink" title="价值函数"></a>价值函数</h4><p>MDP的即时奖励，收益$G_t$与MRP一样，但是因为引入了动作，所以价值函数不一样了，MDP的价值函数分为两种</p><ul><li><strong>状态价值函数$v_\pi(s)$</strong>  ，表示从状态$s$开始，<strong>遵循当前策略</strong>时所获得的收获的期望；或者说在执行当前策略 $\pi$ 时，衡量个体处在状态 $s$ 时的价值大小。数学表示如下：</li></ul><script type="math/tex; mode=display">v _ { \pi } ( s ) = \mathbb { E } _ { \pi } \left[ G _ { t } | S _ { t } = s \right]</script><ul><li><p><strong>行为价值函数$q_\pi(s,a)$</strong>，表示在执行策略 $\pi$ 时，对当前状态 $s$ 执行某一具体行为 $a$ 所能的到的收获的期望；或者说在遵循当前策略π时，衡量对当前状态执行行为a的价值大小。行为价值函数一般都是与某一特定的状态相对应的，更精细的描述是<strong>状态-行为</strong>价值函数。行为价值函数的公式描述如下：</p><script type="math/tex; mode=display">q _ { \pi } ( s , a ) = \mathbb { E } _ { \pi } \left[ G _ { t } | S _ { t } = s , A _ { t } = a \right]</script></li><li><p>两者的关系</p><script type="math/tex; mode=display">v _ { \pi } ( s ) = \sum _ { a \in A } \pi ( a | s ) q _ { \pi } ( s , a )\\q _ { \pi } ( s , a ) = \mathcal { R } _ { s } ^ { a } + \gamma \sum _ { s ^ { \prime } \in \mathcal { S } } \mathcal { P } _ { s s ^ { \prime } } ^ { a } v _ { \pi } \left( s ^ { \prime } \right)\\v _ { \pi } ( s ) = \sum _ { a \in \mathcal { A } } \pi ( a | s ) \left( \mathcal { R } _ { s } ^ { a } + \gamma \sum _ { s ^ { \prime } \in \mathcal { S } } \mathcal { P } _ { s s ^ { \prime } } ^ { a } v _ { \pi } \left( s ^ { \prime } \right) \right)\\q _ { \pi } ( s , a ) = \mathcal { R } _ { s } ^ { a } + \gamma \sum _ { s ^ { \prime } \in \mathcal { S } } \mathcal { P } _ { s s ^ { \prime } } ^ { a } \sum _ { a ^ { \prime } \in \mathcal { A } } \pi \left( a ^ { \prime } | s ^ { \prime } \right) q _ { \pi } \left( s ^ { \prime } , a ^ { \prime } \right)</script><p><strong>注:MDPs 中，任何不说明策略π 的情况下，讨论值函数都是在耍流氓！</strong></p></li></ul><h4 id="Bellman期望方程"><a href="#Bellman期望方程" class="headerlink" title="Bellman期望方程"></a>Bellman期望方程</h4><p>和 MRP 相似，MDPs 中的值函数也能分解成瞬时奖励和后继状态的值函数两部分的贝尔曼方程</p><script type="math/tex; mode=display">v _ { \pi } ( s ) = \mathbb { E } _ { \pi } \left[ R _ { t + 1 } + \gamma v _ { \pi } \left( S _ { t + 1 } \right) | S _ { t } = s \right]</script><script type="math/tex; mode=display">q _ { \pi } ( s , a ) = \mathbb { E } _ { \pi } \left[ R _ { t + 1 } + \gamma q _ { \pi } \left( S _ { t + 1 } , A _ { t + 1 } \right) | S _ { t } = s , A _ { t } = a \right]</script><p><strong>Bellman期望方程矩阵形式</strong></p><script type="math/tex; mode=display">v _ { \pi } = \mathcal { R } ^ { \pi } + \gamma \mathcal { P } ^ { \pi } v _ { \pi }</script><script type="math/tex; mode=display">v _ { \pi } = \left( l - \gamma \mathcal { P } ^ { \pi } \right) ^ { - 1 } \mathcal { R } ^ { \pi }</script><p>下面例子可以帮助理解计算，及区分MDP和MRP</p><p><img alt="MDPvsMRP" data-src="//orangesching.github.io/2019/12/04/算法/机器学习/强化学习/强化学习基础5——总结/MDPvsMRP.jpg" class="lazyload"></p><p>假如，现在你女朋友生日，你纠结要不要给他送口红，你的策略是：0.4的概率不给他送，0.6的概率给他送。你做了这个动作之后，你女朋友的心情对你来说就处于”又生又死的状态“，并且你会因为在生日这天送了他一只口红得到好感度加1的奖励。当你看向你女朋友时，他的心情会坍缩到具体的一个状态，坍缩的概率如图，可能你女朋友不喜欢这个色号他就不高兴，可能正中下怀她就非常高兴的发朋友圈了。</p><p>现在你想计算女朋友生日这个状态（无论做什么事），对你刷好感度到满级有多大意义（V函数），并且向计算在女朋友生日这天送口红，对你刷高感度到满级有多大意义（Q函数）。对于V函数，可以算我从这个状态出发做所有动作的意义平均值就好了。对于Q函数，可以算我做了这个动作的奖励+最后达到的女朋友状态的意义的平均值</p><h3 id="最优化策略"><a href="#最优化策略" class="headerlink" title="最优化策略"></a>最优化策略</h3><h4 id="最优策略的定义"><a href="#最优策略的定义" class="headerlink" title="最优策略的定义"></a>最优策略的定义</h4><ul><li>什么是最优策略</li></ul><p>当对于任何状态 $s$，遵循策略π的价值不小于遵循策略 $\pi’$ 下的价值，则策略 $\pi$ 优于策略 $\pi’$：</p><script type="math/tex; mode=display">\pi \geq \pi ^ { \prime } \text { if } v _ { \pi } ( s ) \geq v _ { \pi ^ { \prime } } ( s ) , \forall s</script><ul><li><strong>如何寻找最优策略</strong></li></ul><p>可以通过最大化最优行为价值函数来找到最优策略：</p><script type="math/tex; mode=display">\pi _ { * } ( a | s ) = \left\{ \begin{array} { l l } { 1 } & { \text { if } a = \underset { a \in \mathcal { A } } { \operatorname { argmax } } q _ { * } ( s , a ) } \\ { 0 } & { \text { otherwise } } \end{array} \right.</script><p>对于任何MDP问题，总存在一个确定性的最优策略；同时如果我们知道最优行为价值函数，则表明我们找到了最优策略。</p><p>针对 $v_*$ ，一个状态的最优价值等于从该状态出发采取的所有行为产生的行为价值中最大的那个行为价值：</p><script type="math/tex; mode=display">v _ { * } ( s ) = \max _ { a } q _ { * } ( s , a )</script><h4 id="Bellman最优方程"><a href="#Bellman最优方程" class="headerlink" title="Bellman最优方程"></a>Bellman最优方程</h4><p>针对 $v _ { * }$ ，有：</p><script type="math/tex; mode=display">v _ { * } ( s ) = \max _ { a } \mathcal { R } _ { s } ^ { a } + \gamma \sum _ { s ^ { \prime } \in \mathcal { S } } \mathcal { P } _ { s s ^ { \prime } } ^ { a } v _ { * } \left( s ^ { \prime } \right)</script><p>针对 $q _ { * }$ ，有：</p><script type="math/tex; mode=display">q _ { * } ( s , a ) = \mathcal { R } _ { s } ^ { a } + \gamma \sum _ { s ^ { \prime } \in \mathcal { S } } \mathcal { P } _ { s s ^ { \prime } } ^ { a } \max _ { a ^ { \prime } } q _ { * } \left( s ^ { \prime } , a ^ { \prime } \right)</script><h1 id="基于模型的动态规划问题"><a href="#基于模型的动态规划问题" class="headerlink" title="基于模型的动态规划问题"></a>基于模型的动态规划问题</h1><h2 id="策略迭代"><a href="#策略迭代" class="headerlink" title="策略迭代"></a>策略迭代</h2><p><strong>问题：</strong>寻找最优策略π</p><p><strong>解决方案：</strong>在当前策略上迭代计算$v$值，再根据$v$值贪婪地更新策略，如此反复多次，最终得到最优策略$\pi^<em>$ 和最优状态价值函数$V^</em>$  </p><p><strong>具体方法：</strong></p><ol><li><p>在给定的策略下迭代更新价值函数，采用Bellman期望方程，计算方法：</p><ul><li><p><strong>同步反向迭代</strong>，即在每次迭代过程中，对于第$k+1$ 次迭代，所有的状态s的价值用$v<em>k(s’)$ 计算并更新该状态第$k+1$  次迭代中使用的价值$v_k(S)$ ，其中$s’$是$s$的后继状态。此种方法通过反复迭代最终将收敛至$V</em>{\pi}$  。</p><script type="math/tex; mode=display">v _ { k + 1 } ( s ) = \sum _ { a \in A } \pi ( a | s ) \left( R _ { s } ^ { a } + \gamma \sum _ { s ^ { \prime } \in S } P _ { s s ^ { \prime } } ^ { a } v _ { k } \left( s ^ { \prime } \right) \right)</script><p>即：一次迭代内，状态s的价值等于前一次迭代该状态的即时奖励与所有s的下一个可能状态s’ 的价值与其概率乘积的和，如图示：</p><p>公式的矩阵形式是：</p><script type="math/tex; mode=display">\mathbf { v } ^ { k + 1 } = \mathcal { R } ^ { \pi } + \gamma \mathcal { P } ^ { \pi } \mathbf { v } ^ { k }</script></li><li><p><strong>异步反向迭代</strong>，即在第k次迭代使用<strong>当次</strong>迭代的状态价值来更新状态价值。</p></li></ul></li><li>在当前策略基础上，贪婪地选取行为，使得后继状态价值增加最多：<script type="math/tex; mode=display">\pi' = greedy(v_{\pi})</script></li></ol><p><img alt="policy_iteration_algorithm" data-src="//orangesching.github.io/2019/12/04/算法/机器学习/强化学习/强化学习基础5——总结/policy_iteration_algorithm.png" class="lazyload"></p><p><strong>改进策略迭代的方法</strong></p><p>有时候不需要持续迭代至最有价值函数，可以设置一些条件提前终止迭代</p><ul><li>比如设定一个$ \epsilon $，比较两次迭代的价值函数平方差</li><li>直接设置迭代次数</li></ul><h2 id="价值迭代"><a href="#价值迭代" class="headerlink" title="价值迭代"></a>价值迭代</h2><p><strong>问题：</strong>寻找最优策略π</p><p><strong>解决方案：</strong>采用Bellman最优方程，过程与策略迭代差不多，但整个过程中没有遵循任何策略，对每一个当前状态 s ,对每个可能的动作 a 都计算一下采取这个动作后到达的下一个状态的期望价值。看看哪个动作可以到达的状态的期望价值函数最大，就将这个最大的期望价值函数作为当前状态的价值函数 $V(s)$ ，循环执行这个步骤，直到价值函数收敛。</p><script type="math/tex; mode=display">V _ { k + 1 } ( s ) = \max _ { a } \sum _ { s ^ { \prime } , r } P \left( s ^ { \prime } , r | s , a \right) \left( r + \gamma V _ { k } \left( s ^ { \prime } \right) \right)</script><p><img alt="value_iteration_algorithm" data-src="//orangesching.github.io/2019/12/04/算法/机器学习/强化学习/强化学习基础5——总结/value_iteration_algorithm.png" class="lazyload"></p><p>对每一个当前状态 $s$ ,对每个可能的动作 $a$ 都计算一下采取这个动作后到达的下一个状态的期望价值。看看哪个动作可以到达的状态的期望价值函数最大，就将这个最大的期望价值函数作为当前状态的价值函数 $V(s)$ 循环执行这个步骤，直到价值函数收敛。</p><h2 id="价值迭代算法与策略迭代算法的区别"><a href="#价值迭代算法与策略迭代算法的区别" class="headerlink" title="价值迭代算法与策略迭代算法的区别"></a>价值迭代算法与策略迭代算法的区别</h2><ul><li>策略迭代有一个策略直接作用于value空间（即不会有value值来构建策略，策略再构建value值的过程）；而价值迭代过程其间得到的价值函数，不对应任何策略</li><li>价值迭代是根据状态期望值选择动作，而策略迭代是先估计状态值然后修改策略 </li></ul><h1 id="基于无模型的强化学习问题"><a href="#基于无模型的强化学习问题" class="headerlink" title="基于无模型的强化学习问题"></a>基于无模型的强化学习问题</h1>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 机器学习 </category>
          
          <category> 强化学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 强化学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>强化学习基础4——基于无模型的强化学习方法</title>
      <link href="/2019/12/02/%E7%AE%97%E6%B3%95/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%804%E2%80%94%E2%80%94%E5%9F%BA%E4%BA%8E%E6%97%A0%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
      <url>/2019/12/02/%E7%AE%97%E6%B3%95/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%804%E2%80%94%E2%80%94%E5%9F%BA%E4%BA%8E%E6%97%A0%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="简介-Introduction"><a href="#简介-Introduction" class="headerlink" title="简介 Introduction"></a>简介 Introduction</h1><p>马尔可夫决策过程可以利用元组$<s,a,p,r,\gamma>$来描述，而根据转移概率P是否已知，可以分为基于模型的动态规划方法和基于无模型的强化学习方法。这两类都包括策略迭代算法、值迭代算法、策略搜索算法。</s,a,p,r,\gamma></p><p>上一章学习了基于模型的动态规划方法，学习了如何从理论上解决一个<strong>已知</strong>的MDP：通过动态规划来评估一个给定的策略，并且得到最优价值函数，根据最优价值函数来确定最优策略；也可以直接进行不基于任何策略的状态价值迭代得到最优价值函数和最优策略。</p><p>这一章我们将讨论解决一个可以被认为是MDP、但却不掌握MDP具体细节（不知道环境是怎样的）的问题，也就是讲述如何直接从Agent与环境的交互来得得到一个估计的最优价值函数和最优策略。这部分内容分为两部分</p><ul><li><p>第一部分聚焦于策略评估，也就是预测，直白的说就是在给定的策略同时不清楚MDP细节的情况下，估计得到值函数。</p></li><li><p>第二部分将利用第一部分的策略评估的主要观念来进行控制进而找出最优策略，最大化Agent的奖励。</p></li></ul><h1 id="策略评估（无模型的预测）"><a href="#策略评估（无模型的预测）" class="headerlink" title="策略评估（无模型的预测）"></a>策略评估（无模型的预测）</h1><p>这部分内容分为三个小部分，分别是蒙特卡洛强化学习、时序差分强化学习和介于两者之间的$\lambda$时序差分强化学习</p><h2 id="蒙特卡洛强化学习-Monte-Carlo-Reinforcement-Learning"><a href="#蒙特卡洛强化学习-Monte-Carlo-Reinforcement-Learning" class="headerlink" title="蒙特卡洛强化学习 Monte-Carlo Reinforcement Learning"></a>蒙特卡洛强化学习 Monte-Carlo Reinforcement Learning</h2><h3 id="启发（为什么会想到这个方法）"><a href="#启发（为什么会想到这个方法）" class="headerlink" title="启发（为什么会想到这个方法）"></a>启发（为什么会想到这个方法）</h3><p>前面讲的主要内容是整个问题可以转换成一个马尔科夫决策过程(MDP)五元组，但是，在现实世界中，我们无法同时知道这个5元组。比如P，状态转移概率就很难知道，P不知道，我们就无法使用bellman方程来求解V和Q值。但是我们依然要去解决这个问题。怎么办？</p><p>一个想法是，虽然我不知道状态转移概率P，但是这个概率是真实存在的。我们可以直接去尝试，不断采样，然后会得到奖赏，通过奖赏来评估值函数。这个想法与蒙特卡罗方法的思想是一致的。我们可以尝试很多次，最后估计的V值就会很接近真实的V值了。</p><p><img alt="monte_carlo" data-src="//orangesching.github.io/2019/12/02/算法/机器学习/强化学习/强化学习基础4——基于无模型的强化学习方法/monte_carlo.png" class="lazyload"></p><p>比如上图，矩形的面积我们可以轻松得到，但是对于阴影部分的面积，我们积分是比较困难的。所以为了计算阴影部分的面积，我们可以在矩形上均匀地撒豆子，然后统计在阴影部分的豆子数占总的豆子数的比例，就可以估算出阴影部分的面积了</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><strong>蒙特卡洛强化学习</strong>：又叫统计模拟方法，在不清楚MDP状态转移及即时奖励的情况下，直接从经历过的<strong>完整Episode</strong>来学习状态价值，通常情况下<strong>某状态的价值等于在多个Episode中以该状态算得到的所有收益的平均</strong>。</p><p><strong>目标：</strong>在给定策略下，从一系列的完整Episode经历中学习得到该策略下的状态价值函数。</p><p><strong>蒙特卡洛强化学习的特点</strong>：不基于模型本身，直接从经历过的Episode中学习，必须是<strong>完整的Episode</strong></p><p><strong>蒙特卡洛强化学习使用的思想</strong>就是<strong>使用平均收获值代替价值</strong>。理论上Episode越多，结果越准确。</p><blockquote><p><strong>Episode</strong></p><p>episode就是经历，每条episode就是一条从起始状态到结束状态的经历。例如在走迷宫，一条episode就是从你开始进入迷宫，到最后走出迷宫的路径。</p><p>首先我们要得到的是某一个状态$s$的平均收获。所以我们说的episode要经过状态$s$。所以下图中第二条路径没有经过状态s，对于s来说就不能使用它了。而且最后我们episode都是要求达到终点的，才能算是一个episode。</p><img title="This is an example image" data-src="/2019/12/02/算法/机器学习/强化学习/强化学习基础4——基于无模型的强化学习方法/monte_carlo.png" class="lazyload"><p>Episode其包含的信息有：状态的转移、使用的行为序列、中间状态获得的即时奖励以及到达终止状态时获得的即时奖励。</p><p>完整的Episode 指必须从某一个状态开始，Agent与Environment交互直到终止状态，环境给出终止状态的即时收获为止。</p><p>完整的Episode不要求起始状态一定是某一个特定的状态，但是要求个体最终进入环境认可的某一个终止状态。</p></blockquote><p>数学描述如下：</p><ul><li>基于特定策略 $\pi$  的一个Episode信息可以表示为如下的一个序列：</li></ul><script type="math/tex; mode=display">S _ { 1 } , A _ { 1 } , R _ { 2 } , S _ { 2 } , A _ { 2 } , \ldots , S _ { t } , A _ { t } , R _ { t + 1 } , \ldots , S _ { k } \sim \pi</script><ul><li>$t$时刻状态 $S_t$ 的收益：</li></ul><script type="math/tex; mode=display">G _ { t } = R _ { t + 1 } + \gamma R _ { t + 2 } + \ldots + \gamma ^ { T - 1 } R _ { T }</script><p>其中 $T$ 为终止时刻。</p><ul><li>该策略下某一状态 $s$ 的价值：</li></ul><script type="math/tex; mode=display">v _ { \pi } ( s ) = E _ { \pi } \left[ G _ { t } | S _ { t } = s \right]</script><h4 id="重复状态的收获计算"><a href="#重复状态的收获计算" class="headerlink" title="重复状态的收获计算"></a>重复状态的收获计算</h4><p>在状态转移过程中，可能发生一个状态经过一定的转移后又一次或多次返回该状态，此时在一个Episode里如何计算这个状态发生的次数和计算该Episode的收获呢？可以有如下两种方法：</p><h5 id="首次访问蒙特卡洛策略评估-First-Visit-Monte-Carlo-Policy-Evaluation"><a href="#首次访问蒙特卡洛策略评估-First-Visit-Monte-Carlo-Policy-Evaluation" class="headerlink" title="首次访问蒙特卡洛策略评估(First-Visit Monte-Carlo Policy Evaluation)"></a>首次访问蒙特卡洛策略评估(First-Visit Monte-Carlo Policy Evaluation)</h5><p>在给定一个策略，使用一系列完整Episode评估某一个状态$s$时，对于每一个Episode，仅当该状态<strong>第一次</strong>出现时列入计算</p><p>状态出现的次数加1： </p><script type="math/tex; mode=display">N ( s ) \leftarrow N ( s ) + 1</script><p>总的收获值更新：</p><script type="math/tex; mode=display">S ( s ) \leftarrow S ( s ) + G_t</script><p>状态s的价值：</p><script type="math/tex; mode=display">V(s) = \frac {S(s)}{N(s)}</script><p>当$N ( s ) \rightarrow \infty $ 时，$V(s) \leftarrow v_{\pi}(s)$ </p><p><img alt="First_visit_mc" data-src="//orangesching.github.io/2019/12/02/算法/机器学习/强化学习/强化学习基础4——基于无模型的强化学习方法/First_visit_mc.jpg" class="lazyload"></p><h5 id="每次访问蒙特卡洛策略评估"><a href="#每次访问蒙特卡洛策略评估" class="headerlink" title="每次访问蒙特卡洛策略评估"></a>每次访问蒙特卡洛策略评估</h5><p>在给定一个策略，使用一系列完整Episode评估某一个状态$s$时，对于每一个Episode，状态s<strong>每次</strong>出现在状态转移链时，计算的具体公式与上面的一样，但具体意义不一样。</p><p>状态出现的次数加1： </p><script type="math/tex; mode=display">N ( s ) \leftarrow N ( s ) + 1</script><p>总的收获值更新：</p><script type="math/tex; mode=display">S ( s ) \leftarrow S ( s ) + G_t</script><p>状态s的价值：</p><script type="math/tex; mode=display">V(s) = \frac {S(s)}{N(s)}</script><p>当$N ( s ) \rightarrow \infty $ 时，$V(s) \leftarrow v_{\pi}(s)$ </p><h4 id="示例：二十一点游戏-Blackjack-Example"><a href="#示例：二十一点游戏-Blackjack-Example" class="headerlink" title="　示例：二十一点游戏 Blackjack Example"></a>　示例：二十一点游戏 Blackjack Example</h4><p>该示例解释了Model-Free下的策略评估问题和结果，没有说具体的学习过程。</p><p>游戏规则：你会得到一副手牌，一开始是两张，你需要得到尽量靠近21点但不能超过21点的手牌点数和。越接近21点越有可能打赢庄家，打赢庄家就算赢。庄家会亮一张牌给玩家看</p><p><strong>状态空间</strong>：（多达200种，根据对状态的定义可以有不同的状态空间，这里采用的定义是牌的分数，不包括牌型）</p><ul><li>当前牌的分数（12 - 21），低于12时，你可以安全的再叫牌，所以没意义。</li><li>庄家出示的牌（A - 10），庄家会显示一张牌面给玩家</li><li>我有“useable” ace吗？（是或否）A既可以当1点也可以当11点。</li></ul><p><strong>行为空间</strong>：</p><ul><li>停止要牌 stick</li><li>继续要牌 twist</li></ul><p><strong>奖励（停止要牌）</strong>：</p><ul><li>+1：如果你的牌分数大于庄家分数</li><li>0： 如果两者分数相同</li><li>-1：如果你的牌分数小于庄家分数</li></ul><p><strong>奖励（继续要牌）</strong>：</p><ul><li>-1：如果牌的分数&gt;21，并且进入终止状态</li><li>0：其它情况</li></ul><p><strong>状态转换（Transitions）</strong>：如果牌分小于12时，自动要牌</p><p><strong>当前策略</strong>：牌分只要小于20就继续要牌。</p><p><strong>问题：</strong>评估该策略的好坏。</p><p><strong>评估过程：</strong>使用庄家显示的牌面值、玩家当前牌面总分值来确定一个二维状态空间，区分手中有无A分别处理。统计每一牌局下决定状态的庄家和玩家牌面的状态数据，同时计算其最终收获。通过模拟多次牌局，计算每一个状态下的平均值，得到如下图示。</p><p><strong>最终结果：</strong>无论玩家手中是否有A牌，该策略在绝大多数情况下各状态价值都较低，只有在玩家拿到21分时状态价值有一个明显的提升。</p><p><img alt="monte_carlo_example" data-src="//orangesching.github.io/2019/12/02/算法/机器学习/强化学习/强化学习基础4——基于无模型的强化学习方法/monte_carlo_example.png" class="lazyload"></p><h3 id="蒙特卡洛累进更新"><a href="#蒙特卡洛累进更新" class="headerlink" title="蒙特卡洛累进更新"></a>蒙特卡洛累进更新</h3><p>在使用蒙特卡洛方法求解平均收获时，需要计算平均值。通常计算平均值要预先存储所有的数据，最后使用总和除以此次数。这里介绍了一种更简单实用的方法：</p><p><strong>累进更新平均值 Incremental Mean</strong></p><p>这里提到了在实际操作时常用的一个实时更新均值的办法，使得在计算平均收获时不需要存储所有既往收获，而是每得到一次收获，就计算其平均收获。</p><p>理论公式如下：</p><script type="math/tex; mode=display">\begin{aligned} \mu _ { k } & = \frac { 1 } { k } \sum _ { j = 1 } ^ { k } x _ { j } \\ & = \frac { 1 } { k } \left( x _ { k } + \sum _ { j = 1 } ^ { k - 1 } x _ { j } \right) \\ & = \frac { 1 } { k } \left( x _ { k } + ( k - 1 ) \mu _ { k - 1 } \right) \\ & = \mu _ { k - 1 } + \frac { 1 } { k } \left( x _ { k } - \mu _ { k - 1 } \right) \end{aligned}</script><p>把这个方法应用于蒙特卡洛策略评估，就得到蒙特卡洛累进更新。</p><p><strong>蒙特卡洛累进更新</strong></p><p>对于一系列Episodes中的每一个：</p><script type="math/tex; mode=display">S _ { 1 } , A _ { 1 } , R _ { 2 } , S _ { 2 } , A _ { 2 } , \ldots , S _ { t } , A _ { t } , R _ { t + 1 } , \ldots , S _ { k }</script><p>对于Episode里的每一个状态 $S_t$ ，有一个收获 $G_t$ ，每碰到一次 $S_t$ ，使用下式计算状态的平均价值 $V(S_t)$ ：</p><script type="math/tex; mode=display">V \left( S _ { t } \right) \leftarrow V \left( S _ { t } \right) + \frac { 1 } { N \left( S _ { t } \right) } \left( G _ { t } - V \left( S _ { t } \right) \right)</script><p>其中：</p><script type="math/tex; mode=display">N ( S_t ) \leftarrow N ( S_t ) + 1</script><p>在处理非静态问题时，使用这个方法跟踪一个实时更新的平均值是非常有用的，可以扔掉那些已经计算过的Episode信息。此时可以引入参数 $\alpha$  来更新状态价值：</p><script type="math/tex; mode=display">V \left( S _ { t } \right) \leftarrow V \left( S _ { t } \right) + \alpha \left( G _ { t } - V \left( S _ { t } \right) \right)</script><p>以上就是蒙特卡洛学习方法的主要思想和描述，由于蒙特卡洛学习方法有许多缺点，因此实际应用并不多。接下来介绍实际常用的TD学习方法。</p><h2 id="时序差分学习-Temporal-Difference-Learning（TD-0-）"><a href="#时序差分学习-Temporal-Difference-Learning（TD-0-）" class="headerlink" title="时序差分学习 Temporal-Difference Learning（TD(0)）"></a>时序差分学习 Temporal-Difference Learning（TD(0)）</h2><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>时序差分算法简称TD学习，是一种无模型的强化学习算法。它继承了动态规划和蒙特卡罗方法的优点，从而对状态值和策略进行预测。从本质上来说，时序差分算法和动态规划一样，是一种<strong>bootstrapping的算法</strong>。同时，也和蒙特卡罗方法一样，从Episode学习，但是它可以学习<strong>不完整</strong>的Episode，是一种<strong>无模型的强化学习算法</strong>，其原理也是基于了试验。</p><p>在Monte-Carlo学习中，使用实际的收获（return）$G_t$  来更新价值（Value）：</p><script type="math/tex; mode=display">V \left( S _ { t } \right) \leftarrow V \left( S _ { t } \right) + \alpha \left( G _ { t } - V \left( S _ { t } \right) \right)</script><p>其中$G <em> { t } - V \left( S </em> { t } \right)$是实际收获与预估收货的<strong>误差</strong></p><p>在TD学习中，算法在估计某一个状态的价值时，用的是离开该状态的即刻奖励 $R<em>{t+1}$  与下一状态 $S</em>{t+1}$  的预估状态价值乘以衰减系数($\gamma$)组成，这符合Bellman方程的描述：</p><script type="math/tex; mode=display">V \left( S _ { t } \right) \leftarrow V \left( S _ { t } \right) + \alpha \left( R _ { t + 1 } + \gamma V \left( S _ { t + 1 } \right) - V \left( S _ { t } \right) \right)</script><p>$R <em> { t + 1 } + \gamma V \left( S </em> { t + 1 } \right)$ 称为<strong>TD目标值</strong>，是对实际收获的估计，即代替了MC中的$G<em>t$<br>$\delta </em> { t } = R <em> { t + 1 } + \gamma V \left( S </em> { t + 1 } \right) - V \left( S _ { t } \right)$称为TD<strong>误差</strong></p><blockquote><p>回顾：Bellman期望方程（见强化学习基础——强化学习问题描述）</p><script type="math/tex; mode=display">v _ { \pi } ( s ) = \mathbb { E } _ { \pi } \left[ R _ { t + 1 } + \gamma v _ { \pi } \left( S _ { t + 1 } \right) | S _ { t } = s \right]</script></blockquote><p><strong>BootStrapping</strong> 指的就是TD目标值 $R <em> { t + 1 } + \gamma V \left( S </em> { t + 1 } \right)$  代替收获 $G_t$  的过程</p><h3 id="MC与TD的区别"><a href="#MC与TD的区别" class="headerlink" title="MC与TD的区别"></a>MC与TD的区别</h3><h4 id="区别一：是否需要完整Episode"><a href="#区别一：是否需要完整Episode" class="headerlink" title="区别一：是否需要完整Episode"></a>区别一：是否需要完整Episode</h4><ul><li><p>TD 在知道结果之前可以学习，MC必须等到最后结果才能学习；</p></li><li><p>TD 可以在没有结果时学习，可以在持续进行的环境里学习。</p></li></ul><p><strong>示例——驾车返家</strong></p><p>想象一下你下班后开车回家，需要预估整个行程花费的时间。TD算法相当于在整个返家的过程中（一个Episode），根据已经消耗的时间和预期还需要的时间来不断更新最终回家需要消耗的时间。</p><p><img alt="td_example1" data-src="//orangesching.github.io/2019/12/02/算法/机器学习/强化学习/强化学习基础4——基于无模型的强化学习方法/td_example1.png" class="lazyload"></p><p>基于上表所示的数据，下图展示了蒙特卡洛学习和TD学习两种不同的学习策略来<strong>更新</strong>价值函数（各个状态的价值）。这里使用的是<strong>从某个状态预估的到家还需耗时</strong>来<strong>间接</strong>反映某状态的价值：某位置预估的到家时间越长，该位置价值越低，在优化决策时需要避免进入该状态。</p><p><img alt="td_example2" data-src="//orangesching.github.io/2019/12/02/算法/机器学习/强化学习/强化学习基础4——基于无模型的强化学习方法/td_example2.png" class="lazyload"></p><p>对于蒙特卡洛学习过程，驾驶员在路面上碰到各种情况时，他不会更新对于回家的预估时间，等他回到家得到了真实回家耗时后，他会重新估计在返家的路上着每一个主要节点状态到家的时间，在下一次返家的时候用新估计的时间来帮助决策；</p><p>对于TD学习，在一开始离开办公室的时候你可能会预估总耗时30分钟，但是当你取到车发现下雨的时候，你会立刻想到原来的预计过于乐观，因为既往的经验告诉你下雨会延长你的返家总时间，此时你会更新目前的状态价值估计，从原来的30分钟提高到40分钟。同样当你驾车离开高速公路时，会一路根据当前的状态（位置、路况等）对应的预估返家剩余时间，直到返回家门得到实际的返家总耗时。这一过程中，你会根据状态的变化实时更新该状态的价值。</p><h4 id="区别二：偏差方差"><a href="#区别二：偏差方差" class="headerlink" title="区别二：偏差方差"></a>区别二：偏差方差</h4><p>MC $G_t$ ：实际收获，是基于某一策略状态价值的<strong>无偏</strong>估计</p><script type="math/tex; mode=display">G _ { t } = R _ { t + 1 } + \gamma R _ { t + 2 } + \ldots + \gamma ^ { T - 1 } R _ { T }</script><p>TD target：TD目标值，是基于下一状态<strong>预估</strong>价值计算的当前预估收获，是当前状态实际价值的<strong>有偏</strong>估计</p><script type="math/tex; mode=display">R _ { t + 1 } + \gamma V \left( S _ { t + 1 } \right)</script><p>True TD target： 真实TD目标值，是基于下一状态的<strong>实际</strong>价值对当前状态实际价值的无偏估计</p><script type="math/tex; mode=display">R _ { t + 1 } + \gamma v _ { \pi } \left( S _ { t + 1 } \right)</script><ul><li>MC 没有偏差（bias），但有着较高的方差（Variance），且对初始值不敏感；</li><li>TD 低方差, 但有一定程度的偏差，对初始值较敏感，通常比 MC 更高效；</li><li>因为MC有T步的环境噪音，而TD只有一步，所以MC的方差高</li></ul><blockquote><p><strong>偏差</strong>指的是距离期望的距离，预估的平均值与实际平均值的偏离程度；</p><p><strong>方差</strong>是指评估单次采样结果相对于与平均值变动的范围大小</p><p>基本就是统计学上均值与方差的概念。</p></blockquote><p><strong>示例——随机行走</strong></p><p><img alt="td_example3" data-src="//orangesching.github.io/2019/12/02/算法/机器学习/强化学习/强化学习基础4——基于无模型的强化学习方法/td_example3.png" class="lazyload"></p><p><strong>状态空间</strong>：如下图：A、B、C、D、E为中间状态，C同时作为起始状态。灰色方格表示终止状态；</p><p><strong>行为空间</strong>：除终止状态外，任一状态可以选择向左、向右两个行为之一；</p><p><strong>即时奖励：</strong>右侧的终止状态得到即时奖励为1，左侧终止状态得到的即时奖励为0，在其他状态间转化得到的即时奖励是0；</p><p><strong>状态转移</strong>：100%按行为进行状态转移，进入终止状态即终止；</p><p><strong>衰减系数：</strong>1；</p><p><strong>给定的策略</strong>：随机选择向左、向右两个行为。</p><p><strong>问题：</strong>评估随机行走这个策略的价值，也就是计算该策略下每个状态的价值，也就是确定该MDP问题的状态价值函数。</p><p><strong>求解：</strong>下图是使用TD算法得到的结果。横坐标显示的是状态，纵坐标是各状态的价值估计，一共5条折线，数字表明的是实际经历的Episode数量，true value所指的那根折线反映的是各状态的实际价值。第0次时，各状态的价值被初始化为0.5，经过1次、10次、100次后得到的价值函数越来越接近实际状态价值函数。</p><p><img alt="td_example4" data-src="//orangesching.github.io/2019/12/02/算法/机器学习/强化学习/强化学习基础4——基于无模型的强化学习方法/td_example4.png" class="lazyload"></p><p>下图比较了MC和TD算法的效率。横坐标是经历的Episode数量，纵坐标是计算得到的状态函数和实际状态函数下各状态价值的均方差。黑色是MC算法在不同step-size下的学习曲线，灰色的曲线使用TD算法。可以看出TD较MC更高效。此图还可以看出当step-size不是非常小的情况下，TD有可能得不到最终的实际价值，将会在某一区间震荡。</p><p><img alt="td_example5" data-src="//orangesching.github.io/2019/12/02/算法/机器学习/强化学习/强化学习基础4——基于无模型的强化学习方法/td_example5.png" class="lazyload"></p><h4 id="区别三：当Episode有限时"><a href="#区别三：当Episode有限时" class="headerlink" title="区别三：当Episode有限时"></a>区别三：当Episode有限时</h4><p>当Episode有限时（比如只有三个），两种算法的区别：</p><ul><li><p>MC算法试图收敛至一个能够最小化状态价值与实际收获的均方差的解决方案，这一均方差用公式表示为：</p><script type="math/tex; mode=display"> \sum _ { k = 1 } ^ { K } \sum _ { t = 1 } ^ { T _ { k } } \left( G _ { t } ^ { k } - V \left( s _ { t } ^ { k } \right) \right) ^ { 2 }</script><p> 式中， $k$ 表示的是Episode序号， $K$ 为总的Episode数量， $t$ 为一个Episode内状态序号（第1,2,3…个状态等），$T_k$ 表示的是第 $k$ 个Episode总的状态数， $G_t^k$ 表示第 $k$ 个Episode里时 $t$ 刻状态  $S_t$ 获得的最终收获，$V(S_t^k)$ 表示的是第 $k$ 个Episode里算法估计的 $t$ 时刻状态  $S_t$ 的价值。</p></li><li><p>TD算法则收敛至一个根据已有经验构建的最大可能的马尔科夫模型的状态价值，也就是说TD算法将首先根据已有经验估计状态间的转移概率：</p><script type="math/tex; mode=display"> \hat { P } _ { s , s ^ { \prime } } ^ { a } = \frac { 1 } { N ( s , a ) } \sum _ { k = 1 } ^ { K } \sum _ { t = 1 } ^ { T _ { k } } \mathbf { 1 } \left( s _ { t } ^ { k } , a _ { t } ^ { k } , s _ { t + 1 } ^ { k } = s , a , s ^ { \prime } \right)</script><p> 同时估计某一个状态的即时奖励：</p><script type="math/tex; mode=display"> \hat { \mathcal { R } } _ { s } ^ { a } = \frac { 1 } { N ( s , a ) } \sum _ { k = 1 } ^ { K } \sum _ { t = 1 } ^ { T _ { k } } \mathbf { 1 } \left( s _ { t } ^ { k } , a _ { t } ^ { k } = s , a \right) r _ { t } ^ { k }</script><p> 最后计算该MDP的状态函数。</p></li></ul><p><strong>示例——AB</strong></p><p><strong>已知：</strong>现有两个状态(A和B)，MDP未知，衰减系数为1，有如下表所示8个完整Episode的经验及对应的即时奖励，其中除了第1个Episode有状态转移外，其余7个均只有一个状态。</p><p><img alt="td_example6" data-src="//orangesching.github.io/2019/12/02/算法/机器学习/强化学习/强化学习基础4——基于无模型的强化学习方法/td_example6.png" class="lazyload"></p><p><strong>问题：依据仅有的Episode，计算状态A，B的价值分别是多少，即</strong>V(A)=？， V(B)=？</p><p><strong>答案：</strong>V(B) = 6/8，V(A)根据不同算法结果不同，用MC算法结果为0，TD则得出6/8。</p><p><strong>解释：</strong></p><p>应用MC算法：由于需要完整的Episode,因此仅Episode1可以用来计算A的状态价值，很明显是0；同时B的价值是6/8。</p><p>应用TD算法：TD算法试图利用现有的Episode经验构建一个MDP（如下图），由于存在一个Episode使得状态A有后继状态B，因此状态A的价值是通过状态B的价值来计算的，同时经验表明A到B的转移概率是100%，且A状态的即时奖励是0，并且没有衰减，因此A的状态价值等于B的状态价值。</p><p><img alt="td_example7" data-src="//orangesching.github.io/2019/12/02/算法/机器学习/强化学习/强化学习基础4——基于无模型的强化学习方法/td_example7.png" class="lazyload"></p><h4 id="区别四：Markov环境的表现"><a href="#区别四：Markov环境的表现" class="headerlink" title="区别四：Markov环境的表现"></a>区别四：Markov环境的表现</h4><ul><li>TD算法使用了MDP问题的马尔科夫性，在Markov 环境下更有效</li><li>但是MC算法并不利用马尔科夫性，通常在非Markov环境下更有效。</li></ul><h3 id="小结——MC-TD-DP"><a href="#小结——MC-TD-DP" class="headerlink" title="小结——MC, TD ,DP"></a>小结——MC, TD ,DP</h3><div class="table-container"><table><thead><tr><th></th><th>动态规划</th><th>蒙特卡洛</th><th>时序差分</th></tr></thead><tbody><tr><td>是否需要知道Model</td><td>是</td><td>否</td><td>否</td></tr><tr><td>是否是Bootstrap算法</td><td>是</td><td>否</td><td>是</td></tr><tr><td>是否用样本来计算</td><td>否（利用模型直接得到V）</td><td>是</td><td>是</td></tr><tr><td>是否需要完整的Episode</td><td>不基于采样</td><td>是</td><td>否</td></tr><tr><td>适用环境</td><td></td><td>非Markov环境<br>不适用Episode少的<br>不适用持续环境（无终结状态）</td><td>Markov环境<br></td></tr><tr><td>backup图</td><td><img title="时序差分算法backup图" data-src="/2019/12/02/算法/机器学习/强化学习/强化学习基础4——基于无模型的强化学习方法/td2.png" class="lazyload"><br>用实际收获更新状态预估价值</td><td><img title="蒙特卡洛方法backup图" data-src="/2019/12/02/算法/机器学习/强化学习/强化学习基础4——基于无模型的强化学习方法/td1.png" class="lazyload"><br>用喜爱状态的预估状态价值预估收获再更新预估价值</td><td><img title="动态规划算法backup图" data-src="/2019/12/02/算法/机器学习/强化学习/强化学习基础4——基于无模型的强化学习方法/td3.png" class="lazyload"><br>根据完整模型，依靠预估数据更新状态价值</td></tr></tbody></table></div><p><img alt="td4" data-src="//orangesching.github.io/2019/12/02/算法/机器学习/强化学习/强化学习基础4——基于无模型的强化学习方法/td4.png" class="lazyload"></p><p>上图从两个维度解释了四种算法的差别，多了一个穷举法。这两个维度分别是：采样深度和广度。当使用单个采样，同时不走完整个Episode就是TD；当使用单个采样但走完整个Episode就是MC；当考虑全部样本可能性，但对每一个样本并不走完整个Episode时，就是DP；当既考虑所有Episode又把Episode从开始到终止遍历完，就变成了穷举法。</p><p>需要提及的是：DP利用的是整个MDP问题的模型，也就是状态转移概率，虽然它并不实际利用样本，但是它利用了整个模型的规律，因此认为是Full Width的。</p><h2 id="时序差分学习-Temporal-Difference-Learning-（TD-λ-）"><a href="#时序差分学习-Temporal-Difference-Learning-（TD-λ-）" class="headerlink" title="时序差分学习 Temporal-Difference Learning （TD(λ)）"></a>时序差分学习 Temporal-Difference Learning （TD(λ)）</h2><p>先前介绍了TD(0)算法，括号内的数字0表示的是在当前状态下往前多看1步，要是往前多看2步更新状态价值会怎样？这就引入了n-step的概念。</p><h3 id="n步预测-n-Step-Prediction"><a href="#n步预测-n-Step-Prediction" class="headerlink" title="n步预测 n-Step Prediction"></a>n步预测 n-Step Prediction</h3><p>所谓的n-step TD，其实就是说要往前多少步再来估计V值。如果往前n步直到终点，那么就等价于蒙特卡罗方法了。</p><p><img alt="tdn1" data-src="//orangesching.github.io/2019/12/02/算法/机器学习/强化学习/强化学习基础4——基于无模型的强化学习方法/tdn1.png" class="lazyload"></p><p>注：图中空心大圆圈表示状态，实心小圆圈表示行为</p><h3 id="n-步收获"><a href="#n-步收获" class="headerlink" title="n-步收获"></a>n-步收获</h3><p>TD(0)是基于1-步预测的，MC则是基于$\infty$步预测的：</p><p><img alt="tdn2" data-src="//orangesching.github.io/2019/12/02/算法/机器学习/强化学习/强化学习基础4——基于无模型的强化学习方法/tdn2.png" class="lazyload"></p><p>注意：n=2时不写成TD(2)。</p><p><strong>n-步收获</strong>定义为：</p><script type="math/tex; mode=display">G _ { t } ^ { ( n ) } = R _ { t + 1 } + \gamma R _ { t + 2 } + \ldots + \gamma ^ { n - 1 } R _ { t + n } + \gamma ^ { n } V \left( S _ { t + n } \right)</script><p>同样TD target 也由2部分组成，已走的步数使用确定的即时reward，剩下的使用估计的状态价值替代，n步TD学习状态价值函数的更新公式为：</p><script type="math/tex; mode=display">V \left( S _ { t } \right) \leftarrow V \left( S _ { t } \right) + \alpha \left( G _ { t } ^ { ( n ) } - V \left( S _ { t } \right) \right)</script><h3 id="λ收获"><a href="#λ收获" class="headerlink" title="λ收获"></a>λ收获</h3><p>既然存在n-步预测，那么n=？时效果最好呢，下面的例子试图回答这个问题：</p><h4 id="实验——n步预测的n取什么效果最好"><a href="#实验——n步预测的n取什么效果最好" class="headerlink" title="实验——n步预测的n取什么效果最好"></a>实验——n步预测的n取什么效果最好</h4><p>这个示例研究了使用多个不同步数预测联合不同步长(step-size，公式里的系数α）时，分别在在线和离线状态时状态函数均方差的差别。所有研究使用了10个Episode。离线与在线的区别在于，离线是在经历所有10个Episode后进行状态价值更新；而在线则至多经历一个Episode就更新依次状态价值。</p><p><img alt="tdn3" data-src="//orangesching.github.io/2019/12/02/算法/机器学习/强化学习/强化学习基础4——基于无模型的强化学习方法/tdn2.png" class="lazyload"></p><p>结果如图表明，离线和在线之间曲线的形态差别不明显；从步数上来看，步数越长，越接近MC算法，均方差越大。对于这个大规模随机行走示例，在线计算比较好的步数是3-5步，离线计算比较好的是6-8步。但是不同的问题其对应的比较高效的步数不是一成不变的。因此选择多少步数作为一个较优的计算参数也是一个问题。</p><h4 id="λ收获定义"><a href="#λ收获定义" class="headerlink" title="λ收获定义"></a>λ收获定义</h4><p>这里我们引入了一个新的参数：λ。通过引入这个新的参数，可以做到在不增加计算复杂度的情况下综合考虑所有步数的预测。这就是<strong>λ预测</strong>和<strong>λ收获。</strong></p><p>λ-收获 $G_t^{\lambda}$ 综合考虑了从 $1$ 到 $\infty$ 的所有步收获，它给其中的任意一个$n-1$ 步收获施加一定的权重$(1-\lambda)\lambda^{n-1}$ 。通过这样的权重设计，得到如下的公式：</p><script type="math/tex; mode=display">G _ { \mathrm { t } } ^ { \lambda } = ( 1 - \lambda ) \sum _ { n = 1 } ^ { \infty } \lambda ^ { n - 1 } G _ { t } ^ { ( n ) }</script><p>对应的λ-预测写成TD(λ):</p><script type="math/tex; mode=display">v \left( S _ { t } \right) \leftarrow v \left( S _ { t } \right) + \alpha \left( G _ { t } ^ { \lambda } - V \left( S _ { t } \right) \right)</script><p>下图是各步收获的权重分配图，图中最后一列λ的指数是$T-t-1$  。$T$ 为终止状态的时刻步数，$t$  为当前状态的时刻步数，所有的权重加起来为1。</p><p><img alt="tdn3" data-src="//orangesching.github.io/2019/12/02/算法/机器学习/强化学习/强化学习基础4——基于无模型的强化学习方法/tdn3.png" class="lazyload"></p><ul><li><strong>TD(λ)对于权重分配的图解</strong></li></ul><p><img alt="tdn4" data-src="//orangesching.github.io/2019/12/02/算法/机器学习/强化学习/强化学习基础4——基于无模型的强化学习方法/tdn4.png" class="lazyload"></p><p>这张图还是比较好理解，例如对于n=3的3-步收获，赋予其在 λ 收获中的权重如左侧阴影部分面积，对于终止状态的T-步收获，T以后的<strong>所有</strong>阴影部分面积。而所有节段面积之和为1。这种几何级数的设计也考虑了算法实现的计算方便性。</p><p>经过这个$(1-\lambda)\lambda^{n-1}$的作用，各个步数的权重就像上图这样衰减。相当于离状态s越远的，权重就越小。这也符合我们一般的想法，离得远的作用就小</p><h3 id="两个方向理解TD-λ"><a href="#两个方向理解TD-λ" class="headerlink" title="两个方向理解TD(λ)"></a>两个方向理解TD(λ)</h3><p>TD((λ)的设计使得Episode中，后一个状态的状态价值与之前所有状态的状态价值有关，同时也可以说成是一个状态价值参与决定了后续所有状态的状态价值。但是每个状态的价值对于后续状态价值的影响权重是不同的。我们可以从两个方向来理解TD(λ)：</p><h4 id="前向认识TD-λ"><a href="#前向认识TD-λ" class="headerlink" title="前向认识TD(λ)"></a>前向认识TD(λ)</h4><p>引入了λ之后，会发现要更新一个状态的状态价值，必须要走完整个Episode获得每一个状态的即时奖励以及最终状态获得的即时奖励。这和MC算法的要求一样，因此TD(λ)算法有着和MC方法一样的劣势。λ取值区间为[0,1]，当λ=1时对应的就是MC算法。这给实际计算带来了不便。</p><p><img alt="tdn_forward" data-src="//orangesching.github.io/2019/12/02/算法/机器学习/强化学习/强化学习基础4——基于无模型的强化学习方法/tdn_forward.png" class="lazyload"></p><p>前向视角的解释：假设一个人坐在状态流上拿着望远镜看向前方，前方是那些将来的状态。当估计当前状态的值函数时，从$TD(λ)$的定义中可以看到，它需要用到将来时刻的值函数。</p><script type="math/tex; mode=display">\begin{array} { c } { V \left( S _ { t } \right) \leftarrow V \left( S _ { t } \right) + \alpha \left( G _ { t } ^ { \lambda } - V \left( S _ { t } \right) \right) } \\ { G _ { t } ^ { \lambda } = ( 1 - \lambda ) \sum _ { n = 1 } ^ { \infty } \lambda ^ { n - 1 } G _ { t } ^ { ( n ) } } \\ G _ { t } ^ { ( n ) } = R _ { t + 1 } + \gamma R _ { t + 2 } + \ldots + \gamma ^ { n - 1 } R _ { t + n } + \gamma ^ { n } V \left( S _ { t + n } \right)\end{array}</script><h4 id="反向认识TD-λ-（重要）"><a href="#反向认识TD-λ-（重要）" class="headerlink" title="反向认识TD(λ)（重要）"></a>反向认识TD(λ)（重要）</h4><p>TD(λ)从另一方面提供了一个单步更新的机制，通过下面的示例来说明。</p><p><strong>示例——被电击的原因</strong></p><p>老鼠在连续接受了3次响铃和1次亮灯信号后遭到了电击，那么在分析遭电击的原因时，到底是响铃的因素较重要还是亮灯的因素更重要呢？</p><p><img alt="tdn5" data-src="//orangesching.github.io/2019/12/02/算法/机器学习/强化学习/强化学习基础4——基于无模型的强化学习方法/tdn5.png" class="lazyload"></p><p>两个概念：</p><p><strong>频率启发 Frequency heuristic：</strong>将原因归因于出现频率最高的状态</p><p><strong>就近启发 Recency heuristic：</strong>将原因归因于较近的几次状态</p><p>给每一个状态引入一个数值：<strong>效用追踪</strong>（<strong>Eligibility Traces, ES</strong>），可以结合上述两个启发。定义：</p><script type="math/tex; mode=display">\begin{array} { c } { E _ { 0 } ( s ) = 0 } \\ { E _ { t } ( s ) = \gamma \lambda E _ { t - 1 } ( s ) + 1 \left( S _ { t } = s \right) } \end{array}</script><p>其中 $1 \left( S _ { t } = s \right)$ 是一个条件判断表达式。</p><p>下图给出了 $E_t(s)$  对于 $t$  的一个可能的曲线图：</p><p><img alt="tdn6" data-src="//orangesching.github.io/2019/12/02/算法/机器学习/强化学习/强化学习基础4——基于无模型的强化学习方法/tdn6.png" class="lazyload"></p><p>该图横坐标是时间，横坐标下有竖线的位置代表当前进入了状态 $s$  ，纵坐标是效用追踪值 $E$  。可以看出当某一状态连续出现，E值会在一定衰减的基础上有一个单位数值的提高，此时将增加该状态对于最终收获贡献的比重，因而在更新该状态价值的时候可以较多地考虑最终收获的影响。同时如果该状态距离最终状态较远，则其对最终收获的贡献越小，在更新该状态时也不需要太多的考虑最终收获。</p><p>特别的，$E$  值并不需要等到完整的Episode结束才能计算出来，它可以每经过一个时刻就得到更新。$E$  值存在饱和现象，有一个瞬时最高上限：$E_{max}=\frac {1}{1-\gamma\lambda}$ </p><p><img alt="tdn_backward" data-src="//orangesching.github.io/2019/12/02/算法/机器学习/强化学习/强化学习基础4——基于无模型的强化学习方法/tdn_backward.png" class="lazyload"></p><p>$TD(λ)$的后向视角解释：有个人坐在状态流上，手里拿着话筒，面朝着已经经历过的状态，获得当前回报并利用下一个状态的值函数得到TD偏差之后，此人会想已经经历过的状态喊话告诉这些已经经历过的状态处的值函数需要利用当前时刻的TD偏差进行更新。此时过往的每个状态值函数更新的大小应该跟距离当前状态的步数有关。假设当前状态为$s<em>t$，TD偏差为$\delta </em> { t }$，那么$s<em>{t−1}$处的值函数更新应该乘以一个衰减因子$\gamma\lambda$，状态$s</em>{t−2}$处的值函数更新应该乘以$(\gamma\lambda)^2$，以此类推。</p><p>后向TD(λ)的更新过程：</p><script type="math/tex; mode=display">\delta _ { t } = R _ { t + 1 } + \gamma V \left( S _ { t + 1 } \right) - V \left( S _ { t } \right)</script><p>计算当前状态的TD偏差，<strong>效用追踪</strong>（<strong>Eligibility Traces, ES</strong>）：</p><script type="math/tex; mode=display">E _ { t } ( s ) = \gamma \lambda E _ { t - 1 } ( s ) + 1 \left( S _ { t } = s \right)</script><p>引入效能主要是为了可以在线学习，可以方便的迭代</p><p>更新eligibility trace（对状态空间中的每一个已经经历过的状态s，更新价值函数）</p><script type="math/tex; mode=display">V ( s ) \leftarrow V ( s ) + \alpha \delta _ { t } E _ { t } ( s )</script><p>前向误差和反向误差一样，有证明的，不要看着好像不一样就觉得是两个公式</p><p>相较于MC算法，TD算法应用更广，是一个非常有用的强化学习方法，在下一讲讲解控制相关的算法时会详细介绍TD算法的实现。</p><h1 id="策略求解（无模型的控制）"><a href="#策略求解（无模型的控制）" class="headerlink" title="策略求解（无模型的控制）"></a>策略求解（无模型的控制）</h1><p>上一节主要讲解了在模型未知的情况下如何进行预测。所谓的预测就是评估一个给定的策略，也就是确定一给定策略下的状态（或状态行为对）的价值函数。这一讲的内容主要是<strong>在模型未知的条件下如何优化价值函数</strong>，这一过程也称作模型无关的控制。</p><p>现实中有很多此类的例子，比如控制一个大厦内的多个电梯使得效率最高；控制直升机的特技飞行，机器人足球世界杯上控制机器人球员，围棋游戏等等。所有的这些问题要么我们对其模型运行机制未知；要么是虽然问题模型是已知的，但问题的规模太大以至于计算机无法高效的计算，除非使用采样的办法。本节的内容就专注于解决这些问题。</p><p>根据优化控制过程中是否利用已有或他人的经验策略来改进我们自身的控制策略，我们可以将这种优化控制分为两类：</p><ul><li><p><strong>现时策略学习（On-policy Learning）</strong>，其基本思想是个体已有一个策略，并且遵循这个策略进行采样，或者说采取一系列该策略下产生的行为，根据这一系列行为得到的奖励，更新状态函数，最后根据该更新的价值函数来优化策略得到较优的策略。</p></li><li><p><strong>离线策略学习（Off-policy Learning）</strong>: 其基本思想是，虽然个体有一个自己的策略，但是个体并不针对这个策略进行采样，而是基于另一个策略进行采样，这另一个策略可以是先前学习到的策略，也可以是人类的策略等一些较为优化成熟的策略，通过观察基于这类策略的行为，或者说通过对这类策略进行采样，得到这类策略下的各种行为，继而得到一些奖励，然后更新价值函数，即在自己的策略形成的价值函数的基础上观察别的策略产生的行为，以此达到学习的目的。这种学习方式类似于“站在别人的肩膀上可以看得更远”。</p></li></ul><h2 id="通用策略迭代"><a href="#通用策略迭代" class="headerlink" title="通用策略迭代"></a>通用策略迭代</h2><p><img alt="2_1" data-src="//orangesching.github.io/2019/12/02/算法/机器学习/强化学习/强化学习基础4——基于无模型的强化学习方法/2_1.png" class="lazyload"></p><p><strong>通用策略迭代的核心</strong>是在两个交替的过程之间进行策略优化。一个过程是策略评估，另一个是改善策略。</p><p>如上图的三角形区域所示，从一个策略π和一个价值函数Ｖ开始，每一次箭头向上代表着利用当前策略进行价值函数的更新，每一次箭头向下代表着根据更新的价值函数贪婪地选择新的策略，说它是贪婪的，是因为每次都采取转移到可能的、状态函数最高的新状态的行为。最终将收敛至最优策略和最优价值函数。</p><h2 id="现时策略学习"><a href="#现时策略学习" class="headerlink" title="现时策略学习"></a>现时策略学习</h2><p>现时策略学习的特点就是当前遵循的策略就是个体学习改善的策略。</p><p>根据是否经历完整的Episode可以将其分为基于蒙特卡洛的和基于TD的。</p><h2 id="现时策略蒙特卡洛控制"><a href="#现时策略蒙特卡洛控制" class="headerlink" title="现时策略蒙特卡洛控制"></a>现时策略蒙特卡洛控制</h2><p>根据通用策略迭代的步骤是评估策略和改善策略交替进行，下面对两个步骤进行讨论</p><h3 id="评估策略"><a href="#评估策略" class="headerlink" title="评估策略"></a>评估策略</h3><p>动态规划算法来改善策略是需要知道某一状态的所有后续状态及状态间转移概率：</p><script type="math/tex; mode=display">\pi ^ { \prime } ( s ) = \underset { a \in \mathcal { A } } { \operatorname { argmax } } \mathcal { R } _ { s } ^ { a } + \mathcal { P } _ { s s ^ { \prime } } ^ { a } V \left( s ^ { \prime } \right)</script><p>但这种方法不适用于模型未知的蒙特卡洛学习，因为不知道执行完某个动作后的转移概率和所有后续的状态,就不知道哪个行动会使价值最大。</p><p>可以使用状态-行为对下的价值$Q(s,a)$来代替状态价值 ，这样就可以改善策略而不需要知道整个模型：</p><script type="math/tex; mode=display">\pi ^ { \prime } ( s ) = \underset { a \in \mathcal { A } } { \operatorname { argmax } } Q ( s , a )</script><blockquote><p>Q函数复习</p><script type="math/tex; mode=display">q _ { \pi } ( s , a ) = \mathbb { E } _ { \pi } \left[ G _ { t } | S _ { t } = s , A _ { t } = a \right]</script></blockquote><p>这样做的目的是可以改善策略而不用知道整个模型，只需要知道在某个状态下采取什么什么样的行为价值最大即可。具体是这样：我们从一个初始的 $Q$ 和策略 $\pi$ 开始，先根据这个策略更新每一个状态行为对的 $q$ 值，$s$ 随后基于更新的 $Q$确定改善的贪婪算法。</p><h3 id="改善策略"><a href="#改善策略" class="headerlink" title="改善策略"></a>改善策略</h3><p>即使这样，至少还存在一个问题，即当我们每次都使用贪婪算法来改善策略的时候，将很有可能由于没有足够的采样经验而导致产生一个并不是最优的策略，我们需要不时的尝试一些新的行为，这就是探索（Exploration）</p><p>完全使用贪婪算法改善策略可能会陷入局部最优，通常不能得到最优策略。为了解决这一问题，我们需要引入一个随机机制，以一定的概率选择当前最好的策略，同时给以其它可能的行为一定的几率，这就是Ɛ-贪婪探索。</p><h4 id="E-贪婪探索"><a href="#E-贪婪探索" class="headerlink" title="Ɛ-贪婪探索"></a>Ɛ-贪婪探索</h4><p>Ɛ-贪婪探索的目标使得某一状态下所有可能的行为都有一定非零几率被选中执行，也就保证了持续的探索，$1 - \epsilon$ 的概率下选择当前认为最好的行为，而 $\epsilon$ 的概率在所有可能的行为中选择（也包括那个当前最好的行为）。数学表达式如下：</p><script type="math/tex; mode=display">\pi ( a | s ) = \left\{ \begin{array} { l l } { \epsilon / m + 1 - \epsilon } & { \text { if } a ^ { * } = \underset { a \in \mathcal { A } } { \operatorname { argmax } } Q ( s , a ) } \\ { \epsilon / m } & { \text { otherwise } } \end{array} \right.</script><p><strong>定理：</strong>使用Ɛ-贪婪探索策略，对于任意一个给定的策略 $\pi$，我们在评估这个策略的同时也总在改善它（$V<em>{\pi’}(s) \geq V</em>{\pi}(s)$）</p><p>证明见David Silver视频</p><h3 id="蒙特卡洛控制-评估策略-改善策略"><a href="#蒙特卡洛控制-评估策略-改善策略" class="headerlink" title="蒙特卡洛控制=评估策略+改善策略"></a>蒙特卡洛控制=评估策略+改善策略</h3><p>解决了上述两个问题，我们最终看到蒙特卡洛控制的全貌：使用Ｑ函数进行策略评估，使用Ɛ-贪婪探索来改善策略。该方法最终可以收敛至最优策略。如下图所示：</p><p><img alt="2_2" data-src="//orangesching.github.io/2019/12/02/算法/机器学习/强化学习/强化学习基础4——基于无模型的强化学习方法/2_2.png" class="lazyload"></p><p>图中每一个向上或向下的箭头都对应着多个Episode。也就是说我们一般在经历了多个Episode之后才进行依次Ｑ函数更新或策略改善。实际上我们也可以在每经历一个Episode之后就更新Ｑ函数或改善策略。但不管使用哪种方式，在Ɛ-贪婪探索算法下我们始终只能得到基于某一策略下的近似Ｑ函数，且该算法没没有一个终止条件，因为它一直在进行探索。</p><p>因此我们必须关注以下两个方面：一方面我们不想丢掉任何更好信息和状态，另一方面随着我们策略的改善我们最终希望能终止于某一个最优策略，因为事实上最优策略不应该包括一些随机行为选择。为此引入了另一个理论概念：<strong>GLIE</strong>。</p><h3 id="基于GLIE的蒙特卡洛控制"><a href="#基于GLIE的蒙特卡洛控制" class="headerlink" title="基于GLIE的蒙特卡洛控制"></a>基于GLIE的蒙特卡洛控制</h3><h4 id="GLIE-Greedy-in-the-Limit-with-Infinite-Exploration"><a href="#GLIE-Greedy-in-the-Limit-with-Infinite-Exploration" class="headerlink" title="GLIE(Greedy in the Limit with Infinite Exploration)"></a>GLIE(Greedy in the Limit with Infinite Exploration)</h4><p><strong>GLIE</strong>(Greedy in the Limit with Infinite Exploration)，直白的说是<strong>在有限的时间内进行无限可能的探索</strong>。具体表现为：</p><ul><li><p>所有已经经历的状态行为对（state-action pair）会被无限次探索</p></li><li><p>策略会收敛于贪婪策略。即随着探索的无限延伸，贪婪算法中Ɛ值趋向于０。例如如果我们取 $\epsilon=\frac {1}{k}$ （$k$ 为探索的Episode数目），那么该Ɛ贪婪蒙特卡洛控制就具备GLIE特性。</p></li></ul><h4 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h4><ol><li><p>对于给定策略 $\pi$ ，采样第 $k$ 个Episode：$S <em> { 1 } , A </em> { 1 } , R <em> { 2 } , \ldots , S </em> { T } \sim \pi$ </p></li><li><p>对于该Episode里出现的每一个状态行为对 $S_t$ 和 $A_t$ 更新其计数和Ｑ函数：</p><script type="math/tex; mode=display">\begin{array} { l } { N \left( S _ { t } , A _ { t } \right) \leftarrow N \left( S _ { t } , A _ { t } \right) + 1 } \\ { Q \left( S _ { t } , A _ { t } \right) \leftarrow + \frac { 1 } { N \left( S _ { t } , A _ { t } \right) } \left( G _ { t } - Q \left( S _ { t } , A _ { t } \right) \right) } \end{array}</script></li><li><p>基于新的Ｑ函数改善以如下方式改善策略：</p><script type="math/tex; mode=display">\epsilon=\frac {1}{k} \\\pi \leftarrow greedy(Q)</script></li></ol><p><strong>定理：GLIE蒙特卡洛控制能收敛至最优的状态行为价值函数。</strong></p><h2 id="现时策略时序差分控制-On-Policy-Temporal-Difference-Control"><a href="#现时策略时序差分控制-On-Policy-Temporal-Difference-Control" class="headerlink" title="现时策略时序差分控制 On-Policy Temporal-Difference Control"></a>现时策略时序差分控制 On-Policy Temporal-Difference Control</h2><p>上一讲提到TD相比MC有很多优点：低方差，可以在线实时学习，可以学习不完整Episode等。因此很自然想到是否可以在控制问题上使用TD学习$Q(S,A)$而不是MC学习？这就是下文要讲解的SARSA</p><h3 id="SARSA"><a href="#SARSA" class="headerlink" title="SARSA"></a>SARSA</h3><p>SARSA的名称来源于下图所示的序列描述：针对一个状态$S$，以及一个特定的行为，$A$进而产生一个状态行为对($SA$)，与环境交互，环境收到个体的行为后会告诉个体即时奖励 $R$ 以及后续进入的状态 $S’$；接下来个体遵循<strong>现有策略</strong>产生一个行为 $A’$，根据当前的<strong>状态行为价值函数</strong>得到后一个状态行为对($S’A’$)的价值（$Q$），利用这个 $Q$ 值更新前一个状态行为对( $SA$ )的价值。</p><p><img alt="2_3" data-src="//orangesching.github.io/2019/12/02/算法/机器学习/强化学习/强化学习基础4——基于无模型的强化学习方法/2_3.png" class="lazyload"></p><p>与蒙特卡洛控制不同的时，每一个时间步，也就是在单个Episode内每一次个体在状态 $S_t$ 采取一个行为后都要更新 $Q$ 值，同样使用<strong>Ɛ-贪婪探索</strong>的形式来改善策略。</p><script type="math/tex; mode=display">Q ( S , A ) \leftarrow Q ( S , A ) + \alpha \left( R + \gamma Q \left( S ^ { \prime } , A ^ { \prime } \right) - Q ( S , A ) \right)</script><h4 id="现时策略控制的SARSA算法"><a href="#现时策略控制的SARSA算法" class="headerlink" title="现时策略控制的SARSA算法"></a>现时策略控制的SARSA算法</h4><p><img alt="2_4" data-src="//orangesching.github.io/2019/12/02/算法/机器学习/强化学习/强化学习基础4——基于无模型的强化学习方法/2_4.png" class="lazyload"></p><p>注：</p><ol><li>算法中的 $Q(s,a)$是以一张大表存储的，这不适用于解决规模很大的问题；</li><li>对于每一个Episode，在 $S$ 状态时采用的行为是 $A$ 基于当前策略的，同时该行为也是实际Episode发生的行为，在更新 $SA$ 行为状态价值循环里，个体并不实际执行在 $S’$ 下的 $A’$ 行为，而是将行为 $A’$ 留到下一个循环执行。</li></ol><h4 id="示例——有风格子世界"><a href="#示例——有风格子世界" class="headerlink" title="示例——有风格子世界"></a>示例——有风格子世界</h4><p><strong>已知：</strong>如图所示，环境是一个10*7的长方形格子世界，同时有一个起始位置S和一个终止目标位置G，水平下方的数字表示对应的列中有一定强度的风，当该数字是1时，个体进入该列的某个格子时，会按图中箭头所示的方向自动移动一格，当数字为2时，表示顺风移动2格，以此类推模拟风的作用。对于个体来说，它不清楚整个格子世界的构造，即它不知道格子是长方形的，也不知道边界在哪里。也不清楚起始位置、终止目标位置的具体为止。对于它来说，每一个格子就相当于一个封闭的房间，在没推开门离开当前房间之前它无法知道会进入哪个房间。个体具备记住曾经去过的格子的能力。格子可以执行的行为是朝上、下、左、右移动一步。</p><p><img alt="2_5" data-src="//orangesching.github.io/2019/12/02/算法/机器学习/强化学习/强化学习基础4——基于无模型的强化学习方法/2_5.png" class="lazyload"></p><p><strong>问题：</strong>个体如何才能找到最短从起始格子S到终止目标格子G的最短路线？</p><p><strong>解答：</strong>可以设置个体每行走一步获得即时奖励为-1，直到到达终止目标位置的即时奖励为0，借此希望找到最优策略。衰减系数λ可设为1。</p><p>其最优路线如下图所示：</p><p><img alt="2_6" data-src="//orangesching.github.io/2019/12/02/算法/机器学习/强化学习/强化学习基础4——基于无模型的强化学习方法/2_6.png" class="lazyload"></p><p>在个体找到这个最优行为序列的早期，由于个体对环境一无所知，SARSA算法需要尝试许多不同的行为，因此在一开始的2000多步里，个体只能完成少数几个完整的Episode，但随着个体找到一条链接起点到终点的路径，其快速优化策略的能力就显现的很明显了，因为它不需要走完一个Episode才能更新行为价值，而是每走一步就根据下一个状态能够得到的最好价值来更新当前状态的价值。</p><h3 id="SARSA-λ"><a href="#SARSA-λ" class="headerlink" title="SARSA(λ)"></a>SARSA(λ)</h3><h4 id="n-步SARSA"><a href="#n-步SARSA" class="headerlink" title="n-步SARSA"></a>n-步SARSA</h4><p>在之前，我们学习了n-步收获（见TD(λ)），这里类似的引出一个n-步Sarsa的概念。观察下面一些列的式子：</p><p><img alt="2_7" data-src="//orangesching.github.io/2019/12/02/算法/机器学习/强化学习/强化学习基础4——基于无模型的强化学习方法/2_7.png" class="lazyload"></p><p>定义<strong>n-步Q收获（Q-return）：</strong></p><script type="math/tex; mode=display">q _ { t } ^ { ( n ) } = R _ { t + 1 } + \gamma R _ { t + 2 } + \ldots + \gamma ^ { n - 1 } R _ { t + n } + \gamma ^ { n } Q \left( S _ { t + n } \right)</script><p>则可以把n-步Sarsa用n-步Q收获来表示，如下式：</p><script type="math/tex; mode=display">Q \left( S _ { t } , A _ { t } \right) \leftarrow Q \left( S _ { t } , A _ { t } \right) + \alpha \left( q _ { t } ^ { ( n ) } - Q \left( S _ { t } , A _ { t } \right) \right)</script><p>假如我们给n-步Q收获的每一个收获分配一个权重，如下引入参数λ分配权重，并按权重对每一步Q收获求和，那么将得到  $q^{\lambda}$ 收获，它结合了所有n-步Q收获：</p><script type="math/tex; mode=display">q _ { t } ^ { \lambda } = ( 1 - \lambda ) \sum _ { n = 1 } ^ { \infty } \lambda ^ { n - 1 } q _ { t } ^ { ( n ) }</script><h4 id="两个方向理解SARSA-λ"><a href="#两个方向理解SARSA-λ" class="headerlink" title="两个方向理解SARSA(λ)"></a>两个方向理解SARSA(λ)</h4><h5 id="Sarsa-λ-前向认识"><a href="#Sarsa-λ-前向认识" class="headerlink" title="Sarsa(λ)前向认识"></a>Sarsa(λ)前向认识</h5><p>如果用某一状态的 $q^{\lambda}$ 收获来更新状态行为对的Q值，那么可以表示称如下的形式：</p><script type="math/tex; mode=display">Q \left( S _ { t } , A _ { t } \right) \leftarrow Q \left( S _ { t } , A _ { t } \right) + \alpha \left( q _ { t } ^ { \lambda } - Q \left( S _ { t } , A _ { t } \right) \right)</script><p>这就是前向认识Sarsa(λ)，使用它更新Q价值需要遍历完整的Episode，我们同样可以反向理解Sarsa(λ).</p><h5 id="Sarsa-λ-反向认识"><a href="#Sarsa-λ-反向认识" class="headerlink" title="Sarsa(λ)反向认识"></a>Sarsa(λ)反向认识</h5><p>与上一节对于TD(λ)的反向认识一样，引入效用追踪（Eligibility Trace）概念，不同的是这次的E值针对的不是一个状态，而是一个状态行为对：</p><script type="math/tex; mode=display">\begin{array} { c } { E _ { 0 } ( s , a ) = 0 } \\ { E _ { t } ( s , a ) = \gamma \lambda E _ { t - 1 } ( s , a ) + 1 \left( S _ { t } = s , A _ { t } = a \right) } \end{array}</script><p>它体现的是一个结果与某一个状态行为对的因果关系，与得到结果最近的状态行为对，以及那些在此之前频繁发生的状态行为对对得到这个结果的影响最大。</p><p>下式是引入ET概念的SARSA(λ)之后的Q值更新描述：</p><script type="math/tex; mode=display">\begin{aligned} E _ { t } ( s , a ) &= \gamma \lambda E _ { t - 1 } ( s , a ) + 1 \left( S _ { t } = s , A _ { t } = a \right)\\\delta _ { t } = & R _ { t + 1 } + \gamma Q \left( S _ { t + 1 } , A _ { t + 1 } \right) - Q \left( S _ { t } , A _ { t } \right) \\ & Q ( s , a ) \leftarrow Q ( s , a ) + \alpha \delta _ { t } E _ { t } ( s , a ) \end{aligned}</script><p>引入ET概念，同时使用SARSA(λ)将可以更有效的在线学习，因为不必要学习完整的Episode，数据用完即可丢弃。ET通常也是更多应用在在线学习算法中(online algorithm)。</p><h4 id="具体的SARSA-λ-算法"><a href="#具体的SARSA-λ-算法" class="headerlink" title="具体的SARSA(λ)算法"></a>具体的SARSA(λ)算法</h4><p><img alt="2_8" data-src="//orangesching.github.io/2019/12/02/算法/机器学习/强化学习/强化学习基础4——基于无模型的强化学习方法/2_8.png" class="lazyload"></p><p>这里要提及一下的是$E(s,a)$在每浏览完一个Episode后需要重新置0，这体现了ET仅在一个Episode中发挥作用；其次要提及的是算法更新Q和E的时候针对的不是某个Episode里的Q或E，而是针对个体掌握的整个状态空间和行为空间产生的Q和E。</p><p>实际如果是基于查表的方式实现该算法，其速度明显比Sarsa要慢。毕竟带E的算法主要应用于在线更新。</p><h3 id="例——SARSA与SARSA-λ-的区别"><a href="#例——SARSA与SARSA-λ-的区别" class="headerlink" title="例——SARSA与SARSA(λ)的区别"></a>例——SARSA与SARSA(λ)的区别</h3><p>假定图描述的路线是个体采取两种算法中的一个得到的一个完整Episode的路径。为了下文更方便描述、解释两个算法之间的区别，先做几个合理的小约定：</p><ol><li><p>认定每一步的即时奖励为0，直到终点处即时奖励为1；</p></li><li><p>根据算法，除了终点以外的任何状态行为对的Q值可以是任意的，但我们设定所有的Q值均为0；</p></li><li><p>该路线是第一次找到终点的路线。</p><p><img alt="2_9" data-src="//orangesching.github.io/2019/12/02/算法/机器学习/强化学习/强化学习基础4——基于无模型的强化学习方法/2_9.png" class="lazyload"></p></li></ol><div class="table-container"><table><thead><tr><th></th><th>Sarsa(0)</th><th>Sarsa(λ)</th></tr></thead><tbody><tr><td>第一次</td><td>Q表中的值均为0<br>依据当前策略 $A$ 右移动一步，到达$S’$位置<br>依据当前策略产生一个行为$A’$，在Q表中查找$Q(S’,A’)$得到$Q’$<br><br>依据更新公式更新表$Q(S,A)$值（在每到终点前都是0）<br>个体到达终点，获得奖励1，（从$S<em>H$向上走$A</em>{up}$到达的终点）<br>更新Q表中的$Q(S<em>H,A</em>{up})$<br>完成一个Episode（只有一次有意义的行为价值函数更新）</td><td>E表中的值均为0<br>依据当前策略 $A$ 右移动一步，到达$S’$位置<br>E(S,A)加1（表明经历了这个事件）<br>计算TD误差，估计这个事件对整个问题的价值（结果是0，说明这个举动没有说明积极帮助）<br>更新Q表中的$Q(S,A)$值<br>个体到达终点，获得奖励1，，（从$S<em>H$向上走$A</em>{up}$到达的终点）<br>计算TD误差为1,<br>更新<strong>整个过程经历过</strong>的$Q(s,a)$，其中与$<s_h,a_{up}>$越近发生的状态（体现在E值），价值提升越明显（个体在这个Episode中经历的所有状态行为对的Q值都将得到一个非0的更新）</s_h,a_{up}></td></tr><tr><td>第二次</td><td>一开始与首次一样都是盲目随机的<br>直到其进入终点位置下方的位置 $S_H$，在这个位置，个体更新的策略要求其选择向上的行为直接进入终点位置$S_G$</td><td>起点处向右走的价值不再是0<br>过程同上</td></tr><tr><td>第n次</td><td>如果采用greedy策略更新，个体最终将得到一条到达终点的路径，不过这条路径的倒数第二步永远是在终点位置的下方。<br>如果采用Ɛ-greedy策略更新，那么个体还会尝试到终点位置的左上右等其它方向的相邻位置价值也比较大，此时个体每次完成的路径可能都不一样。</td><td>如果采用greedy策略更新，个体将根据上次经验得到的新策略直接选择右走，并且一直按照原路找到终点。<br>如果采用Ɛ-greedy策略更新，那么个体还会尝试新的路线。</td></tr></tbody></table></div><h2 id="离线策略学习-Off-Policy-Learning"><a href="#离线策略学习-Off-Policy-Learning" class="headerlink" title="离线策略学习 Off-Policy Learning"></a><strong>离线策略学习 Off-Policy Learning</strong></h2><p>离线策略学习（Off-Policy Learning）则指的是在遵循一个策略 $\mu(a|s)$ 的同时评估另一个策略 $\pi(a|s)$，也就是计算确定这另一个策略下的状态价值函数 $v<em>{\pi}(s)$ 或状态行为价值函数 $q</em>{\pi}(s,a)$。</p><p>这样可以较容易的从人类经验或其他个体的经验中学习，也可以从一些旧的策略中学习，可以比较两个策略的优劣。可以遵循一个探索式策略的基础上优化现有的策略。</p><p>根据是否经历完整的Episode可以将其分为基于蒙特卡洛的和基于TD的。</p><h2 id="离线策略蒙特卡洛控制"><a href="#离线策略蒙特卡洛控制" class="headerlink" title="离线策略蒙特卡洛控制"></a>离线策略蒙特卡洛控制</h2><p>基于蒙特卡洛的离线策略学习仅有理论上的研究价值，在实际中毫无用处。</p><h2 id="离线策略时序差分控制-Off-Policy-Temporal-Difference-Control"><a href="#离线策略时序差分控制-Off-Policy-Temporal-Difference-Control" class="headerlink" title="离线策略时序差分控制 Off-Policy Temporal-Difference Control"></a>离线策略时序差分控制 Off-Policy Temporal-Difference Control</h2><p>离线策略TD学习的任务就是使用TD方法在遵循一个策略 $\mu(a|s)$ 的同时评估另一个策略 $\pi(a|s)$ 。具体数学表示为：</p><script type="math/tex; mode=display">V \left( S _ { t } \right) \leftarrow V \left( S _ { t } \right) + \alpha \left( \frac { \pi \left( A _ { t } | S _ { t } \right) } { \mu \left( A _ { t } | S _ { t } \right) } \left( R _ { t + 1 } + \gamma V \left( S _ { t + 1 } \right) \right) - V \left( S _ { t } \right) \right)</script><p>这个公式可以这样解释：</p><p>个体处在状态 $S<em>t$中，基于策略 $\mu$ 产生了一个行为 $A_t$ ，执行该行为后进入新的状态 $S</em>{t+1}$ ，那么在当前策略下如何根据新状态的价值调整原来状态的价值呢？离线策略的方法就是，在状态时 $S_t$ 比较分别依据另一个策略 $\pi$和当前遵循的策略 $\mu$ 产生行为 $A_t$ 的概率大小。</p><ul><li><p>如果策略 $\pi$ 得到的概率值与遵循当前策略 $\mu$ 得到的概率值接近，说明根据状态 $S_{t+1}$ 价值来更新 $S_t$ 的价值同时得到两个策略的支持，这一更新操作比较有说服力。同时也说明在 $S_t$ 状态时，两个策略有接近的概率选择行为 $A_t$ 。</p></li><li><p>如果这一概率比值很小，则表明如果依照被评估的策略，选择 $A<em>t$ 的机会很小，这时候我们在更新  $S_t$ 价值的时候就不能过多的考虑基于当前策略得到的状态 $S</em>{t+1}$ 的价值。同样概率比值大于1时的道理也类似。这就相当于借鉴被评估策略的经验来更新我们自己的策略。</p></li></ul><h3 id="Q学习"><a href="#Q学习" class="headerlink" title="Q学习"></a>Q学习</h3><p>应用上述思想最好的方法是基于TD(0)的Q-学习（Q-learning）。它的要点在于，更新一个状态-行为的Q价值时，遵循策略 $\pi $ 得到的下一个状态行为对的Q价值。公式如下：</p><script type="math/tex; mode=display">Q \left( S _ { t } , A _ { t } \right) \leftarrow Q \left( S _ { t } , A _ { t } \right) + \alpha \left( R _ { t + 1 } + \gamma Q \left( S _ { t + 1 } , A ^ { \prime } \right) - Q \left( S _ { t } , A _ { t } \right) \right)</script><p>式中，$R <em> { t + 1 } + \gamma Q \left( S </em> { t + 1 } , A ^ { \prime } \right)$ TD目标是基于自己的策略(待评估) $\pi$ 产生的行为 $A’$ 得到的$Q$价值。</p><p><strong>Q学习最主要的表现形式是</strong>：个体遵循的策略 $\mu$ 是基于当前状态行为价值函数 $Q(s,a)$ 的一个Ɛ-贪婪策略，而目标策略 $\pi$ 是基于当前状态行为价值函数 $Q(s,a)$ 不包含Ɛ的单纯贪婪策略：</p><script type="math/tex; mode=display">\pi \left( S _ { t + 1 } \right) = \underset { a ^ { \prime } } { \operatorname { argmax } } Q \left( S _ { t + 1 } , a ^ { \prime } \right)</script><p>这样Q学习的TD目标值可以被大幅简化：</p><script type="math/tex; mode=display">\begin{aligned} & R _ { t + 1 } + \gamma Q \left( S _ { t + 1 } , A ^ { \prime } \right) \\ = & R _ { t + 1 } + \gamma Q \left( S _ { t + 1 } , \underset { a ^ { \prime } } { \operatorname { argmax } } Q \left( S _ { t + 1 } , a ^ { \prime } \right) \right) \\ = & R _ { t + 1 } + \max _ { x ^ { \prime } } \gamma Q \left( S _ { t + 1 } , a ^ { \prime } \right) \end{aligned}</script><p><strong>定理：</strong>Q学习控制将收敛至最优状态行为价值函数：$Q(s,a) \rightarrow q_*(s,a)$</p><p>下图是Q学习具体的更新公式和图解：</p><p><img alt="2_10" data-src="//orangesching.github.io/2019/12/02/算法/机器学习/强化学习/强化学习基础4——基于无模型的强化学习方法/2_10.png" class="lazyload"></p><script type="math/tex; mode=display">Q ( S , A ) \leftarrow Q ( S , A ) + \alpha \left( R + \gamma \max _ { a ^ { \prime } } Q \left( S ^ { \prime } , a ^ { \prime } \right) - Q ( S , A ) \right)</script><p>下图是Q学习的算法流程：</p><p><img alt="2_11" data-src="//orangesching.github.io/2019/12/02/算法/机器学习/强化学习/强化学习基础4——基于无模型的强化学习方法/2_11.png" class="lazyload"></p><h2 id="总结DP与TD关系"><a href="#总结DP与TD关系" class="headerlink" title="总结DP与TD关系"></a><strong>总结DP与TD关系</strong></h2><p>下面两张图概括了各种DP算法和各种TD算法，同时也揭示了各种不同算法之间的区别和联系。总的来说TD是采样+有数据引导(bootstrap)，DP是全宽度+实际数据。如果从Bellman期望方程角度看：聚焦于状态本身价值的是迭代法策略评估（DP）和TD学习，聚焦于状态行为对价值函数的则是Q-策略迭代（DP）和SARSA；如果从针对状态行为价值函数的Bellman优化方程角度看，则是Q-价值迭代（DP）和Q学习。</p><p><img alt="2_12" data-src="//orangesching.github.io/2019/12/02/算法/机器学习/强化学习/强化学习基础4——基于无模型的强化学习方法/2_12.png" class="lazyload"></p><p><img alt="2_13" data-src="//orangesching.github.io/2019/12/02/算法/机器学习/强化学习/强化学习基础4——基于无模型的强化学习方法/2_13.png" class="lazyload"></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 机器学习 </category>
          
          <category> 强化学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 强化学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>强化学习基础3——基于模型的动态规划方法</title>
      <link href="/2019/11/30/%E7%AE%97%E6%B3%95/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%803%E2%80%94%E2%80%94%E5%9F%BA%E4%BA%8E%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%96%B9%E6%B3%95/"/>
      <url>/2019/11/30/%E7%AE%97%E6%B3%95/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%803%E2%80%94%E2%80%94%E5%9F%BA%E4%BA%8E%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>上一章我们将强化学习的问题纳入了马尔可夫决策过程的框架下解决。马尔可夫决策过程可以利用元组$<s,a,p,r,\gamma>$来描述，而根据转移概率P是否已知，可以分为基于模型的动态规划方法和基于无模型的强化学习方法。这两类都包括策略迭代算法、值迭代算法、策略搜索算法。</s,a,p,r,\gamma></p><p>本讲着重讲解了利用动态规划来进行强化学习，具体是进行强化学习中的“规划”问题，也就是在已知模型的基础上判断一个策略的价值函数，并在此基础上寻找到最优的策略和最优价值函数，或者直接寻找最优策略和最优价值函数。本讲是整个强化学习课程核心内容的引子。</p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><strong>动态规划算法</strong>是解决复杂问题的一个方法，算法通过把复杂问题分解为子问题，通过求解子问题进而得到整个问题的解。在解决子问题的时候，其结果通常需要存储起来被用来解决后续复杂问题。当问题具有下列特性时，通常可以考虑使用动态规划来求解：第一个特性是一个复杂问题的最优解由数个小问题的最优解构成，可以通过寻找子问题的最优解来得到复杂问题的最优解；子问题在复杂问题内重复出现，使得子问题的解可以被存储起来重复利用。</p><p>马尔科夫决定过程（MDP）具有上述两个属性：Bellman方程把问题递归为求解子问题，价值函数就相当于存储了一些子问题的解，可以复用。因此可以使用动态规划来求解MDP。</p><p>我们用动态规划算法来求解一类称为“规划”的问题。“规划”指的是在了解整个MDP的基础上求解最优策略，也就是清楚模型结构的基础上：包括状态行为空间、转换矩阵、奖励等。这类问题不是典型的强化学习问题，我们可以用<strong>规划</strong>来进行<strong>预测</strong>和<strong>控制</strong>。</p><p>具体的数学描述是这样：</p><p><strong>预测：</strong>给定一个MDP $<s,a,p,r,\gamma>$ 和策略 $\pi$  ，或者给定一个MRP$<s,p^{\pi},r^{\pi},\gamma>$  ，要求输出基于当前策略π的价值函数 $V_{\pi}$ </s,p^{\pi},r^{\pi},\gamma></s,a,p,r,\gamma></p><p><strong>控制：</strong>给定一个MDP$<s,a,p,r,\gamma>$  ，要求确定最优价值函数 $V<em>{*}$ 和最优策略 $\pi</em>{*}$ </s,a,p,r,\gamma></p><h1 id="策略迭代-Policy-Iteration"><a href="#策略迭代-Policy-Iteration" class="headerlink" title="策略迭代 Policy Iteration"></a>策略迭代 Policy Iteration</h1><p>在讨论策略迭代算法前，先讨论两个问题：策略评估和策略改善</p><h2 id="策略评估"><a href="#策略评估" class="headerlink" title="策略评估"></a>策略评估</h2><h3 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h3><p><strong>问题：</strong>评估一个给定的策略π，也就是解决“预测”问题。</p><p><strong>解决方案：</strong>反向迭代应用Bellman期望方程</p><p><strong>具体方法：</strong></p><ul><li><p><strong>同步反向迭代</strong>，即在每次迭代过程中，对于第$k+1$ 次迭代，所有的状态s的价值用$v<em>k(s’)$ 计算并更新该状态第$k+1$  次迭代中使用的价值$v_k(S)$ ，其中$s’$是$s$的后继状态。此种方法通过反复迭代最终将收敛至$V</em>{\pi}$  。</p><script type="math/tex; mode=display">v _ { k + 1 } ( s ) = \sum _ { a \in A } \pi ( a | s ) \left( R _ { s } ^ { a } + \gamma \sum _ { s ^ { \prime } \in S } P _ { s s ^ { \prime } } ^ { a } v _ { k } \left( s ^ { \prime } \right) \right)</script><p>即：一次迭代内，状态s的价值等于前一次迭代该状态的即时奖励与所有s的下一个可能状态s’ 的价值与其概率乘积的和，如图示：<br><img alt="policy_iteration1" data-src="//orangesching.github.io/2019/11/30/算法/机器学习/强化学习/强化学习基础3——基于模型的动态规划方法/policy_iteration1.png" class="lazyload"><br>公式的矩阵形式是：</p><script type="math/tex; mode=display">\mathbf { v } ^ { k + 1 } = \mathcal { R } ^ { \pi } + \gamma \mathcal { P } ^ { \pi } \mathbf { v } ^ { k }</script></li><li><p><strong>异步反向迭代</strong>，即在第k次迭代使用<strong>当次</strong>迭代的状态价值来更新状态价值。</p></li></ul><h3 id="示例——方格世界"><a href="#示例——方格世界" class="headerlink" title="示例——方格世界"></a>示例——方格世界</h3><p><img alt="policy_iteration_example1" data-src="//orangesching.github.io/2019/11/30/算法/机器学习/强化学习/强化学习基础3——基于模型的动态规划方法/policy_iteration_example1.png" class="lazyload"><br><strong>已知：</strong></p><ul><li><strong>状态空间S</strong>：如图。S1 - S14非终止状态，ST终止状态，下图灰色方格所示两个位置；</li><li><strong>行为空间A</strong>：${n, e, s, w} $对于任何非终止状态可以有东南西北移动四个行为；</li><li><strong>转移概率P：</strong>任何试图离开方格世界的动作其位置将不会发生改变，其余条件下将100%地转移到动作指向的状态；</li><li><strong>即时奖励R：</strong>任何在非终止状态间的转移得到的即时奖励均为-1，进入终止状态即时奖励为0；</li><li><strong>衰减系数γ：</strong>1；</li><li><strong>当前策略π：</strong>Agent采用随机行动策略，在任何一个非终止状态下有均等的几率采取任一移动方向这个行为，即$π(n|\cdot) = π(e|\cdot) = π(s|\cdot) = π(w|\cdot) = 1/4$。</li></ul><p><strong>问题：</strong>评估在这个方格世界里给定的策略。<br>   该问题等同于：求解该方格世界在给定策略下的（状态）价值函数，也就是求解在给定策略下，该方格世界里每一个状态的价值。</p><p><strong>求解：迭代法进行策略评估</strong><br><img alt="policy_iteration_example2" data-src="//orangesching.github.io/2019/11/30/算法/机器学习/强化学习/强化学习基础3——基于模型的动态规划方法/policy_iteration_example2.png" class="lazyload"><br>状态价值在第153次迭代后收敛</p><h2 id="策略改善"><a href="#策略改善" class="headerlink" title="策略改善"></a>策略改善</h2><h3 id="理论-1"><a href="#理论-1" class="headerlink" title="理论"></a>理论</h3><p>通过方格世界的例子，我们得到了一个优化策略的办法，分为两步：首先我们在一个给定的策略下迭代更新价值函数：</p><script type="math/tex; mode=display">v _ { \pi } ( s ) = \mathbb { E } \left[ R _ { t + 1 } + \gamma R _ { t + 2 } + \ldots | S _ { t } = s \right]</script><p>随后，在当前策略基础上，贪婪地选取行为，使得后继状态价值增加最多：</p><script type="math/tex; mode=display">\pi' = greedy(v_{\pi})</script><p>在刚才的格子世界中，基于给定策略的价值迭代最终收敛得到的策略就是最优策略，但通过一个回合的迭代计算价值联合策略改善就能找到最优策略不是普遍现象。通常，还需在改善的策略上继续评估，反复多次。不过这种方法总能收敛至最优策略$\pi^*$ 。</p><h3 id="理论证明"><a href="#理论证明" class="headerlink" title="理论证明"></a>理论证明</h3><ol><li><p>考虑一个确定的策略（$a=\pi(s)$）： </p><p>为什么证明这个要考虑确定的策略？因为策略改善使用的贪婪策略，是将一个普通策略（在这个状态下做哪个行动的概率是<em>*</em>）变成了贪婪策略（在这个状态下就做这个行动，这个行动是所有行动里值函数最大的那个）。即为确定策略。</p><p>对于确定策略，由于$\pi(s)=a$（即在这个情况下一定选择这个策略），值函数公式 $v <em> { \pi } ( s ) = \sum </em> { a \in A } \pi ( a | s ) q <em> { \pi } ( s , a )$等于$q </em> { \pi } ( s , a )$ 等于$R<em>s^a + \gamma\sum </em> { s’ \in S } P<em>{ss’}^a v </em> { \pi } ( s’ )$（上一章的知识点）</p></li><li><p>通过贪婪计算优化策略（贪的行为价值函数）：</p><script type="math/tex; mode=display">\pi'(s) = \underset { a \in \mathcal { A } } { \operatorname { argmax } } q _ { \pi } ( s , a )</script></li><li><p>接着推导</p><script type="math/tex; mode=display">q_{\pi}(s,\pi'(s)) = \underset { a \in \mathcal { A } } { \operatorname { max } } q _ { \pi } ( s , a ) \geq q _ { \pi } ( s , \pi(s) ) = v_{\pi}(s)</script><p>由于策略是贪婪q值得到的，则这个更新策略后的q值一定不小于更新前的q值，而根据1所述，$q <em> { \pi } ( s , \pi(s) ) = v</em>{\pi}(s)$。</p></li></ol><ol><li><p>而根据上一章的Bellman最优方程，我们找最优策略的目标是最大化v值，现在的贪婪策略在最大化比v值还大的值，等同于在最大化v值，即v值在每一次迭代都会更大。当$q<em>{\pi}(s,\pi’(s)) = \underset { a \in \mathcal { A } } { \operatorname { max } } q </em> { \pi } ( s , a ) = q <em> { \pi } ( s , \pi(s) ) = v</em>{\pi}(s)$时就可以结束迭代了，因为满足Bellman最优方程，说明当前策略下的状态价值就是最优状态价值。因而此时的策略就是最优策略。</p><p>（$v<em>{\pi’}(s)\geq v</em>{\pi}(s)$证明见David Silver视频PPT）</p></li></ol><h2 id="策略迭代算法-策略评估-策略改善"><a href="#策略迭代算法-策略评估-策略改善" class="headerlink" title="策略迭代算法=策略评估+策略改善"></a><strong>策略迭代算法=策略评估+策略改善</strong></h2><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>在当前策略上迭代计算$v$值，再根据$v$值贪婪地更新策略，如此反复多次，最终得到最优策略$\pi^<em>$ 和最优状态价值函数$V^</em>$  </p><p><strong>贪婪</strong> 指的是仅采取那个（些）使得状态价值得到最大的行为。</p><p><img alt="policy_iteration2" data-src="//orangesching.github.io/2019/11/30/算法/机器学习/强化学习/强化学习基础3——基于模型的动态规划方法/policy_iteration2.png" class="lazyload"></p><p><img alt="policy_iteration_algorithm" data-src="//orangesching.github.io/2019/11/30/算法/机器学习/强化学习/强化学习基础3——基于模型的动态规划方法/policy_iteration_algorithm.png" class="lazyload"></p><h3 id="示例——连锁汽车租赁"><a href="#示例——连锁汽车租赁" class="headerlink" title="示例——连锁汽车租赁"></a>示例——连锁汽车租赁</h3><p>举了一个汽车租赁的例子，说明如何在给定策略下得到基于该策略的价值函数，并根据更新的价值函数来调整策略，直至得到最优策略和最优价值函数。</p><p>一个连锁汽车租赁公司有两个地点提供汽车租赁，由于不同的店车辆租赁的市场条件不一样，为了能够实现利润最大化，该公司需要在每天下班后在两个租赁点转移车辆，以便第二天能最大限度的满足两处汽车租赁服务。</p><p><strong>已知</strong></p><p><strong>状态空间：</strong>2个地点，每个地点最多20辆车供租赁</p><p><strong>行为空间：</strong>每天下班后最多转移5辆车从一处到另一处；</p><p><strong>即时奖励：</strong>每租出1辆车奖励10元，必须是有车可租的情况；不考虑在两地转移车辆的支出。</p><p><strong>转移概率：</strong>求租和归还是随机的，但是满足泊松分布  。第一处租赁点平均每天租车请求3次，归还3次；第二处租赁点平均每天租车4次，归还2次。</p><p><strong>衰减系数</strong> $\gamma$：0.9；</p><p><strong>问题：</strong>怎样的策略是最优策略？</p><p><strong>求解方法：</strong>从一个确定的策略出发进行迭代，该策略可以是较为随意的，比如选择这样的策略：不管两地租赁业务市场需求，不移动车辆。以此作为给定策略进行价值迭代，当迭代收敛至一定程度后，改善策略，随后再次迭代，如此反复，直至最终收敛。</p><p>在这个问题中，状态用两个地点的汽车存量来描述，比如分别用c1,c2表示租赁点1,2两处的可租汽车数量，可租汽车数量同时参与决定夜间可转移汽车的最大数量。</p><p>解决该问题的核心就是依据泊松分布确定状态<c1,c2>的即时奖励，进而确定每一个状态的价值。</c1,c2></p><p><img alt="policy_iteration_example3" data-src="//orangesching.github.io/2019/11/30/算法/机器学习/强化学习/强化学习基础3——基于模型的动态规划方法/policy_iteration_example3.png" class="lazyload"></p><h2 id="改进策略迭代"><a href="#改进策略迭代" class="headerlink" title="改进策略迭代"></a>改进策略迭代</h2><p>有时候不需要持续迭代至最有价值函数，可以设置一些条件提前终止迭代</p><ul><li>比如设定一个$ \epsilon $，比较两次迭代的价值函数平方差</li><li>直接设置迭代次数</li></ul><h1 id="价值迭代-Value-Iteration"><a href="#价值迭代-Value-Iteration" class="headerlink" title="价值迭代 Value Iteration"></a>价值迭代 Value Iteration</h1><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><h3 id="优化原则-Principle-of-Optimality"><a href="#优化原则-Principle-of-Optimality" class="headerlink" title="优化原则 Principle of Optimality"></a>优化原则 Principle of Optimality</h3><p>一个最优策略可以被分解为两部分</p><ol><li>从状态 $s$ 到下一个状态 $s’$ 采取了最优行为$A_*$  </li><li>在状态 $s’$ 时遵循一个最优策略</li></ol><blockquote><p><strong>定理</strong></p><p>一个策略能够使得状态s获得最优价值，当且仅当：对于从状态$s$可以到达的任何状态$s’$，该策略能够使得状态s’的价值是最优价值：</p></blockquote><h3 id="确定性的价值迭代"><a href="#确定性的价值迭代" class="headerlink" title="确定性的价值迭代"></a>确定性的价值迭代</h3><p>如果我们知道了子问题$v<em>*(s’)$，则$v</em>*(s)$只需要通过一步就能得到</p><script type="math/tex; mode=display">v _ { * } ( s ) \leftarrow \max _ { a \in \mathcal { A } } \mathcal { R } _ { s } ^ { a } + \gamma \sum _ { s ^ { \prime } \in \mathcal { S } } \mathcal { P } _ { s s ^ { \prime } } ^ { a } v _ { * } \left( s ^ { \prime } \right)</script><p><strong>示例——最短路径</strong></p><p><img alt="value_iteration_example1" data-src="//orangesching.github.io/2019/11/30/算法/机器学习/强化学习/强化学习基础3——基于模型的动态规划方法/value_iteration_example1.png" class="lazyload"></p><p><strong>问题：</strong>如何在一个4*4的方格世界中，找到任一一个方格到最左上角方格的最短路径</p><p>如果我们清楚地知道我们期望的最终（goal）状态的位置以及反推需要明确的状态间关系，那么可以认为是一个<strong>确定性的价值迭代</strong>。此时，我们可以把问题分解成一些列的子问题，从最终目标状态开始分析，逐渐往回推，直至推至所有状态。</p><p>简要思路：在已知左上角为最终目标的情况下，我们可以从与左上角相邻的两个方格开始计算，因为这两个方格是可以仅通过1步就到达目标状态的状态，或者说目标状态是这两个状态的后继状态。最短路径可以量化为：每移动一步获得一个-1的即时奖励。为此我们可以更新与目标方格相邻的这两个方格的状态价值为-1。如此依次向右下角倒推，直至所有状态找到最短路径。</p><h2 id="价值迭代算法-value-iteration"><a href="#价值迭代算法-value-iteration" class="headerlink" title="价值迭代算法 value iteration"></a>价值迭代算法 value iteration</h2><p><strong>问题：</strong>寻找最优策略π</p><p><strong>解决方案：</strong>采用Bellman最优方程，从初始状态价值开始同步迭代计算，最终收敛，整个过程中没有遵循任何策略</p><script type="math/tex; mode=display">V _ { k + 1 } ( s ) = \max _ { a } \sum _ { s ^ { \prime } , r } P \left( s ^ { \prime } , r | s , a \right) \left( r + \gamma V _ { k } \left( s ^ { \prime } \right) \right)</script><p><img alt="value_iteration_algorithm" data-src="//orangesching.github.io/2019/11/30/算法/机器学习/强化学习/强化学习基础3——基于模型的动态规划方法/value_iteration_algorithm.png" class="lazyload"></p><p>对每一个当前状态 $s$ ,对每个可能的动作 $a$ 都计算一下采取这个动作后到达的下一个状态的期望价值。看看哪个动作可以到达的状态的期望价值函数最大，就将这个最大的期望价值函数作为当前状态的价值函数 $V(s)$ 循环执行这个步骤，直到价值函数收敛。</p><h2 id="价值迭代算法与策略迭代算法的区别"><a href="#价值迭代算法与策略迭代算法的区别" class="headerlink" title="价值迭代算法与策略迭代算法的区别"></a>价值迭代算法与策略迭代算法的区别</h2><ul><li>策略迭代有一个策略直接作用于value空间（即不会有value值来构建策略，策略再构建value值的过程）；而价值迭代过程其间得到的价值函数，不对应任何策略</li><li>值迭代是根据状态期望值选择动作，而策略迭代是先估计状态值然后修改策略 </li></ul><h1 id="同步动态规划问题总结"><a href="#同步动态规划问题总结" class="headerlink" title="同步动态规划问题总结"></a>同步动态规划问题总结</h1><p><img alt="conclusion" data-src="//orangesching.github.io/2019/11/30/算法/机器学习/强化学习/强化学习基础3——基于模型的动态规划方法/conclusion.png" class="lazyload"></p><ul><li><p><strong>预测问题</strong>：在给定策略下迭代计算价值函数。</p></li><li><p><strong>控制问题</strong>：策略迭代寻找最优策略问题则先在给定或随机策略下计算状态价值函数，根据状态函数贪婪更新策略，多次反复找到最优策略；单纯使用价值迭代，全程没有策略参与也可以获得最优策略，但需要知道状态转移矩阵，即状态s在行为a后到达的所有后续状态及概率。</p><p> 使用状态价值函数或行为价值函数两种价值迭代的算法时间复杂度都较大，为 $O(mn^2)$ 或$O(m^2n^2)$  。一种改进方案是使用异步动态规划，其他的方法即放弃使用动态规划，随后的几讲中将详细讲解其他方法。</p></li></ul><h1 id="动态规划的一些扩展"><a href="#动态规划的一些扩展" class="headerlink" title="动态规划的一些扩展"></a>动态规划的一些扩展</h1><h2 id="异步动态规划-Asynchronous-Dynamic-Programming"><a href="#异步动态规划-Asynchronous-Dynamic-Programming" class="headerlink" title="异步动态规划 Asynchronous Dynamic Programming"></a>异步动态规划 Asynchronous Dynamic Programming</h2><p>几个可能改进的点子</p><h3 id="原位动态规划-In-place-dynamic-programming"><a href="#原位动态规划-In-place-dynamic-programming" class="headerlink" title="原位动态规划(In-place dynamic programming)"></a>原位动态规划(In-place dynamic programming)</h3><p>直接原地更新下一个状态的v值，而不像同步迭代那样需要额外存储新的v值。在这种情况下，<strong>按何种次序更新状态价值有时候会比较有意义</strong>。</p><script type="math/tex; mode=display">v ( s ) \leftarrow \max _ { a \in \mathcal { A } } \left( \mathcal { R } _ { s } ^ { a } + \gamma \sum _ { s ^ { \prime } \in \mathcal { S } } \mathcal { P } _ { s s ^ { \prime } } ^ { a } v \left( s ^ { \prime } \right) \right)</script><h3 id="重要状态优先更新-Priortised-Sweeping"><a href="#重要状态优先更新-Priortised-Sweeping" class="headerlink" title="重要状态优先更新(Priortised Sweeping)"></a>重要状态优先更新(Priortised Sweeping)</h3><p>对那些重要的状态优先更新。</p><p>使用Bellman error：</p><script type="math/tex; mode=display">\max _ { a \in \mathcal { A } } \left( \mathcal { R } _ { s } ^ { a } + \gamma \sum _ { s ^ { \prime } \in \mathcal { S } } \mathcal { P } _ { s s ^ { \prime } } ^ { a } v \left( s ^ { \prime } \right) \right) - v ( s )</script><p>来确定哪些状态是比较重要的。Bellman error 反映的是当前的状态价值与更新后的状态价值差的绝对值。Bellman error越大，越有必要优先更新。对那些Bellman error较大的状态进行备份。这种算法使用优先级队列能够较得到有效的实现。</p><h3 id="实时动态规划-Real-time-dynamic-programming"><a href="#实时动态规划-Real-time-dynamic-programming" class="headerlink" title="实时动态规划(Real-time dynamic programming)"></a>实时动态规划(Real-time dynamic programming)</h3><p>更新那些仅与个体关系密切的状态，同时使用个体的经验来知道更新状态的选择。有些状态虽然理论上存在，但在现实中几乎不会出现。利用已有现实经验。</p><script type="math/tex; mode=display">v \left( S _ { t } \right) \leftarrow \max _ { a \in \mathcal { A } } \left( \mathcal { R } _ { S _ { t } } ^ { a } + \gamma \sum _ { s ^ { \prime } \in \mathcal { S } } \mathcal { P } _ { S _ { t s ^ { \prime } } } ^ { a } v \left( s ^ { \prime } \right) \right)</script><p>St是实际与Agent相关或者说Agent经历的状态，可以省去关于那些仅存在理论上的状态的计算。</p><h2 id="采样更新-Sample-Backups"><a href="#采样更新-Sample-Backups" class="headerlink" title="采样更新 Sample Backups"></a>采样更新 Sample Backups</h2><p>动态规划使用full-width backups。意味着使用DP算法，对于每一次状态更新，都要考虑到其所有后继状态及所有可能的行为，同时还要使用MDP中的状态转移矩阵、奖励函数（信息）。DP解决MDP问题的这一特点决定了其对中等规模（百万级别的状态数）的问题较为有效，对于更大规模的问题，会带来Bellman维度灾难。</p><p>因此在面对大规模MDP问题是，需要寻找更加实际可操作的算法，主要的思想是Sample Backups，后续会详细介绍。这类算法的优点是不需要完整掌握MDP的条件（例如奖励机制、状态转移矩阵等），通过Sampling（举样）可以打破维度灾难，反向更新状态函数的开销是常数级别的，与状态数无关。</p><h2 id="近似动态规划-Approximate-Dynamic-Programming"><a href="#近似动态规划-Approximate-Dynamic-Programming" class="headerlink" title="近似动态规划 Approximate Dynamic Programming"></a>近似动态规划 Approximate Dynamic Programming</h2><p>使用其他技术手段（例如神经网络）建立一个参数较少，消耗计算资源较少、同时虽然不完全精确但却够用的近似价值函数：</p><script type="math/tex; mode=display">\bar { v } _ { k } ( s ) = \max _ { a \in \mathcal { A } } \left( \mathcal { R } _ { s } ^ { a } + \gamma \sum _ { s ^ { \prime } \in \mathcal { S } } \mathcal { P } _ { s s ^ { \prime } } ^ { a } v \left( s ^ { \prime } , w _ { k } \right) \right)</script><p>注：本讲的内容主要还是在于理解强化学习的基本概念，各种Bellman方程，在实际应用中，很少使用动态规划来解决大规模强化学习问题。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 机器学习 </category>
          
          <category> 强化学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 强化学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>强化学习基础2——强化学习问题描述</title>
      <link href="/2019/11/22/%E7%AE%97%E6%B3%95/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%802%E2%80%94%E2%80%94%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0/"/>
      <url>/2019/11/22/%E7%AE%97%E6%B3%95/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%802%E2%80%94%E2%80%94%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<p>在强化学习中，马尔科夫决策过程（Markov decision process, MDP）是对环境进行描述的工具。几乎所有的强化学习问题都可以转化为MDP。 </p><p>本章的脉络为</p><ol><li>马尔科夫性（介绍状态的马尔科夫性和状态转移概率）</li><li>马尔科夫过程（由有限具有马尔科夫性的状态和状态转移概率组成的马尔科夫链）</li><li>马尔科夫奖励过程（在马尔科夫过程的基础上加入奖励和衰减系数）</li><li>马尔科夫决策过程（在马尔科夫奖励过程的基础上加入动作）</li></ol><h1 id="马尔可夫性（Markov-Property）"><a href="#马尔可夫性（Markov-Property）" class="headerlink" title="马尔可夫性（Markov Property）"></a>马尔可夫性（Markov Property）</h1><p>未来只依赖于最近给定的状态，则认为该状态具有<strong>马尔科夫性</strong>。即：</p><script type="math/tex; mode=display">\mathrm{P}\left[S_{\mathrm{r}+1} | \mathrm{S}_{t} \right] = \mathrm{P}\left[S_{\mathrm{}+1} | \mathrm{S}_{1}, \ldots, \mathrm{S}_{\mathrm{t}}\right]</script><p><strong>状态转移概率公式</strong>可以用来描述马尔科夫性：</p><script type="math/tex; mode=display">\mathcal{P}_{s s^{\prime}}=\mathrm{P}\left[S_{t+1}=s^{\prime} | S_{t}=s\right]</script><p><strong>状态转移矩阵</strong> $\mathcal{P}$ 用来表示当前任意状态转移到其他状态的概率。每一行代表，当前处于这种状态时，下一个状态出现的概率</p><script type="math/tex; mode=display">\text{to} \\\mathcal{P}=\text { from }\left[\begin{array}{ccc}{\mathcal{P}_{11}} & {\cdots} & {\mathcal{P}_{1 n}} \\ {\vdots} & {} & {} \\ {\mathcal{P}_{n 1}} & {\cdots} & {\mathcal{P}_{n n}}\end{array}\right]</script><p> 式中n为状态数量，矩阵中每一行元素之和为1. </p><h1 id="马尔可夫过程（Markov-Process）"><a href="#马尔可夫过程（Markov-Process）" class="headerlink" title="马尔可夫过程（Markov Process）"></a>马尔可夫过程（Markov Process）</h1><p> <strong>马尔科夫过程</strong> 又叫马尔科夫链(Markov Chain)，是一个无记忆的随机过程</p><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>可以用一个元组$<s, \mathcal{p}>$表示</s,></p><ul><li>$S$ 是具有马尔科夫性的有限随机状态集${\mathrm{S}_1，\mathrm{S}_2，\cdots}$</li><li>$\mathcal{P}$是状态之间的转移概率矩阵</li></ul><h2 id="例"><a href="#例" class="headerlink" title="例"></a>例</h2><p><img alt="student_markov_chain" data-src="//orangesching.github.io/2019/11/22/算法/机器学习/强化学习/强化学习基础2——强化学习问题描述/student_markov_chain.png" class="lazyload"></p><p>圆圈表示学生所处的状态，方块Sleep表示马尔科夫链的最终状态或者可以描述成自循环的状态，也就是Sleep状态的下一个状态100%的几率还是自己。箭头表示状态之间的转移，箭头上的数字表示当前转移的概率。 右边是这个马尔科夫链对应的状态转移矩阵。</p><p> 当学生处在第一节课（Class1）时，他/她有50%的几率会参加第2节课（Class2）；同时在也有50%的几率不在认真听课，进入到浏览facebook这个状态中。在浏览facebook这个状态时，他有90%的几率在下一时刻继续浏览，也有10%的几率返回到课堂内容上来。当学生进入到第二节课（Class2）时，会有80%的几率继续参加第三节课（Class3），也有20%的几率觉得课程较难而退出（Sleep）。当学生处于第三节课这个状态时，他有60%的几率通过考试，继而100%的退出该课程，也有40%的可能性去酒吧，又分别有20%、40%、40%的几率返回值第一、二、三节课重新继续学习。 </p><p>一个学生从状态Class1开始，最终结束于Sleep，其间的过程根据状态转化图可以有很多种可能性，这些都称为<strong>样本集（Sample Episodes）</strong>。一个<strong>采样</strong>是从初始状态到结束状态的一个状态序列，以下采样都是可能的：</p><ul><li>C1 - C2 - C3 - Pass - Sleep</li><li>C1 - FB - FB - C1 - C2 - Sleep</li><li>C1 - C2 - C3 - Pub - C2 - C3 - Pass - Sleep</li></ul><h1 id="马尔科夫奖励过程（-Markov-Reward-Process）"><a href="#马尔科夫奖励过程（-Markov-Reward-Process）" class="headerlink" title="马尔科夫奖励过程（ Markov Reward Process）"></a>马尔科夫奖励过程（ Markov Reward Process）</h1><p>马尔科夫奖励过程可以看做带有value判断的马尔科夫过程，这个value标志着这个状态的好坏。它在马尔科夫过程的基础上增加了<strong>奖励$R$</strong>和<strong>衰减系数$\gamma$</strong>。</p><h2 id="描述-概念"><a href="#描述-概念" class="headerlink" title="描述 / 概念"></a>描述 / 概念</h2><p>可以用四元组$<s, p, r, \gamma>$表示，分别是状态，转移概率，即时奖励，衰减系数。</s,></p><ul><li><p><strong>即时奖励（Reward）</strong> $R$</p><p>某一时刻（$t$）处在状态$s$下，在下 一个时刻（$t+1$）能获得的<strong>奖励期望</strong>，即为状态$s$下的奖励，与下一刻去哪个状态没有关系：</p><script type="math/tex; mode=display">R_{s}=E\left[R_{t+1} | S_{t}=s\right]</script><p>例：马尔科夫奖励过程图示。在“马尔科夫过程”基础上增加了针对每一个状态的奖励</p><img title="This is an example image" data-src="/2019/11/22/算法/机器学习/强化学习/强化学习基础2——强化学习问题描述/Student_MRP.png" class="lazyload"><p>当学生处于 Class1 状态时，若他选择参加 Class2 获得的 Reward 是 -2；若他选择去刷 Facebook  获得的 Reward 是 -2。即他从 Class1 状态离开就可获得立即奖励，这个即时奖励和他去哪没关系。</p></li></ul><ul><li><p><strong>收益（ Return）</strong> $G_t$</p><p>由于即时奖励与具体的下一状体没关系，引入收益，来量化一个片段（Episode）的奖励和</p><p>收益为在一个马尔科夫奖励链上从 $t$ 时刻开始往后所有有衰减的奖励和。公式如下：</p><script type="math/tex; mode=display">G_{t}=R_{t+1}+\gamma R_{t+2}+\ldots=\sum_{k=0}^{\infty} \gamma^{k} R_{t+k+1}</script><p>其中<strong>衰减系数 （Discount Factor）</strong> $\gamma \in [0,1]$ 体现了未来的奖励在当前时刻的价值比例，在 $k+1$ 时刻获得的奖励 $R$ 在t时刻的体现出的价值是  $\gamma^{k} R$，$\gamma$ 接近于0，表明趋向于“近视”性评估（贪婪）；γ接近1则表明偏重考虑远期的收益。</p><p><em>这里是从$R<em>{t+1}$开始算起的，因为描述上通常是智能体在$t$时刻做了一个操作，环境接收操作后更新时间，所以这个奖励通常描述为$R</em>{t+1}$</em></p><blockquote><p>衰减系数的引入有很多理由，其中有数学表达的方便，避免陷入无限循环，远期利益具有一定的不确定性，符合人类对于眼前利益的追求，符合金融学上获得的利益能够产生新的利益因而更有价值等等。</p></blockquote></li></ul><p>  收益值是针对一次片段的结果，存在很大的样本偏差。$G_t$ 是从 $t$ 时刻的状态到终止状态的一条状态转移序列的收益值，但从 $t$ 时刻的状态到终止状态可能有多条路径，就如上述状态转移图所示（而且可能还有很多序列没有观测到）。故要想精确的计算出 $G_t$ 是不可能的，因为无法穷举所有序列。</p><ul><li><p><strong>价值函数 Value Function</strong></p><p>引入价值函数是为了解决每个取样都对应一个$G_t$的问题。价值函数是一个数值包含了多条路径。</p><p>价值函数给出了某一状态或某一行为的长期价值，用来衡量一个状态的好坏。</p><p>一个马尔科夫奖励过程中某一状态的价值函数，为从该状态开始的马尔可夫链收获的期望：</p><script type="math/tex; mode=display">v(s)=E\left[G_{t} | S_{t}=s\right]</script><p><em>注：价值可以仅描述状态，也可以描述某一状态下的某个行为，在一些特殊情况下还可以仅描述某个行为</em></p></li></ul><h2 id="例-1"><a href="#例-1" class="headerlink" title="例"></a>例</h2><p>为方便计算，把“学生马尔科夫奖励过程”示例图表示成下表的形式。表中第二行对应各状态的即时奖励值，蓝色区域数字为状态转移概率，表示为从所在行状态转移到所在列状态的概率：</p><p><img alt="MRP_example1" data-src="//orangesching.github.io/2019/11/22/算法/机器学习/强化学习/强化学习基础2——强化学习问题描述/MRP_example1.png" class="lazyload"></p><p><strong>收益计算例</strong></p><p>在$t=1$时刻（$S<em>{1}=C</em>{1}$）时状态 $S_1$ 的收益公式：            </p><script type="math/tex; mode=display">G_{1}=R_{2}+\gamma R_{3}+\ldots +\gamma^{r-2} R_{r}</script><p>如下4个马尔科夫链取样，现计算当$\gamma= 1/2$时的收益值。</p><p><img alt="MRP_example" data-src="//orangesching.github.io/2019/11/22/算法/机器学习/强化学习/强化学习基础2——强化学习问题描述/MRP_example2.png" class="lazyload"></p><p>从上表也可以理解到，收益是针对一个马尔科夫链中的<strong>某一个状态</strong>来说的。且收益是不确定的，随机的（因为取样是随机的）。但是价值函数不是随机的，价值函数是收益的期望</p><p><strong>价值计算例</strong></p><p>对于上述状态转移图如果仅仅观测到以上 4 条序列，那么在状态 Class1 处的学生的值函数就是上述 4 个 值除以 4 即可。</p><script type="math/tex; mode=display">v(Class1) = ( (-2.25) + (-3.125) + (-3.41) + (-3.21) )  ÷ 4 =  2.996</script><p><strong>不同衰减系数下</strong></p><p>当$\gamma = 0$时，上表描述的MRP中，各状态的即时奖励就与该状态的价值相同。当$\gamma \neq 0$时，各状态的价值需要通过计算得到，这里先给出$ \gamma $分别为0，0.9，和1三种情况下各状态的价值，如下图所示。</p><p>各状态圈内的数字表示该状态的价值，圈外的$R=-2$等表示的是该状态的即时奖励。</p><p><img alt="MRP_example" data-src="//orangesching.github.io/2019/11/22/算法/机器学习/强化学习/强化学习基础2——强化学习问题描述/MRP_example3.png" class="lazyload"><img alt="MRP_example" data-src="//orangesching.github.io/2019/11/22/算法/机器学习/强化学习/强化学习基础2——强化学习问题描述/MRP_example4.png" class="lazyload"><img alt="MRP_example" data-src="//orangesching.github.io/2019/11/22/算法/机器学习/强化学习/强化学习基础2——强化学习问题描述/MRP_example5.png" class="lazyload"></p><blockquote><p><strong>各状态价值的确定是很重要的，RL的许多问题可以归结为求状态的价值问题</strong>。假设你已经算出来上面的各个状态下的值函数，那么对于强化学习而言，假设是找到一条最优路径，起点状态是 Class1 ，那么很明显最优状态链是class1-&gt;class2-&gt;class3-&gt;pass-&gt;sleep，也就是说<strong>这条路径的累计回报</strong>最大，也就是说值函数求出来了，其实强化学习问题就解决了，对应的就是后续的值迭代法、Q-learning等思路了。因此如何求解各状态的价值，也就是寻找一个价值函数（从状态到价值的映射）就变得很重要了。</p></blockquote><h2 id="价值函数的推导"><a href="#价值函数的推导" class="headerlink" title="价值函数的推导"></a>价值函数的推导</h2><p>状态值函数的引入解决了不同路径收益不同问题。但状态值函数不好算，因为在计算某个状态的价值时，需要使用到将来所有状态的 $G_t$，这明显是不科学的。所以需要进一步推导价值函数<strong>使价值函数容易求解</strong>。</p><h3 id="按价值定义公式推导"><a href="#按价值定义公式推导" class="headerlink" title="按价值定义公式推导"></a>按价值定义公式推导</h3><script type="math/tex; mode=display">\begin{aligned} v(s) &=\mathbb{E}\left[G_{t} | S_{t}=s\right] \\ &=\mathbb{E}\left[R_{t+1}+\gamma R_{t+2}+\gamma^{2} R_{t+3}+\ldots | S_{t}=s\right] \\ &=\mathbb{E}\left[R_{t+1}+\gamma\left(R_{t+2}+\gamma R_{t+3}+\ldots\right) | S_{t}=s\right] \\ &=\mathbb{E}\left[R_{t+1}+\gamma G_{t+1} | S_{t}=s\right] \\ &=\mathbb{E}\left[R_{t+1}+\gamma v\left(S_{t+1}\right) | S_{t}=s\right] \end{aligned}</script><p>在导出最后一行时，将$G<em>{t+1}$ 变成了 $v\left(S</em>{t+1}\right)$。其理由是收获的期望等于收获的期望的期望。</p><h3 id="Bellman方程"><a href="#Bellman方程" class="headerlink" title="Bellman方程"></a>Bellman方程</h3><p>先看看贝尔曼方程是什么</p><blockquote><p>贝尔曼方程，又叫动态规划方程，是以Richard Bellman命名的，表示动态规划问题中相邻状态关系的方程。某些决策问题可以按照时间或空间分成多个阶段，每个阶段做出决策从而使整个过程取得效果最优的多阶段决策问题，可以用动态规划方法求解。某一阶段最优决策的问题，通过贝尔曼方程转化为下一阶段最优决策的子问题，从而初始状态的最优决策可以由终状态的最优决策(一般易解)问题逐步迭代求解。存在某种形式的贝尔曼方程，是动态规划方法能得到最优解的必要条件。 </p></blockquote><p>（哦！动态规划的递推式，推出了这个就可以用递归/递推来求价值函数了）</p><p>根据上面对价值函数的定义公式的推导，最后我们得到了针对MRP的Bellman方程： </p><script type="math/tex; mode=display">v(s)=\mathbb{E}\left[R_{t+1}+\gamma v\left(S_{t+1}\right) | S_{t}=s\right]</script><p>通过方程可以看出 $v(s)$ 由两部分组成</p><ul><li><p>$s$ 状态的即时奖励期望。即时奖励期望等于即时奖励，因为根据即时奖励的定义，它与下一个状态无关</p></li><li><p>下一时刻状态的价值期望的衰减值，可以根据下一时刻状态的概率分布得到其期望。</p></li></ul><p>如果用 $s’$ 表示 $s$ 状态下一时刻任一可能的状态，那么Bellman方程可以写成：</p><script type="math/tex; mode=display">v(s)=\mathcal{R}_{s}+\gamma \sum_{s^{\prime} \in \mathcal{S}} \mathcal{P}_{s s^{\prime}} v\left(s^{\prime}\right)</script><p>即计算状态 s 的值函数方法 = 该状态的立即奖励 + 遍历该状态的各个后继状态，对于每一个后继状态：$\gamma$  × 状态转移概率  × 后继状态的值函数 求和。 </p><p><strong>例</strong><br>下图已经给出了$\gamma=1$时各状态的价值，状态$C_3$  的价值可以通过状态Pub和Pass的价值以及他们之间的状态转移概率来计算：</p><script type="math/tex; mode=display">4.3=-2+1.0 *(0.6 * 10+0.4 * 0.8)</script><p><img alt="MRP_Bellman_example" data-src="//orangesching.github.io/2019/11/22/算法/机器学习/强化学习/强化学习基础2——强化学习问题描述/MRP_Bellman_example.png" class="lazyload"></p><h3 id="Bellman方程的矩阵形式和求解"><a href="#Bellman方程的矩阵形式和求解" class="headerlink" title="Bellman方程的矩阵形式和求解"></a>Bellman方程的矩阵形式和求解</h3><script type="math/tex; mode=display">v=\mathcal{R}+\gamma \mathcal{P} v</script><p>结合矩阵的具体表达形式还是比较好理解的：</p><script type="math/tex; mode=display">\left[\begin{array}{c}{v(1)} \\ {\vdots} \\ {v(n)}\end{array}\right]=\left[\begin{array}{c}{\mathcal{R}_{1}} \\ {\vdots} \\ {\mathcal{R}_{n}}\end{array}\right]+\gamma\left[\begin{array}{ccc}{\mathcal{P}_{11}} & {\cdots} & {\mathcal{P}_{1 n}} \\ {\vdots} & {} & {} \\ {\mathcal{P}_{11}} & {\cdots} & {\mathcal{P}_{n n}}\end{array}\right]\left[\begin{array}{c}{v(1)} \\ {\vdots} \\ {v(n)}\end{array}\right]</script><p>Bellman方程是一个线性方程组，因此理论上解可以直接求解：</p><script type="math/tex; mode=display">\begin{aligned} v & = \mathcal { R } + \gamma \mathcal { P } v \\ ( I - \gamma \mathcal { P } ) v & = \mathcal { R } \\ v & = ( l - \gamma \mathcal { P } ) ^ { - 1 } \mathcal { R } \end{aligned}</script><p>实际上，计算复杂度是$O(n^3)$ ， $n$是状态数量。因此直接求解仅适用于小规模的MRPs。大规模MRP的求解通常使用迭代法。常用的迭代方法有：动态规划Dynamic Programming、蒙特卡洛评估Monte-Carlo evaluation、时序差分学习Temporal-Difference。</p><h1 id="马尔科夫决策过程（Markov-Decision-Process）"><a href="#马尔科夫决策过程（Markov-Decision-Process）" class="headerlink" title="马尔科夫决策过程（Markov Decision Process）"></a>马尔科夫决策过程（Markov Decision Process）</h1><p>相较于马尔科夫奖励过程，马尔科夫决策过程多了一个行为集合$A$</p><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>马尔科夫决策过程(MDP)与MP、MRP的区别</p><ul><li>在MP和MRP中，我们都是作为观察者，去观察其中的状态转移现象，去计算回报值</li><li>对于一个RL问题，我们更希望去改变状态转移的流程，去最大化回报值</li><li>通过MRP中引入决策即得到了马尔科夫决策过程</li></ul><h2 id="描述-概念-1"><a href="#描述-概念-1" class="headerlink" title="描述 / 概念"></a>描述 / 概念</h2><p>它是这样的一个五元组$M=(S,A,P,R,\gamma)$描述</p><ul><li><p>$ S $：表示状态集(states)，有$s \in S$，$s_i$ 表示第 $i$ 步的状态。</p></li><li><p>$A$：表示一组动作(actions)，有$a \in A$，$a_i$ 表示第 $i$ 步的动作。</p></li><li><p>$P$：表示状态转移概率。表示的是在当前$s \in S$状态下，经过$a \in A$作用后，会转移到的其他状态的概率分布情况。比如，在状态$s$下执行动作$a$，转移到$s’$的概率可以表示为$p(s’|s,a)$，具体的数学表达式如下：</p><script type="math/tex; mode=display">\mathcal{P}_{s s^{\prime}}^{a}=\mathbb{P}\left[S_{t+1}=s^{\prime} | S_{t}=s, A_{t}=a\right]</script><p>（个人理解：马尔科夫奖励过程是在当前状态下选择到下一状态，而马尔可夫决策过程是在当前状态下先选择一个动作，这个动作会有不同的概率导向不同的新状态，智能体只能做这个动作，不能控制这个动作导向的状态，这个动作导向的结果由环境决定，所以马尔可夫决策过程很适合描述强化学习场景。这里的状态转移概率矩阵是三维的，第一维是当前状态，第二维是所做动作，第三维是下一状态，下面的回报函数同理）</p></li><li><p>$R$：回报函数(reward function)。$R(s, a)$ 描述了在状态 $s$做动作 $a$的奖励。与MRP的奖励与状态对应不同，<strong>MDP的奖励是与动作对应的</strong>，具体的数学表达式如下：</p><script type="math/tex; mode=display">\mathcal{R}_{s}^{a}=\mathbb{E}\left[R_{t+1} | S_{t}=s, A_{t}=a\right]</script></li><li><p>$\gamma$ ：衰减系数</p></li></ul><p>注意：$P$和$R$看起来很类似马尔科夫奖励过程，但这里的它们都与具体的<strong>行为</strong> $a$ 对应，而不像马尔科夫奖励过程那样仅对应于某个状态</p><p>在马尔可夫决策过程中能够随意愿改变的变成了动作。我们关心的是在什么情况先该做什么动作</p><p><strong>例</strong></p><p>下图给出了一个可能的MDP的状态转化图。图中红色的文字表示的是采取的行为，而不是先前的状态名。对比之前的学生MRP示例可以发现，即时奖励与行为对应了，同一个状态下采取不同的行为得到的即时奖励是不一样的。由于引入了Action，容易与状态名混淆，因此此图没有给出各状态的名称；此图还把Pass和Sleep状态合并成一个终止状态；另外当选择”去酒吧”这个动作时，<strong>主动</strong>进入了一个临时状态（ 这样的状态不属于MDP中考虑的状态 ，图中用黑色小实点表示），随后<strong>被动的</strong>被环境按照其动力学分配到另外三个状态（正式的），也就是说Agent做出一个动作后没有权利选择决定去哪一个状态。</p><p><img alt="MDP_example" data-src="//orangesching.github.io/2019/11/22/算法/机器学习/强化学习/强化学习基础2——强化学习问题描述/MDP_example.png" class="lazyload"></p><p> 注，图中除了在 Class4 状态上执行 去酒吧 动作外，其他的所有状态跳转都是确定性，我们通过在不同的状态上执行不同的动作，实现状态跳转。 </p><h3 id="策略Policy"><a href="#策略Policy" class="headerlink" title="策略Policy"></a>策略Policy</h3><p>策略 $\pi$ 是概率的集合或分布，其元素 $\pi(a|s)$  在某一状态$s$采取可能的行为$a$的概率。用$\pi(a|s)$  表示</p><script type="math/tex; mode=display">\pi ( a | s ) = \mathbb { P } \left[ A _ { t } = a | S _ { t } = s \right]</script><p>策略π有两个含义</p><ol><li>当为确定性策略的时候，$\pi$就等于$a$表示一个动作；</li><li>当策略不确定的时候，就表示一个动作分布。假设动作是有限的，我们就会写成一个向量，向量上的值对应相应动作的概率，该向量求和为1</li></ol><p>注意：</p><ul><li><p>策略是对智能体行为的全部描述，若策略给定，所有动作将被确定。</p></li><li><p>在MDPs中的策略是基于马尔科夫状态的（而不是基于历史的）</p></li><li><p>策略是时间稳定的，只和$s$有关，与时间$t$无关。</p></li><li><p>策略是RL问题的终极目标</p></li><li><p>如果策略的概率分布输出的是独立的，那么称为确定性策略，否则为随机策略。</p></li></ul><p><strong>MDP与MRP的关系</strong></p><p>当给定一个MDP: $M=(S,A,P,R,\gamma)$ 和一个策略$\pi$，那么状态序列$S_1,S_2,\cdots$  是一个马尔科夫过程$<s,p^{\pi}>$ ；同样，状态和奖励序列$S_1,R_2,S_2,R_3,S_3\cdots$   是一个马尔科夫奖励过程$<s,p^{\pi},r^{\pi},\gamma>$  ，并且在这个奖励函数和转移概率如下中满足下面两个方程：</s,p^{\pi},r^{\pi},\gamma></s,p^{\pi}></p><script type="math/tex; mode=display">\mathcal { P } _ { s , s ^ { \prime } } ^ { \pi } = \sum _ { a \in \mathcal { A } } \pi ( a | s ) \mathcal { P } _ { s s ^ { \prime } } ^ { a }</script><script type="math/tex; mode=display">\mathcal { R } _ { s } ^ { \pi } = \sum _ { a \in \mathcal { A } } \pi ( a | s ) \mathcal { R } _ { s } ^ { a }</script><p>在执行策略 $\pi$  时，状态从 $s$ 转移至 $s’$ 的概率等于一系列概率的和。因为到状态$s’$一定要做一个动作同时又跳转到了$s’$，所以这整个事件发生的概率就是在$s$状态执行了$a$动作的概率 乘 执行这个动作$a$正好跳转到了$s’$的概率 之和。奖励函数同理</p><p>策略在MDP中的作用相当于agent可以在某一个状态时做出选择，进而有形成各种马尔科夫过程的可能，而且基于策略产生的每一个马尔科夫过程是一个马尔科夫奖励过程，各过程之间的差别是不同的选择产生了不同的后续状态以及对应的不同的奖励。</p><h3 id="基于策略π的价值函数"><a href="#基于策略π的价值函数" class="headerlink" title="基于策略π的价值函数"></a>基于策略π的价值函数</h3><ul><li><strong>状态价值函数$v_\pi(s)$</strong>  ，表示从状态$s$开始，<strong>遵循当前策略</strong>时所获得的收获的期望；或者说在执行当前策略 $\pi$ 时，衡量个体处在状态 $s$ 时的价值大小。数学表示如下：</li></ul><script type="math/tex; mode=display">v _ { \pi } ( s ) = \mathbb { E } _ { \pi } \left[ G _ { t } | S _ { t } = s \right]</script><ul><li><strong>行为价值函数$q_\pi(s,a)$</strong>，表示在执行策略 $\pi$ 时，对当前状态 $s$ 执行某一具体行为 $a$ 所能的到的收获的期望；或者说在遵循当前策略π时，衡量对当前状态执行行为a的价值大小。行为价值函数一般都是与某一特定的状态相对应的，更精细的描述是<strong>状态行为对</strong>价值函数。行为价值函数的公式描述如下：<script type="math/tex; mode=display">q _ { \pi } ( s , a ) = \mathbb { E } _ { \pi } \left[ G _ { t } | S _ { t } = s , A _ { t } = a \right]</script><img alt="MDP_example" data-src="//orangesching.github.io/2019/11/22/算法/机器学习/强化学习/强化学习基础2——强化学习问题描述/MDP_example2.png" class="lazyload"></li></ul><p><strong>注:MDPs 中，任何不说明策略π 的情况下，讨论值函数都是在耍流氓！</strong></p><ul><li><p><strong>$v <em> { \pi } ( s ) $和的$q </em> { \pi } ( s , a ) $关系</strong></p><p><img alt="MDP_relation" data-src="//orangesching.github.io/2019/11/22/算法/机器学习/强化学习/强化学习基础2——强化学习问题描述/MDP_relation.png" class="lazyload"></p><p>上图中，空心较大圆圈表示状态，黑色实心小圆表示的是动作本身，连接状态和动作的线条仅仅把该状态以及该状态下可以采取的行为关联起来。可以看出，在遵循策略π时，状态s的价值体现为在该状态下遵循某一策略而采取所有可能行为的价值按行为发生概率的乘积求和。</p><script type="math/tex; mode=display">v _ { \pi } ( s ) = \sum _ { a \in A } \pi ( a | s ) q _ { \pi } ( s , a )</script></li></ul><p><img alt="MDP_relation" data-src="//orangesching.github.io/2019/11/22/算法/机器学习/强化学习/强化学习基础2——强化学习问题描述/MDP_relation2.png" class="lazyload"></p><p>  类似的，一个行为价值函数也可以表示成状态价值函数的形式：</p><script type="math/tex; mode=display">q _ { \pi } ( s , a ) = \mathcal { R } _ { s } ^ { a } + \gamma \sum _ { s ^ { \prime } \in \mathcal { S } } \mathcal { P } _ { s s ^ { \prime } } ^ { a } v _ { \pi } \left( s ^ { \prime } \right)</script><p>  它表明，一个某一个状态下采取一个行为的价值，可以分为两部分：其一是离开这个状态的价值，其二是所有进入新的状态的价值于其转移概率乘积的和。</p><p>  如果组合起来，可以得到下面的结果：</p><script type="math/tex; mode=display">v _ { \pi } ( s ) = \sum _ { a \in \mathcal { A } } \pi ( a | s ) \left( \mathcal { R } _ { s } ^ { a } + \gamma \sum _ { s ^ { \prime } \in \mathcal { S } } \mathcal { P } _ { s s ^ { \prime } } ^ { a } v _ { \pi } \left( s ^ { \prime } \right) \right)</script><p><img alt="MDP_relation" data-src="//orangesching.github.io/2019/11/22/算法/机器学习/强化学习/强化学习基础2——强化学习问题描述/MDP_relation3.png" class="lazyload"></p><p>  也可以得到下面的结果：</p><script type="math/tex; mode=display">q _ { \pi } ( s , a ) = \mathcal { R } _ { s } ^ { a } + \gamma \sum _ { s ^ { \prime } \in \mathcal { S } } \mathcal { P } _ { s s ^ { \prime } } ^ { a } \sum _ { a ^ { \prime } \in \mathcal { A } } \pi \left( a ^ { \prime } | s ^ { \prime } \right) q _ { \pi } \left( s ^ { \prime } , a ^ { \prime } \right)</script><p><img alt="MDP_relation" data-src="//orangesching.github.io/2019/11/22/算法/机器学习/强化学习/强化学习基础2——强化学习问题描述/MDP_relation4.png" class="lazyload"></p><p>  例：<br>  下图解释了红色空心圆圈状态的状态价值是如何计算的，遵循的策略随机策略，即所有可能的行为有相同的几率被选择执行。</p><p><img alt="MDP_relation" data-src="//orangesching.github.io/2019/11/22/算法/机器学习/强化学习/强化学习基础2——强化学习问题描述/MDP_relation5.png" class="lazyload"></p><h2 id="价值函数的推导-1"><a href="#价值函数的推导-1" class="headerlink" title="价值函数的推导"></a>价值函数的推导</h2><h3 id="Bellman期望方程"><a href="#Bellman期望方程" class="headerlink" title="Bellman期望方程"></a>Bellman期望方程</h3><p>和 MRP 相似，MDPs 中的值函数也能分解成瞬时奖励和后继状态的值函数两部分：</p><script type="math/tex; mode=display">v _ { \pi } ( s ) = \mathbb { E } _ { \pi } \left[ R _ { t + 1 } + \gamma v _ { \pi } \left( S _ { t + 1 } \right) | S _ { t } = s \right]</script><script type="math/tex; mode=display">q _ { \pi } ( s , a ) = \mathbb { E } _ { \pi } \left[ R _ { t + 1 } + \gamma q _ { \pi } \left( S _ { t + 1 } , A _ { t + 1 } \right) | S _ { t } = s , A _ { t } = a \right]</script><h3 id="Bellman期望方程矩阵形式"><a href="#Bellman期望方程矩阵形式" class="headerlink" title="Bellman期望方程矩阵形式"></a>Bellman期望方程矩阵形式</h3><script type="math/tex; mode=display">v _ { \pi } = \mathcal { R } ^ { \pi } + \gamma \mathcal { P } ^ { \pi } v _ { \pi }</script><script type="math/tex; mode=display">v _ { \pi } = \left( l - \gamma \mathcal { P } ^ { \pi } \right) ^ { - 1 } \mathcal { R } ^ { \pi }</script><h2 id="优化问题"><a href="#优化问题" class="headerlink" title="优化问题"></a>优化问题</h2><p>之前值函数，以及贝尔曼期望方程针对的都是给定策略 $\pi$  的情况，是一个评价的问题（评价策略 $\pi$ 的好坏）。<br>现在来讨论强化学习中的优化问题，即找出最好的策略。</p><h3 id="最优价值函数"><a href="#最优价值函数" class="headerlink" title="最优价值函数"></a>最优价值函数</h3><p>最优值函数指的是在所有策略中的值函数最大值，其中包括最优 V 函 数和最优 Q 函数</p><ul><li><p>最优状态价值函数 $v_{*}(s)$  指的是在从所有策略产生的状态价值函数中，选取使状态 $s$ 价值最大的函数：</p><script type="math/tex; mode=display">{ v _ { * } ( s ) = \max _ { \pi } v _ { \pi } ( s ) }</script></li><li><p>最优行为价值函数 $q_*(s,a)$ 指的是从所有策略产生的行为价值函数中，选取是状态行为对  $<s,a>$  价值最大的函数：</s,a></p><script type="math/tex; mode=display">{ q _ { * } ( s , a ) = \max q _ { \pi } ( s , a ) }</script><p>最优价值函数明确了MDP的最优可能表现，当我们知道了最优价值函数，也就知道了每个状态的最优价值，这时便认为这个MDP获得了解决。</p></li><li><p>例：</p><p>学生MDP问题的最优状态价值</p><p><img alt="MDP_max" data-src="//orangesching.github.io/2019/11/22/算法/机器学习/强化学习/强化学习基础2——强化学习问题描述/MDP_max1.png" class="lazyload"></p><p>学生MDP问题的最优行为价值</p><p><img alt="MDP_max" data-src="//orangesching.github.io/2019/11/22/算法/机器学习/强化学习/强化学习基础2——强化学习问题描述/MDP_max2.png" class="lazyload"><br>注：youtube留言认为Pub行为对应的价值是+9.4而不是+8.4</p></li></ul><h3 id="最优策略"><a href="#最优策略" class="headerlink" title="最优策略"></a>最优策略</h3><ul><li><p><strong>定义</strong></p><p>当对于任何状态 $s$，遵循策略π的价值不小于遵循策略 $\pi’$ 下的价值，则策略 $\pi$ 优于策略 $\pi’$：</p><script type="math/tex; mode=display">\pi \geq \pi ^ { \prime } \text { if } v _ { \pi } ( s ) \geq v _ { \pi ^ { \prime } } ( s ) , \forall s</script><blockquote><p><strong>定理</strong><br>对于任何MDP，下面几点成立：<br>1.存在一个最优策略，比任何其他策略更好或至少相等；<br>2.所有的最优策略有相同的状态价值函数；<br>3.所有的最优策略具有相同的行为价值函数。</p></blockquote></li><li><p><strong>寻找最优策略</strong></p><p>可以通过最大化最优行为价值函数来找到最优策略：</p><script type="math/tex; mode=display">\pi _ { * } ( a | s ) = \left\{ \begin{array} { l l } { 1 } & { \text { if } a = \underset { a \in \mathcal { A } } { \operatorname { argmax } } q _ { * } ( s , a ) } \\ { 0 } & { \text { otherwise } } \end{array} \right.</script><p>对于任何MDP问题，总存在一个确定性的最优策略；同时如果我们知道最优行为价值函数，则表明我们找到了最优策略。</p></li><li><p><strong>学生MDP最优策略示例</strong></p><p>红色箭头表示的行为表示最优策略</p><p><img alt="MDP_max" data-src="//orangesching.github.io/2019/11/22/算法/机器学习/强化学习/强化学习基础2——强化学习问题描述/MDP_max3.png" class="lazyload"></p></li></ul><h3 id="Bellman最优方程"><a href="#Bellman最优方程" class="headerlink" title="Bellman最优方程"></a>Bellman最优方程</h3><ul><li><p>定义</p><p>针对 $v_*$ ，一个状态的最优价值等于从该状态出发采取的所有行为产生的行为价值中最大的那个行为价值：</p><script type="math/tex; mode=display">v _ { * } ( s ) = \max _ { a } q _ { * } ( s , a )</script><p><img alt="MDP_max" data-src="//orangesching.github.io/2019/11/22/算法/机器学习/强化学习/强化学习基础2——强化学习问题描述/MDP_max4.png" class="lazyload"></p><p>针对 $q _ { * }$ ，在某个状态$s$下，采取某个行为的最优价值由2部分组成，一部分是离开状态 s 的即刻奖励，另一部分则是所有能到达的状态 s’ 的最优状态价值按出现概率求和：</p><script type="math/tex; mode=display">q _ { * } ( s , a ) = \mathcal { R } _ { s } ^ { a } + \gamma \sum _ { s ^ { \prime } \in \mathcal { S } } \mathcal { P } _ { s s ^ { \prime } } ^ { a } v _ { * } \left( s ^ { \prime } \right)</script><p><img alt="MDP_max" data-src="//orangesching.github.io/2019/11/22/算法/机器学习/强化学习/强化学习基础2——强化学习问题描述/MDP_max5.png" class="lazyload"></p></li></ul><p>  组合起来，针对 $v _ { * }$ ，有：</p><script type="math/tex; mode=display">  v _ { * } ( s ) = \max _ { a } \mathcal { R } _ { s } ^ { a } + \gamma \sum _ { s ^ { \prime } \in \mathcal { S } } \mathcal { P } _ { s s ^ { \prime } } ^ { a } v _ { * } \left( s ^ { \prime } \right)</script><p>  <img alt="MDP_max" data-src="//orangesching.github.io/2019/11/22/算法/机器学习/强化学习/强化学习基础2——强化学习问题描述/MDP_max6.png" class="lazyload"></p><p>  针对 $q _ { * }$ ，有：</p><script type="math/tex; mode=display">  q _ { * } ( s , a ) = \mathcal { R } _ { s } ^ { a } + \gamma \sum _ { s ^ { \prime } \in \mathcal { S } } \mathcal { P } _ { s s ^ { \prime } } ^ { a } \max _ { a ^ { \prime } } q _ { * } \left( s ^ { \prime } , a ^ { \prime } \right)</script><p>  <img alt="MDP_max" data-src="//orangesching.github.io/2019/11/22/算法/机器学习/强化学习/强化学习基础2——强化学习问题描述/MDP_max7.png" class="lazyload"></p><ul><li><p><strong>Bellman最优方程学生MDP示例</strong></p><p><img alt="MDP_max" data-src="//orangesching.github.io/2019/11/22/算法/机器学习/强化学习/强化学习基础2——强化学习问题描述/MDP_max8.png" class="lazyload"></p></li><li><p><strong>求解Bellman最优方程</strong></p><p>对于Bellman期望方程，可以使用矩阵求逆来求解</p><p>但Bellman最优方程是非线性的，没有固定的解决方案，通过一些迭代方法来解决：价值迭代、策略迭代、Q学习、Sarsa等。后续会逐步讲解展开。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 机器学习 </category>
          
          <category> 强化学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 强化学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>强化学习基础1——强化学习问题提出</title>
      <link href="/2019/11/21/%E7%AE%97%E6%B3%95/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%801%E2%80%94%E2%80%94%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E9%97%AE%E9%A2%98%E6%8F%90%E5%87%BA/"/>
      <url>/2019/11/21/%E7%AE%97%E6%B3%95/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%801%E2%80%94%E2%80%94%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E9%97%AE%E9%A2%98%E6%8F%90%E5%87%BA/</url>
      
        <content type="html"><![CDATA[<p>强化学习问题可以从智能体和环境两方面来描述。</p><p><img alt="强化学习问题" data-src="//orangesching.github.io/2019/11/21/算法/机器学习/强化学习/强化学习基础1——强化学习问题提出/1.png" class="lazyload"></p><p>在 $t$ 时刻，智能体和环境分别可以：</p><div class="table-container"><table><thead><tr><th>智能体</th><th>环境</th></tr></thead><tbody><tr><td>有一个对于环境的观察评估$O<em>t$<br>做出一个行为$A_t$<br><br>从环境得到一个奖励信号 $R</em>{t+1}$</td><td><br>接收个体的动作 $A<em>t$，更新环境信息<br>给个体一个奖励信号 $R</em>{t+1}$<br><br>同时使得个体可以得到下一个观测$O_{t+1}$<br></td></tr></tbody></table></div><h1 id="序列决策问题-Sequential-Decision-Making"><a href="#序列决策问题-Sequential-Decision-Making" class="headerlink" title="序列决策问题 Sequential Decision Making"></a>序列决策问题 Sequential Decision Making</h1><p>强化学习解决的是序列决策问题，即环境状态-&gt;行动-&gt;新的环境状态-&gt;下一步行动的决策</p><p>决策的目标：选择一定的行为系列以<strong>最大化未来的总体奖励</strong>，这些行为可能是一个长期的序列，奖励可能而且通常是延迟的，有时候宁愿牺牲即时（短期）的奖励以获取更多的长期奖励</p><p>比如：下棋时，没有到最后一刻都不知道棋局结果，而要决策的是一系列下棋的位置</p><h1 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h1><h2 id="环境-Environment"><a href="#环境-Environment" class="headerlink" title="环境 Environment"></a>环境 Environment</h2><h3 id="奖励-Reward"><a href="#奖励-Reward" class="headerlink" title="奖励 Reward"></a>奖励 Reward</h3><p>$R_t$ 是信号的反馈，是一个标量，它反映智能体在 $t$ 时刻做得怎么样。个体的工作就是最大化累计奖励。<br>比如：Flappy bird可把奖励定义为当前做完该行动的得分</p><blockquote><p>强化学习主要基于这样的”奖励假设”：所有问题解决的目标都可以被描述成最大化累积奖励。</p></blockquote><h2 id="环境与智能体交互"><a href="#环境与智能体交互" class="headerlink" title="环境与智能体交互"></a>环境与智能体交互</h2><h3 id="历史-History"><a href="#历史-History" class="headerlink" title="历史 History"></a>历史 History</h3><p>历史是观测、行为、奖励的序列： $H<em>{t}=O</em>{1}, A<em>{1}, R</em>{1}, \ldots, O<em>{t-1}, A</em>{t-1}, R<em>{t-1}, O</em>{t}, A<em>{t}, R</em>{t}$</p><h3 id="状态-State（重要）"><a href="#状态-State（重要）" class="headerlink" title="状态 State（重要）"></a>状态 State（重要）</h3><p>状态是所有决定将来行为的已有的信息，是对历史信息的总结，通常我们研究的是State而不是HIstory， 是关于历史的一个函数 $S<em>{t}=f\left(H</em>{t}\right)$</p><p>状态只有经过最后一次观测才能是合理有效的</p><p>状态的三种定义：</p><ol><li><p>环境状态</p><p>是环境的私有呈现，真实环境抽象的某些数字集合，理解真实环境。包括环境用来决定下一个观测/奖励的所有数据，通常对个体并不完全可见，也就是个体有时候并不知道环境状态的所有细节。即使有时候环境状态 $S_{t}^{e}$ 对个体可以是完全可见的，这些信息也可能包含着一些无关信息。</p></li><li><p>智能体状态</p><p>是智能体的内部呈现，包括智能体可以使用的、决定未来动作的所有信息。智能体状态是强化学习算法可以利用的信息，它可以是历史的一个函数：$S<em>{t}^{a}=f\left(H</em>{t}\right)$</p></li><li><p>信息状态（用数学语言对状态进行定义）</p><p>包括历史上所有<strong>有用</strong>的信息，又称Markov状态</p><p>在我们使用状态表示法的时候，这些状态包含history的全部有用信息，我们能做的就是定义一个状态表示，使状态具有马尔可夫性</p></li></ol><blockquote><p>马尔可夫性</p><p>指系统的下一个状态$s<em>{t+1}$仅与当前状态$s_t$有关，与过去没多大关系）。$状态s_t是马尔科夫的\Leftrightarrow P[s</em>{t+1} | s<em>t]=P[s</em>{t+1}|s_1,…,s2]$</p><p>即$H_{1:t}$</p></blockquote><p>也就是说，如果信息状态是可知的，那么所有历史信息都可以丢掉，仅需要$t$时刻的信息状态就可以了。例如：环境状态是Markov的，因为环境状态是环境包含了环境决定下一个观测/奖励的所有信息；同样，（完整的）历史$H_t$也是马尔可夫的，即</p><script type="math/tex; mode=display">H_t \to S_t \to H_{t+1: \infty}</script><p>例：</p><p>有如下三个针对老鼠的事件序列，其中前两个最后的事件分别是老鼠遭电击和获得一块奶酪，现在请分析比较这三个事件序列的特点，分析第第三个事件序列中，老鼠是获得电击还是奶酪？</p><p><img alt="例" data-src="//orangesching.github.io/2019/11/21/算法/机器学习/强化学习/强化学习基础1——强化学习问题提出/例.png" class="lazyload"></p><ul><li>假如个体状态 = 序列中的后三个事件（不包括电击、获得奶酪，下同），事件序列3的结果会是什么？（电击）</li><li>假如个体状态 = 亮灯、响铃和拉电闸各自事件发生的次数，那么事件序列3的结果又是什么？（奶酪）</li><li>假如个体状态 = 完整的事件序列，那结果又是什么？（未知）</li></ul><p>状态表示某种程度上决定了未来会发生什么。我们可以使用各种各样不同的方式来表征我们的状态</p><ul><li><strong>完全可观测的环境 Fully Observable Environments</strong></li></ul><p>智能体能够直接观测到环境状态。在这种条件下:</p><script type="math/tex; mode=display">智能体对环境的观测O_t = 个体状态S_t^a = 环境状态S_t^e</script><p>这种问题是一个<strong>马尔可夫决策过程</strong>（Markov Decision Process， MDP）</p><ul><li><strong>部分可观测的环境 Partially Observable Environments</strong></li></ul><p>智能体间接观测环境。几个例子：</p><ol><li>一个可拍照的机器人个体对于其周围环境的观测并不能说明其绝度位置，它必须自己去估计自己的绝对位置，而绝对位置则是非常重要的环境状态特征之一；</li><li>一个交易员只能看到当前的交易价格；</li><li>一个扑克牌玩家只能看到自己的牌和其他已经出过的牌，而不知道整个环境（包括对手的牌）状态。</li></ol><p>在这种条件下： </p><script type="math/tex; mode=display">智能体状态 ≠ 环境状态</script><p>这种问题是一个<strong>部分可观测马儿可夫决策过程</strong>。智能体必须构建它自己的状态呈现形式。</p><p>比如：记住完整的历史，整个动作序列是一个状态：$S_t^a = H_t$ 。这种方法比较原始、幼稚。</p><p>还有其他办法，例如 ：</p><ol><li><p>Beliefs of environment state：此时虽然智能体不知道环境状态到底是什么样，但智能体可以利用已有经验（数据），用各种个体已知状态的概率分布作为当前时刻的智能体状态的呈现：</p><script type="math/tex; mode=display">S_{t}^{a}=\left(\mathbb{P}\left[S_{t}^{e}=s^{1}\right], \ldots, \mathbb{P}\left[S_{t}^{e}=s^{n}\right]\right)</script></li><li><p>Recurrent neural network：不需要知道概率，只需要将最近的智能体状态与最近的观测结合起来，送入循环神经网络(RNN)中得到一个当前智能体状态的呈现：</p></li></ol><script type="math/tex; mode=display">S_{t}^{a}=\sigma\left(S_{t-1}^{a} W_{s}+O_{t} W_{o}\right)</script><h2 id="智能体-Agent"><a href="#智能体-Agent" class="headerlink" title="智能体 Agent"></a>智能体 Agent</h2><p>智能体可以由以下三个组成部分中的一个或多个组成：</p><h3 id="策略-Policy"><a href="#策略-Policy" class="headerlink" title="策略 Policy"></a>策略 Policy</h3><p>策略是决定智能体行为的机制。是从状态到行为的一个映射，可以是确定性的$a = \pi(s)$，也可以是不确定性的$\pi(a|s)=P[A=a|S=s]$。</p><p>比如：在看电视这个状态，做作业的概率是0.3，出去玩的概率是0.7。就是一个策略</p><h3 id="价值函数-Value-Function"><a href="#价值函数-Value-Function" class="headerlink" title="价值函数 Value Function"></a>价值函数 Value Function</h3><p>是一个未来奖励的预测，用来评价当前状态的好坏程度。当面对两个不同的状态时，智能体可以用一个Value值来评估这两个状态可能获得的最终奖励区别，继而指导选择不同的行为，即制定不同的策略。同时，一个价值函数是基于某一个特定策略的，不同的策略下同一状态的价值并不相同。</p><h3 id="模型-Model"><a href="#模型-Model" class="headerlink" title="模型 Model"></a>模型 Model</h3><p>智能体对环境的一个建模，它体现了个体是如何思考环境运行机制的（如何理解环境，模拟环境），个体希望模型能模拟环境与个体的交互机制。</p><p>模型至少要解决两个问题：</p><p>一是状态转化概率，即预测下一个可能状态发生的概率</p><script type="math/tex; mode=display">\mathcal{P}_{s s^{\prime}}^{a}=\mathbb{P}\left[S_{t+1}=s^{\prime} | S_{t}=s, A_{t}=a\right]</script><p>即状态是$s$且执行了$a$操作的条件下下一个状态是$s^{\prime}$的概率</p><p>另一项工作是预测可能获得的即时奖励</p><script type="math/tex; mode=display">\mathcal{R}_{s}^{a}=\mathbb{E}\left[R_{t+1} | S_{t}=s, A_{t}=a\right]</script><p>即到目前为止，出现了状态是$s$后执行了$a$操作的情况，所获得的平均奖励</p><blockquote><p>注意： </p><ol><li>模型并不是构建一个个体所必需的，很多强化学习算法中个体并不依赖模型。</li><li>模型仅针对个体而言，环境实际运行机制不称为模型，而称为环境动力学(dynamics of environment)，它能够明确确定个体下一个状态和所得的即时奖励。</li></ol></blockquote><p>例：<br>在 Flappy bird 这个游戏中，需要简单的点击操作来控制小鸟，躲过各种水管，飞的越远越好，因为飞的越远就能获得更高的积分奖励。</p><p>这就是一个典型的强化学习场景：</p><ul><li>小鸟角色——智能体</li><li>水管排布——环境</li><li>控制小鸟飞的更远——决策目标</li><li>$t$时刻水管的排布——环境的观察评估$O_t$</li><li>$t$小鸟飞——行动$A_t$</li><li>$t$时刻是否撞柱子——奖励信号 $R_t$</li></ul><blockquote><p>根据智能体的三个组成部分分类</p><p>是否有策略/价值函数</p><ul><li>Value Based<br>没有策略，靠价值函数选择，存储的是价值函数</li><li>policay Based<br>没有价值函数，靠策略选择，存储的是策略</li><li>Actor Critic<br>前面两者的结合，既有策略，也有价值函数</li></ul><p>是否有模型</p><ul><li>Model Free：没有模型，有策略或/和价值函数</li><li>Model Based：有模型，有策略或/和价值函数</li></ul></blockquote><h2 id="学习和规划-Learning-amp-Planning"><a href="#学习和规划-Learning-amp-Planning" class="headerlink" title="学习和规划 Learning &amp; Planning"></a>学习和规划 Learning &amp; Planning</h2><ul><li>学习：环境初始时是未知的，个体不知道环境如何工作，个体通过与环境进行交互，逐渐改善其行为策略。</li><li>规划: 环境如何工作对于个体是已知或近似已知的，个体并不与环境发生实际的交互，而是利用其构建的模型进行计算，在此基础上改善其行为策略。</li></ul><p>一个常用的强化学习问题解决思路是，先学习环境如何工作，也就是了解环境工作的方式，即学习得到一个模型，然后利用这个模型进行规划。</p><h2 id="探索和利用-Exploration-amp-Exploitation"><a href="#探索和利用-Exploration-amp-Exploitation" class="headerlink" title="探索和利用 Exploration &amp; Exploitation"></a>探索和利用 Exploration &amp; Exploitation</h2><p>强化学习类似于一个试错的学习，个体需要从其与环境的交互中发现一个好的策略，同时又不至于在试错的过程中丢失太多的奖励。探索和利用是个体进行决策时需要平衡的两个方面。</p><p>一个形象的比方是，当你去一个餐馆吃饭，“探索”意味着你对尝试新餐厅感兴趣，很可能会去一家以前没有去过的新餐厅体验，“利用”则意味着你就在以往吃过的餐厅中挑一家比较喜欢的，而不去尝试以前没去过的餐厅。这两种做法通常是一对矛盾，但对解决强化学习问题又都非常重要。</p><p>其它一些例子，在线广告推广时，显示最受欢迎的广告和显示一个新的广告；油气开采时选择一个已知的最好的地点同在未知地点进行开采；玩游戏时选择一个你认为最好的方法同实验性的采取一个新的方法。</p><h2 id="预测和控制-Prediction-amp-Control"><a href="#预测和控制-Prediction-amp-Control" class="headerlink" title="预测和控制 Prediction &amp; Control"></a>预测和控制 Prediction &amp; Control</h2><p>在强化学习里，我们经常需要先解决关于预测（prediction）的问题，而后在此基础上解决关于控制（Control）的问题。</p><ul><li>预测：给定一个策略，评价未来。可以看成是求解在给定策略下的价值函数（value function）的过程。How well will I(an agent) do if I(the agent) follow a specific policy?</li><li>控制：找到一个好的策略来最大化未来的奖励。</li></ul><p>举了一个例子来说明预测和控制的区别。</p><p>预测：现在给出了从A到A’的奖励以及从B到B’的奖励，在“随机选择4个方向进行移动”的策略下，如何得知每一个位置的价值。</p><p><img alt="预测" data-src="//orangesching.github.io/2019/11/21/算法/机器学习/强化学习/强化学习基础1——强化学习问题提出/预测.png" class="lazyload"></p><p>控制：同样的条件，在所有可能的策略下最优的价值函数是什么？最优策略是什么？</p><p><img alt="控制" data-src="//orangesching.github.io/2019/11/21/算法/机器学习/强化学习/强化学习基础1——强化学习问题提出/控制.png" class="lazyload"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>强化学习解决的序列决策问题，智能体可由三个部分组成：策略、价值函数、模型。环境会响应智能体的行为，给予奖励。智能体和环境的交互过程中会产生由【观察，行为，奖励】构成的序列称为历史，智能体将历史概括为状态。当环境完全可观测时，观察值=个体状态=环境状态，为一个马尔可夫决策过程；当环境部分可观测时，观察值≠环境状态，需要构建自己状态的呈现方式（通过RNN等方式构建），为部分可观测马尔可夫决策过程</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 机器学习 </category>
          
          <category> 强化学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 强化学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>强化学习导论</title>
      <link href="/2019/11/08/%E7%AE%97%E6%B3%95/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%AE%BA/"/>
      <url>/2019/11/08/%E7%AE%97%E6%B3%95/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="强化学习是什么"><a href="#强化学习是什么" class="headerlink" title="强化学习是什么"></a>强化学习是什么</h1><p>强化学习(Reinforcement Learning, RL)是机器学习的一个重要分支：监督学习、无监督学习、强化学习，又称为增强学习，模拟的是人类的一种学习方式，在执行某个动作或决策后根据执行效果来获得奖励，通过不断与环境的交互进行学习，最终达到目标。即强调如何基于环境而行动，以取得最大化的预期利益。</p><p>其灵感来源于心理学中的行为主义理论，即有机体如何在环境给予的奖励或惩罚的刺激下，逐步形成对刺激的预期，产生能获得最大利益的习惯性行为。</p><p>主要包含四个元素，<strong>智能体（agent），状态，行动，奖励</strong>， 强化学习的目标就是获得最多的累计奖励 </p><blockquote><p>强化学习与监督学习、无监督学习的区别</p><p>强化学习不同于 <em>监督学习</em>。 监督学习是目前机器学习领域中研究最多的一种学习方式，它从知识渊博的教练所提供的有标记的训练集中学习。 每一个样例都是一种情况的描述，都带有标签，标签描述的是系统在该情况下的应该采取的正确动作，每一个样例用来识别这种情况应该属于哪一类。 这种学习的目的是让系统推断概括它应有的反馈机制，使它可以对未知样本作出正确回应。 这是一种重要的学习方式，但单凭它并不足以从交互中学习。 在交互问题中，找到期待的既正确又典型的样例通常都是不切实际的。 在一个未知的领域，若要使收益最大化，个体必须能够从自己的经验中学习。</p><p>强化学习也与机器学习研究人员所谓的 <em>无监督学习</em> 不同，后者通常是用于寻找隐藏在未标记数据集合中的结构。 监督学习和无监督学习这两个术语似乎对机器学习范式进行了详尽的分类，但事实却并非如此。 尽管人们可能会试图将强化学习视为一种无监督学习，因为它不依赖于正确行为的样例，但强化学习试图最大化奖励信号而不是试图找到隐藏的结构。 在个体的经验数据中揭示结构确实对强化学习特别有用，但是它本身并没有解决最大化奖励信号的强化学习问题。 因此，我们认为强化学习是除监督学习和无监督学习之外的第三种机器学习范式，也许还有其他范式。</p></blockquote><h1 id="强化学习的特点"><a href="#强化学习的特点" class="headerlink" title="强化学习的特点"></a>强化学习的特点</h1><p>强化学习是一种学习如何将状态映射到动作，以获得最大奖励的学习机制。 学习者不会被告知要采取哪些动作，而是必须通过尝试来发现哪些动作会产生最大的回报。 动作不仅可以影响直接奖励，还可以影响下一个状态，并通过下一个状态，影响到随后而来的奖励。 这两个特征 - <strong>试错法和延迟奖励</strong> - 是强化学习的两个最重要的可区别特征。 </p><ol><li>没有监督数据、只有奖励信号</li><li>奖励信号不一定是实时的，而很可能是延后的，有时甚至延后很多。</li><li>时间（序列）是一个重要因素</li><li>当前的行为影响后续接收到的数据</li></ol><h1 id="发展历程："><a href="#发展历程：" class="headerlink" title="发展历程："></a>发展历程：</h1><ul><li>1956年 Bellman提出了动态规划方法。</li><li>1977年 Werbos提出只适应动态规划算法。</li><li>1988年 sutton提出时间差分算法。</li><li>1992年 Watkins 提出Q-learning 算法。</li><li>1994年 rummery 提出Saras算法。</li><li>1996年 Bersekas提出解决随机过程中优化控制的神经动态规划方法。</li><li>2006年 Kocsis提出了置信上限树算法。</li><li>2009年 kewis提出反馈控制只适应动态规划算法。</li><li>2014年 silver提出确定性策略梯度（Policy Gradients）算法。</li><li>2015年 Google-deepmind 提出Deep-Q-Network算法。</li></ul><h1 id="强化学习的应用"><a href="#强化学习的应用" class="headerlink" title="强化学习的应用"></a>强化学习的应用</h1><p>直升机特技飞行、经典游戏、投资管理、发电站控制、让机器人模仿人类行走等</p><h1 id="强化学习解决什么问题"><a href="#强化学习解决什么问题" class="headerlink" title="强化学习解决什么问题"></a>强化学习解决什么问题</h1><p>强化学习试图解决决策优化的问题。即面对特定状态（State,S），采取什么行动方案（Action,A）， 通过选择一定的行动系列，使得未来的总体奖励最大（Reward,R）。比如：下棋、投资、课程安排、驾车</p><p>例：在 Flappy bird 这个游戏中，我们需要简单的点击操作来控制小鸟，躲过各种水管，飞的越远越好，因为飞的越远就能获得更高的积分奖励。面对特定的水管排布选择“飞”这个动作，通过选择一系列动作（如：飞|不飞|飞|飞）来使小鸟飞得更远获得更多的分</p><blockquote><p>强化学习的本质是在大空间中寻找最优解，是介于穷举和贪婪之间的一种探索机制，这种探索机制是学习得来的。<br>“介于穷举和贪婪之间”：不用穷举可以减少搜索量，提升速度；不用贪婪可以尽量避免局部最优解。因此可以说是在计算时间与全局最优之间的权衡。</p></blockquote><h1 id="强化学习算法分类"><a href="#强化学习算法分类" class="headerlink" title="强化学习算法分类"></a>强化学习算法分类</h1><h2 id="强化学习的几个元素的角度划分"><a href="#强化学习的几个元素的角度划分" class="headerlink" title="强化学习的几个元素的角度划分"></a>强化学习的几个元素的角度划分</h2><ul><li>Policy based, 关注点是找到最优策略</li><li>Value based, 关注点是找到最优奖励总和</li><li>Action based, 关注点是每一步的最优行动</li></ul><h2 id="其他角度划分"><a href="#其他角度划分" class="headerlink" title="其他角度划分"></a>其他角度划分</h2><ol><li>基于理不理解所处环境来进行分类：</li></ol><ul><li><p><strong>Model-free</strong>：环境给了我们什么就是什么. 我们就把这种方法叫做 model-free, 这里的 model 就是用模型来表示环境</p></li><li><p><strong>Model-based</strong>：那理解了环境也就是学会了用一个模型来代表环境, 所以这种就是 model-based 方法</p><p><img alt="Model-Based-RL" data-src="//orangesching.github.io/2019/11/08/算法/机器学习/强化学习/强化学习导论/Model-Based-RL.png" class="lazyload"><img alt="Model-Free-RL" data-src="//orangesching.github.io/2019/11/08/算法/机器学习/强化学习/强化学习导论/Model-Free-RL.png" class="lazyload"></p></li></ul><ol><li>基于是否直接输出各个动作概率进行分类：</li></ol><ul><li><p><strong>Policy based</strong>：通过感官分析所处的环境, 直接输出下一步要采取的各种动作的概率, 然后根据概率采取行动。</p></li><li><p><strong>Value based</strong>：输出的是所有动作的价值, 根据最高价值来选动作，这类方法不能选取连续的动作。</p><p><img alt="Value-Based-RL" data-src="//orangesching.github.io/2019/11/08/算法/机器学习/强化学习/强化学习导论/Value-Based-RL.png" class="lazyload"><img alt="Policy-Based-RL" data-src="//orangesching.github.io/2019/11/08/算法/机器学习/强化学习/强化学习导论/Policy-Based-RL.png" class="lazyload"></p></li></ul><ol><li>是否单步更新分类：</li></ol><ul><li><p><strong>Monte-carlo update</strong>：游戏开始后, 要等待游戏结束, 然后再总结这一回合中的所有转折点, 再更新行为准则。</p></li><li><p><strong>Temporal-difference update</strong>：在游戏进行中每一步都在更新, 不用等待游戏的结束, 这样就能边玩边学习了。</p><p> <img alt="Monte-Carlo-update" data-src="//orangesching.github.io/2019/11/08/算法/机器学习/强化学习/强化学习导论/Monte-Carlo-update.png" class="lazyload"><img alt="Temporal-Difference-update" data-src="//orangesching.github.io/2019/11/08/算法/机器学习/强化学习/强化学习导论/Temporal-Difference-update.png" class="lazyload"></p><p> 基于是否在线学习分类：</p></li><li><p><strong>On-policy</strong>：必须本人在场, 并且一定是本人边玩边学习。</p></li><li><p><strong>Off-policy</strong>：可以选择自己玩, 也可以选择看着别人玩, 通过看别人玩来学习别人的行为准则。</p><p><img alt="On-Policy" data-src="//orangesching.github.io/2019/11/08/算法/机器学习/强化学习/强化学习导论/On-Policy.png" class="lazyload"><img alt="Off-Policy" data-src="//orangesching.github.io/2019/11/08/算法/机器学习/强化学习/强化学习导论/Off-Policy.png" class="lazyload"></p></li></ul><h1 id="代表性算法"><a href="#代表性算法" class="headerlink" title="代表性算法"></a>代表性算法</h1><h2 id="Q-learning"><a href="#Q-learning" class="headerlink" title="Q-learning"></a>Q-learning</h2><p>Q-learning定义动作效用函数（action-utility function），用于判断在特定状态下采取某个动作的优劣，可以将之理解为智能体（Agent）的大脑。</p><p>Q-learning 只利用了下一步信息, 让系统按照策略指引进行探索，在探索每一步都使用更新公式进行状态价值的更新</p><h2 id="Sarsa"><a href="#Sarsa" class="headerlink" title="Sarsa"></a>Sarsa</h2><p>同Q-learning只是更新公式不同</p><h2 id="DQN"><a href="#DQN" class="headerlink" title="DQN"></a>DQN</h2><p>DQN（Deep Q Network）是一种融合了神经网络和Q learning的方法.</p><p>有些问题太复杂，Q表无法存储，即使可以存储，搜索也很麻烦。故而，将Q表用神经网络进行替代。</p><h2 id="Policy-Gradients"><a href="#Policy-Gradients" class="headerlink" title="Policy Gradients"></a>Policy Gradients</h2><h2 id="Actor-critic"><a href="#Actor-critic" class="headerlink" title="Actor-critic"></a>Actor-critic</h2><p> 算法分为两个部分：Actor 和 Critic。Actor 更新概率， Critic 更新价值。Critic 就可以用之前介绍的 SARSA 或者 Q Learning 算法。 是基于价值和基于概率的结合体</p><h1 id="如何用强化算法解决问题"><a href="#如何用强化算法解决问题" class="headerlink" title="如何用强化算法解决问题"></a>如何用强化算法解决问题</h1><ol><li><p>将实际问题建模成马尔可夫决策过程，抽象出五元组（状态集、动作集、状态转移概率、奖励函数、折扣因子），  其中奖励与实际目标相关联</p></li><li><p>根据动作是否连续选择对应的算法 </p><p>​    动作离散：DQN   </p><p>​    动作连续：Policy Gradients，Actor-Critic，DDPG</p></li><li><p>根据算法写代码</p></li></ol><h1 id="强化学习资料"><a href="#强化学习资料" class="headerlink" title="强化学习资料"></a>强化学习资料</h1><p>强化学习课程</p><blockquote><p>【推荐】David Silver 的 UCL 强化学习课程：<a href="http://www0.cs.ucl.ac.uk/staff/d.silver/web/Teaching.html" target="_blank" rel="noopener">http://www0.cs.ucl.ac.uk/staff/d.silver/web/Teaching.html</a><br>DeepMind 和 UCL 的深度学习和强化学习课程：<a href="https://www.youtube.com/playlist?list=PLqYmG7hTraZDNJre23vqCGIVpfZ_K2RZs" target="_blank" rel="noopener">https://www.youtube.com/playlist?list=PLqYmG7hTraZDNJre23vqCGIVpfZ_K2RZs</a><br>Sergey Levine 教授的深度强化学习课程：<a href="http://rail.eecs.berkeley.edu/deeprlcourse/" target="_blank" rel="noopener">http://rail.eecs.berkeley.edu/deeprlcourse/</a><br>OpenAI 的 Spinning Up in Deep RL：<a href="https://blog.openai.com/spinning-up-in-deep-rl/" target="_blank" rel="noopener">https://blog.openai.com/spinning-up-in-deep-rl/</a></p></blockquote><p>书籍</p><blockquote><p>Sutton 和 Barto 的强化学习著作《Reinforcement learning: an introduction》：<a href="http://incompleteideas.net/book/the-book-2nd.html" target="_blank" rel="noopener">http://incompleteideas.net/book/the-book-2nd.html</a><br>一本有关深度强化学习的书籍草稿：<a href="https://arxiv.org/abs/1810.06339" target="_blank" rel="noopener">https://arxiv.org/abs/1810.06339</a><br>Richard Sutton 和 Andrew Barto的《强化学习：简介（第二版）》：<a href="http://incompleteideas.net/book/RLbook2018.pdf" target="_blank" rel="noopener">http://incompleteideas.net/book/RLbook2018.pdf</a><br> 郭宪博士2017年写的《深入浅出强化学习：原理入门》，入门级别的书，语言通俗易懂</p></blockquote><p>学习路线</p><p> <a href="https://github.com/dennybritz/reinforcement-learning" target="_blank" rel="noopener">https://github.com/dennybritz/reinforcement-learning</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 机器学习 </category>
          
          <category> 强化学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 强化学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo常用命令</title>
      <link href="/2019/10/04/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/Hexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2019/10/04/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/Hexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>详细使用文档参见 <a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">hexo</a> 官网</p><p>[TOC]</p><h1 id="新建网站-init"><a href="#新建网站-init" class="headerlink" title="新建网站 init"></a>新建网站 init</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init [路径]</span><br></pre></td></tr></table></figure><p>新建一个网站。如果没有设置 <code>folder</code> ，Hexo 默认在当前文件夹建立网站。</p><h1 id="新建文章-new"><a href="#新建文章-new" class="headerlink" title="新建文章 new"></a>新建文章 new</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new [布局][参数] &quot;文章名字&quot;</span><br></pre></td></tr></table></figure><p>新建一篇文章。如果没有设置 <code>layout</code> 的话，默认使用 <a href="https://hexo.io/zh-cn/docs/configuration" target="_blank" rel="noopener">_config.yml</a> 中的 <code>default_layout</code> 参数代替</p><h1 id="生成静态网站-generate"><a href="#生成静态网站-generate" class="headerlink" title="生成静态网站 generate"></a>生成静态网站 generate</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>生成静态文件。</p><div class="table-container"><table><thead><tr><th style="text-align:left">选项</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>-d</code>, <code>--deploy</code></td><td style="text-align:left">文件生成后立即部署网站</td></tr><tr><td style="text-align:left"><code>-w</code>, <code>--watch</code></td><td style="text-align:left">监视文件变动</td></tr><tr><td style="text-align:left"><code>-b</code>, <code>--bail</code></td><td style="text-align:left">生成过程中如果发生任何未处理的异常则抛出异常</td></tr><tr><td style="text-align:left"><code>-f</code>, <code>--force</code></td><td style="text-align:left">强制重新生成文件 Hexo 引入了差分机制，如果 <code>public</code> 目录存在，那么 <code>hexo g</code> 只会重新生成改动的文件。 使用该参数的效果接近 <code>hexo clean &amp;&amp; hexo generate</code></td></tr></tbody></table></div><p>该命令可以简写为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g</span><br></pre></td></tr></table></figure><h1 id="发布草稿publish"><a href="#发布草稿publish" class="headerlink" title="发布草稿publish"></a>发布草稿publish</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo publish [layout] &lt;filename&gt;</span><br></pre></td></tr></table></figure><p>发表草稿。</p><h1 id="启动服务器-server"><a href="#启动服务器-server" class="headerlink" title="启动服务器 server"></a>启动服务器 server</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>启动服务器。默认情况下，访问网址为： <code>http://localhost:4000/</code>。</p><div class="table-container"><table><thead><tr><th style="text-align:left">选项</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>-p</code>, <code>--port</code></td><td style="text-align:left">重设端口</td></tr><tr><td style="text-align:left"><code>-s</code>, <code>--static</code></td><td style="text-align:left">只使用静态文件</td></tr><tr><td style="text-align:left"><code>-l</code>, <code>--log</code></td><td style="text-align:left">启动日记记录，使用覆盖记录格式</td></tr></tbody></table></div><h1 id="部署网站deploy"><a href="#部署网站deploy" class="headerlink" title="部署网站deploy"></a>部署网站deploy</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>部署网站。</p><div class="table-container"><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>-g</code>, <code>--generate</code></td><td style="text-align:left">部署之前预先生成静态文件</td></tr></tbody></table></div><p>该命令可以简写为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo d</span><br></pre></td></tr></table></figure><h1 id="清除缓存-clean"><a href="#清除缓存-clean" class="headerlink" title="清除缓存 clean"></a>清除缓存 clean</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br></pre></td></tr></table></figure><p>清除缓存文件 (<code>db.json</code>) 和已生成的静态文件 (<code>public</code>)。</p><p>在某些情况（尤其是更换主题后），如果发现对站点的更改无论如何也不生效，可能需要运行该命令。</p><h1 id="查看版本-version"><a href="#查看版本-version" class="headerlink" title="查看版本 version"></a>查看版本 version</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo version</span><br></pre></td></tr></table></figure><p>显示 Hexo 版本。</p><h1 id="各种模式"><a href="#各种模式" class="headerlink" title="各种模式"></a>各种模式</h1><h2 id="安全模式"><a href="#安全模式" class="headerlink" title="安全模式"></a>安全模式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo --safe</span><br></pre></td></tr></table></figure><p>在安全模式下，不会载入插件和脚本。当您在安装新插件遭遇问题时，可以尝试以安全模式重新执行。</p><h2 id="调试模式"><a href="#调试模式" class="headerlink" title="调试模式"></a>调试模式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo --debug</span><br><span class="line">$ hexo s --debug  #以debug模式运行</span><br></pre></td></tr></table></figure><p>在终端中显示调试信息并记录到 <code>debug.log</code>。当您碰到问题时，可以尝试用调试模式重新执行一次</p><h2 id="简洁模式"><a href="#简洁模式" class="headerlink" title="简洁模式"></a>简洁模式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo --silent</span><br></pre></td></tr></table></figure><p>隐藏终端信息。</p><h1 id="显示草稿"><a href="#显示草稿" class="headerlink" title="显示草稿"></a>显示草稿</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo --draft</span><br></pre></td></tr></table></figure><p>显示 <code>source/_drafts</code> 文件夹中的草稿文章。</p>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客搭建 </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo文章操作详解</title>
      <link href="/2019/10/04/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/Hexo%E6%93%8D%E4%BD%9C%E8%AF%A6%E8%A7%A3/"/>
      <url>/2019/10/04/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/Hexo%E6%93%8D%E4%BD%9C%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="网站配置"><a href="#网站配置" class="headerlink" title="网站配置"></a>网站配置</h1><p>网站根目录下的 <code>_config.yml</code> 中修改大部分的配置</p><h2 id="网站"><a href="#网站" class="headerlink" title="网站"></a>网站</h2><div class="table-container"><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>title</code></td><td style="text-align:left">网站标题</td></tr><tr><td style="text-align:left"><code>subtitle</code></td><td style="text-align:left">网站副标题</td></tr><tr><td style="text-align:left"><code>description</code></td><td style="text-align:left">网站描述</td></tr><tr><td style="text-align:left"><code>keywords</code></td><td style="text-align:left">网站的关键词。使用半角逗号 <code>,</code> 分隔多个关键词。</td></tr><tr><td style="text-align:left"><code>author</code></td><td style="text-align:left">您的名字</td></tr><tr><td style="text-align:left"><code>language</code></td><td style="text-align:left">网站使用的语言</td></tr><tr><td style="text-align:left"><code>timezone</code></td><td style="text-align:left">网站时区。Hexo 默认使用您电脑的时区。<a href="https://en.wikipedia.org/wiki/List_of_tz_database_time_zones" target="_blank" rel="noopener">时区列表</a>。比如说：<code>America/New_York</code>, <code>Japan</code>, 和 <code>UTC</code> 。</td></tr></tbody></table></div><p>其中，<code>description</code>主要用于SEO，告诉搜索引擎一个关于您站点的简单描述，通常建议在其中包含您网站的关键词。<code>author</code>参数用于主题显示文章的作者。</p><h2 id="网址"><a href="#网址" class="headerlink" title="网址"></a>网址</h2><div class="table-container"><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">描述</th><th style="text-align:left">默认值</th></tr></thead><tbody><tr><td style="text-align:left"><code>url</code></td><td style="text-align:left">网址</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>root</code></td><td style="text-align:left">网站根目录</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>permalink</code></td><td style="text-align:left">文章的 <a href="https://hexo.io/zh-cn/docs/permalinks" target="_blank" rel="noopener">永久链接</a> 格式</td><td style="text-align:left"><code>:year/:month/:day/:title/</code></td></tr><tr><td style="text-align:left"><code>permalink_defaults</code></td><td style="text-align:left">永久链接中各部分的默认值</td></tr></tbody></table></div><p>如果你的网站存放在子目录中，例如 <code>http://yoursite.com/blog</code>，则请将您的 <code>url</code> 设为 <code>http://yoursite.com/blog</code> 并把 <code>root</code> 设为 <code>/blog/</code></p><h2 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h2><div class="table-container"><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">描述</th><th style="text-align:left">默认值</th></tr></thead><tbody><tr><td style="text-align:left"><code>new_post_name</code></td><td style="text-align:left">新文章的文件名称</td><td style="text-align:left">:title.md</td></tr><tr><td style="text-align:left"><code>default_layout</code></td><td style="text-align:left">预设布局</td><td style="text-align:left">post</td></tr><tr><td style="text-align:left"><code>auto_spacing</code></td><td style="text-align:left">在中文和英文之间加入空格</td><td style="text-align:left">false</td></tr><tr><td style="text-align:left"><code>titlecase</code></td><td style="text-align:left">把标题转换为 title case</td><td style="text-align:left">false</td></tr><tr><td style="text-align:left"><code>external_link</code></td><td style="text-align:left">在新标签中打开链接</td><td style="text-align:left">true</td></tr><tr><td style="text-align:left"><code>filename_case</code></td><td style="text-align:left">把文件名称转换为 (1) 小写或 (2) 大写</td><td style="text-align:left">0</td></tr><tr><td style="text-align:left"><code>render_drafts</code></td><td style="text-align:left">显示草稿</td><td style="text-align:left">false</td></tr><tr><td style="text-align:left"><code>post_asset_folder</code></td><td style="text-align:left">启动 Asset 文件夹</td><td style="text-align:left">false</td></tr><tr><td style="text-align:left"><code>relative_link</code></td><td style="text-align:left">把链接改为与根目录的相对位址</td><td style="text-align:left">false</td></tr><tr><td style="text-align:left"><code>future</code></td><td style="text-align:left">显示未来的文章</td><td style="text-align:left">true</td></tr><tr><td style="text-align:left"><code>highlight</code></td><td style="text-align:left">代码块的设置</td></tr></tbody></table></div><h2 id="分类-amp-标签"><a href="#分类-amp-标签" class="headerlink" title="分类 &amp; 标签"></a>分类 &amp; 标签</h2><div class="table-container"><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">描述</th><th style="text-align:left">默认值</th></tr></thead><tbody><tr><td style="text-align:left"><code>default_category</code></td><td style="text-align:left">默认分类</td><td style="text-align:left"><code>uncategorized</code></td></tr><tr><td style="text-align:left"><code>category_map</code></td><td style="text-align:left">分类别名</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>tag_map</code></td><td style="text-align:left">标签别名</td></tr></tbody></table></div><h2 id="日期-时间格式"><a href="#日期-时间格式" class="headerlink" title="日期 / 时间格式"></a>日期 / 时间格式</h2><p>Hexo 使用 <a href="http://momentjs.com/" target="_blank" rel="noopener">Moment.js</a> 来解析和显示时间。</p><div class="table-container"><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">描述</th><th style="text-align:left">默认值</th></tr></thead><tbody><tr><td style="text-align:left"><code>date_format</code></td><td style="text-align:left">日期格式</td><td style="text-align:left"><code>YYYY-MM-DD</code></td></tr><tr><td style="text-align:left"><code>time_format</code></td><td style="text-align:left">时间格式</td><td style="text-align:left"><code>HH:mm:ss</code></td></tr></tbody></table></div><h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><div class="table-container"><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">描述</th><th style="text-align:left">默认值</th></tr></thead><tbody><tr><td style="text-align:left"><code>per_page</code></td><td style="text-align:left">每页显示的文章量 (0 = 关闭分页功能)</td><td style="text-align:left"><code>10</code></td></tr><tr><td style="text-align:left"><code>pagination_dir</code></td><td style="text-align:left">分页目录</td><td style="text-align:left"><code>page</code></td></tr></tbody></table></div><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><div class="table-container"><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>theme</code></td><td style="text-align:left">当前主题名称。值为<code>false</code>时禁用主题</td></tr><tr><td style="text-align:left"><code>theme_config</code></td><td style="text-align:left">主题的配置文件。在这里放置的配置会覆盖主题目录下的 _config.yml 中的配置</td></tr><tr><td style="text-align:left"><code>deploy</code></td><td style="text-align:left">部署部分的设置</td></tr><tr><td style="text-align:left"><code>meta_generator</code></td><td style="text-align:left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/meta#属性" target="_blank" rel="noopener">Meta generator</a> 标签。 值为 <code>false</code> 时 Hexo 不会在头部插入该标签</td></tr></tbody></table></div><h1 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h1><h1 id="文章文件"><a href="#文章文件" class="headerlink" title="文章文件"></a>文章文件</h1><h2 id="创建文章"><a href="#创建文章" class="headerlink" title="创建文章"></a>创建文章</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new [文章布局][参数] "文章标题"  #文章布局可省略，默认是post</span><br></pre></td></tr></table></figure><p>执行完成后可以在<code>/source/_posts</code> 下看到一个“<code>文章标题.md</code>”的文章文件。是 <code>Markdown</code> 格式的文件，头部为布局文件中的形式。最好不要直接在<code>/source/_posts</code>下直接创建<code>.md</code>文件。如果要直接创建则要加上头部信息(Front-matter)</p><p>参数：</p><div class="table-container"><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>-p</code>, <code>--path</code></td><td style="text-align:left">自定义新文章的路径</td></tr><tr><td style="text-align:left"><code>-r</code>, <code>--replace</code></td><td style="text-align:left">如果存在同名文章，将其替换</td></tr><tr><td style="text-align:left"><code>-s</code>, <code>--slug</code></td><td style="text-align:left">文章的 Slug，作为新文章的文件名和发布后的 URL</td></tr></tbody></table></div><p>默认情况下，Hexo 会使用文章布局来决定文章文件的路径。对于page布局来说，Hexo 会创建一个以标题为名字的目录，并在目录中放置一个 <code>index.md</code> 文件。可以使用 <code>--path</code> 参数来覆盖上述行为、自行决定文件的目录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page --path about/me &quot;About me&quot;</span><br></pre></td></tr></table></figure><p>以上命令会创建一个 <code>source/about/me.md</code> 文件，同时 Front Matter 中的 title 为 <code>&quot;About me&quot;</code></p><h2 id="文章布局（Layout）"><a href="#文章布局（Layout）" class="headerlink" title="文章布局（Layout）"></a>文章布局（Layout）</h2><p>在新建文章时，Hexo 会根据 <code>scaffolds</code> 文件夹内相对应的文章布局文件来建立<code>.md</code>文件。文章的布局（layout），默认为 <code>post</code>（对应<code>scaffolds</code>中的<code>post.md</code>文件），可以通过修改 <code>_config.yml</code> 中的 <code>default_layout</code> 参数来指定默认布局</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new photo &quot;My Gallery&quot;</span><br></pre></td></tr></table></figure><p>在执行这行指令时，Hexo 会尝试在 <code>scaffolds</code> 文件夹中寻找 <code>photo.md</code>，并根据其内容建立<code>&quot;My Gallery.md&quot;</code>文章</p><h3 id="默认布局：post、page、draft"><a href="#默认布局：post、page、draft" class="headerlink" title="默认布局：post、page、draft"></a>默认布局：<code>post</code>、<code>page</code>、<code>draft</code></h3><p>在创建三种不同类型的文件时，它们将会被保存到不同的路径；自定义的其他布局和 <code>post</code> 相同，都将储存到 <code>source/_posts</code> 文件夹。</p><div class="table-container"><table><thead><tr><th style="text-align:left">布局</th><th style="text-align:left">路径</th></tr></thead><tbody><tr><td style="text-align:left"><code>post</code></td><td style="text-align:left"><code>source/_posts</code></td></tr><tr><td style="text-align:left"><code>page</code></td><td style="text-align:left"><code>source</code></td></tr><tr><td style="text-align:left"><code>draft</code></td><td style="text-align:left"><code>source/_drafts</code></td></tr></tbody></table></div><p>草稿：</p><p>draft是Hexo 的一种特殊布局，这种布局在建立时会被保存到 <code>source/_drafts</code> 文件夹，默认不渲染，可通过 <code>publish</code> 命令将草稿移动到 <code>source/_posts</code> 文件夹进行渲染，该命令的使用方式与 <code>new</code> 类似</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo publish [文章布局] &quot;文章标题&quot;  #文章布局可省略，默认是post</span><br></pre></td></tr></table></figure><p>草稿默认不会显示在页面中，可在执行时加上 <code>--draft</code> 参数，或是把 <code>render_drafts</code> 参数设为 <code>true</code> 来预览草稿。</p><h3 id="自定义布局"><a href="#自定义布局" class="headerlink" title="自定义布局"></a>自定义布局</h3><p>支持自定义布局，可模仿<code>scaffolds/post.md</code>文件书写，详细见 Front-matter</p><h2 id="文件名称"><a href="#文件名称" class="headerlink" title="文件名称"></a>文件名称</h2><p>Hexo 默认以标题做为文件名称，可编辑站点配置文件的 <code>new_post_name</code> 参数来改变默认的文件名称，推荐默认设置 <code>:year-:month-:day-:title.md</code> 可更方便的通过日期来管理文章。</p><div class="table-container"><table><thead><tr><th style="text-align:left">变量</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>:title</code></td><td style="text-align:left">标题（小写，空格将会被替换为短杠）</td></tr><tr><td style="text-align:left"><code>:year</code></td><td style="text-align:left">建立的年份，比如， <code>2015</code></td></tr><tr><td style="text-align:left"><code>:month</code></td><td style="text-align:left">建立的月份（有前导零），比如， <code>04</code></td></tr><tr><td style="text-align:left"><code>:i_month</code></td><td style="text-align:left">建立的月份（无前导零），比如， <code>4</code></td></tr><tr><td style="text-align:left"><code>:day</code></td><td style="text-align:left">建立的日期（有前导零），比如， <code>07</code></td></tr><tr><td style="text-align:left"><code>:i_day</code></td><td style="text-align:left">建立的日期（无前导零），比如， <code>7</code></td></tr></tbody></table></div><h2 id="文章头部（Front-matter）"><a href="#文章头部（Front-matter）" class="headerlink" title="文章头部（Front-matter）"></a>文章头部（Front-matter）</h2><p>Front-matter 是文件最上方以 <code>---</code> 分隔的区域，用于指定个别文件的变量，举例来说：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: Hello World</span><br><span class="line">date: 2013/7/13 20:46:25</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>一般Front-matter：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">title: your title</span><br><span class="line">date: year-month-day</span><br><span class="line">tags:</span><br><span class="line"><span class="bullet">   - </span>your tag1</span><br><span class="line"><span class="bullet">   - </span>your tag2</span><br><span class="line">categories:</span><br><span class="line"><span class="bullet">   - </span>your category1</span><br><span class="line"><span class="bullet">   - </span>your category2</span><br></pre></td></tr></table></figure><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>以下是预先定义的参数，可在模板中使用这些参数值并加以利用。</p><div class="table-container"><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">描述</th><th style="text-align:left">默认值</th></tr></thead><tbody><tr><td style="text-align:left"><code>layout</code></td><td style="text-align:left">布局</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>title</code></td><td style="text-align:left">标题</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>date</code></td><td style="text-align:left">建立日期</td><td style="text-align:left">文件建立日期</td></tr><tr><td style="text-align:left"><code>updated</code></td><td style="text-align:left">更新日期</td><td style="text-align:left">文件更新日期</td></tr><tr><td style="text-align:left"><code>comments</code></td><td style="text-align:left">开启文章的评论功能</td><td style="text-align:left">true</td></tr><tr><td style="text-align:left"><code>tags</code></td><td style="text-align:left">标签（不适用于分页）</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>categories</code></td><td style="text-align:left">分类（不适用于分页）</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>permalink</code></td><td style="text-align:left">覆盖文章网址</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>keywords</code></td><td style="text-align:left">仅用于 meta 标签和 Open Graph 的关键词（不推荐使用）</td></tr></tbody></table></div><h3 id="分类和标签"><a href="#分类和标签" class="headerlink" title="分类和标签"></a>分类和标签</h3><p>只有文章支持分类和标签，可在 Front-matter 中设置。分类具有顺序性和层次性，也就是说 <code>Foo, Bar</code> 不等于 <code>Bar, Foo</code>；而标签没有顺序和层次。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">categories:</span><br><span class="line"> - Diary</span><br><span class="line">tags:</span><br><span class="line"> - PS3</span><br><span class="line"> - Games</span><br></pre></td></tr></table></figure><h1 id="文章资源"><a href="#文章资源" class="headerlink" title="文章资源"></a>文章资源</h1><p>资源（Asset）指<code>source</code> 文件夹中除了文章以外的所有文件，例如图片、CSS、JS 文件等。使用文章资源的方式有两种：使用Markdow语法或使用插件</p><h2 id="使用Markdown语法和相对路径来引用资源"><a href="#使用Markdown语法和相对路径来引用资源" class="headerlink" title="使用Markdown语法和相对路径来引用资源"></a>使用Markdown语法和相对路径来引用资源</h2><p>如果你的Hexo项目中只有少量图片，最简单的方法就是将它们放在 <code>source/images</code> 文件夹中。然后使用Markdown语法 <code>![](/images/image.jpg)</code> 的方法访问它们。</p><p>但通过常规的 markdown 语法和相对路径来引用图片和其它资源可能会导致它们在存档页或者主页上显示不正确</p><h2 id="使用文章资源文件夹和相对路径引用的标签插件"><a href="#使用文章资源文件夹和相对路径引用的标签插件" class="headerlink" title="使用文章资源文件夹和相对路径引用的标签插件"></a>使用文章资源文件夹和相对路径引用的标签插件</h2><ol><li><p>打开文件资源文件夹</p><p>Hexo提供了更组织化的方式来管理资源。通过将 主站配置文件<code>_config.yml</code> 文件中的 <code>post_asset_folder</code> 选项设为 <code>true</code> 来打开。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_config.ymlpost_asset_folder: true</span><br></pre></td></tr></table></figure><p>当资源文件管理功能打开后，Hexo将会在你每一次通过 <code>hexo new [layout] &lt;title&gt;</code> 命令创建新文章时自动创建一个文件夹。这个资源文件夹将会有与这个文章文件一样的名字。将所有与你的文章有关的资源放在这个关联文件夹中之后，可以通过相对路径来引用它们，这样就得到了一个更简单而且方便得多的工作流。</p></li><li><p>使用相对路径引用的标签插件插入图片</p><p>Hexo 3 这种标签插件已被加入到了核心代码中。这使得可以更简单地在文章中引用你的资源，语句如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% asset_path slug %&#125;</span><br><span class="line">&#123;% asset_img slug [title] %&#125;</span><br><span class="line">&#123;% asset_link slug [title] %&#125;</span><br></pre></td></tr></table></figure><p>例如：当你打开文章资源文件夹功能后，把一个 <code>example.jpg</code> 图片放在了对应的资源文件夹中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% asset_img example.jpg This is an example image %&#125;</span><br></pre></td></tr></table></figure></li></ol><p>​    通过这种方式，图片将会同时出现在文章和主页以及归档页中。</p><h1 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h1>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客搭建 </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 Github Page + Hexo 搭建自己的博客网站</title>
      <link href="/2019/10/03/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/Github-Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2019/10/03/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/Github-Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="注册Github账号、创建代码库"><a href="#注册Github账号、创建代码库" class="headerlink" title="注册Github账号、创建代码库"></a>注册Github账号、创建代码库</h1><ol><li><p>没有账号的先<a href="https://github.com/" target="_blank" rel="noopener">注册</a>账号<br><img alt="注册账号" data-src="//orangesching.github.io/2019/10/03/博客搭建/Github-Hexo搭建博客/1.png" class="lazyload"></p></li><li><p>点击 Start project 或者下面的 new repository 创建一个新的仓库，注意仓库名要以  <strong>用户名.github.io</strong> 命名。且Github规定一个用户仅能使用一个同名仓库的代码托管一个静态站点</p><p><img alt="创建一个新的仓库" data-src="//orangesching.github.io/2019/10/03/博客搭建/Github-Hexo搭建博客/2.png" class="lazyload"></p></li><li><p>可访问 <a href="https://用户名.github.io" target="_blank" rel="noopener">https://用户名.github.io</a> 来访问你的静态站点（如果你在该仓库写一个index.html则会显示这个页面的内容）</p></li></ol><h1 id="安装各种工具"><a href="#安装各种工具" class="headerlink" title="安装各种工具"></a><span id="2">安装各种工具</span></h1><h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><ol><li><p>下载<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">Git</a>，<a href="https://www.liaoxuefeng.com/wiki/896043488029600" target="_blank" rel="noopener">Git使用教程</a></p></li><li><p>傻瓜式安装，成功标志：在开始菜单里找到“Git”-&gt;“Git Bash”，，蹦出一个类似命令行窗口的东西</p></li><li><p>配置Git，没有账号的见注册步骤</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name "Your Name"</span><br><span class="line">git config --global user.email "email@example.com"</span><br></pre></td></tr></table></figure></li></ol><h2 id="NodeJS"><a href="#NodeJS" class="headerlink" title="NodeJS"></a>NodeJS</h2><p>Node.js 是一个基于 Chrome V8 引擎的 <a href="https://baike.baidu.com/item/JavaScript/321142" target="_blank" rel="noopener">JavaScript</a> 运行环境。 Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型。Node 是一个让 JavaScript 运行在<a href="https://baike.baidu.com/item/服务端/6492316" target="_blank" rel="noopener">服务端</a>的开发平台，它让 JavaScript 成为与<a href="https://baike.baidu.com/item/PHP/9337" target="_blank" rel="noopener">PHP</a>、<a href="https://baike.baidu.com/item/Python/407313" target="_blank" rel="noopener">Python</a>、<a href="https://baike.baidu.com/item/Perl/851577" target="_blank" rel="noopener">Perl</a>、<a href="https://baike.baidu.com/item/Ruby/11419" target="_blank" rel="noopener">Ruby</a> 等服务端语言平起平坐的<a href="https://baike.baidu.com/item/脚本语言/1379708" target="_blank" rel="noopener">脚本语言</a>。</p><p>npm是NodeJS的包管理器</p><p>由于Hexo基于NodeJS，安装Hexo需先安装NodeJS</p><ol><li><p>下载<a href="https://nodejs.org/en/" target="_blank" rel="noopener">NodeJS</a></p></li><li><p>傻瓜式安装，成功标志：打开cmd输入node -v和npm -v显示版本。显示不是内部或外部命令的解决方法</p><ul><li>重启cmd</li><li>查看是否配置NodeJS环境变量(计算机-&gt;属性-&gt;高级系统属性-&gt;高级-&gt;环境变量-&gt;找到Path查看是否有NodeJS路径)</li></ul></li><li><p>验证前两步</p><p>打开git bash（Windowns）或者终端（Mac），在命令行中输入相应命令验证是否成功，如果成功会有相应的版本号</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git version</span><br><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure></li></ol><h2 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h2><p>以上环境准备好了就可以使用 npm 开始安装 Hexo 了，<a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">官方Hexo文档</a></p><p>使用NodeJS的包管理器npm来安装Hexo，在命令行输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><h1 id="使用Hexo生成本地博客"><a href="#使用Hexo生成本地博客" class="headerlink" title="使用Hexo生成本地博客"></a>使用Hexo生成本地博客</h1><h2 id="使用以下命令初始化一个博客项目"><a href="#使用以下命令初始化一个博客项目" class="headerlink" title="使用以下命令初始化一个博客项目"></a>使用以下命令初始化一个博客项目</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd &lt;博客放置的路径&gt;  #不执行此语句默认在用户目录下</span><br><span class="line">hexo init myBlog&lt;博客文件夹名&gt;</span><br><span class="line">cd myBlog&lt;博客文件夹名&gt;</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><p>创建完成后，博客文件夹目录如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml # 网站的配置信息，您可以在此配置大部分的参数。 </span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds # 模版文件夹,当您新建文章时，Hexo 会根据 scaffolds 来建立文件</span><br><span class="line">├── source  # 资源文件夹，除 _posts 文件，其他以下划线_开头的文件或者文件夹不会被编译打包到public文件夹</span><br><span class="line">|   └── _posts # 文章Markdowm文件 </span><br><span class="line">└── themes  # 主题文件夹，Hexo 会根据主题来生成静态页面</span><br></pre></td></tr></table></figure><h2 id="运行浏览博客"><a href="#运行浏览博客" class="headerlink" title="运行浏览博客"></a>运行浏览博客</h2><p>要能够在本地预览自己的博客，需要本地启动服务器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s   #浏览器访问 http://localhost:4000 浏览</span><br></pre></td></tr></table></figure><p>本地博客搭建成功，下面部署到 Github Page</p><h1 id="部署到Github-Page"><a href="#部署到Github-Page" class="headerlink" title="部署到Github Page"></a>部署到Github Page</h1><h2 id="配置SSH-key"><a href="#配置SSH-key" class="headerlink" title="配置SSH key"></a>配置SSH key</h2><p>要使用 git 工具首先要配置一下SSH key，为部署本地博客到 Github 做准备。</p><ol><li><p>查看是否有SSH key</p><p>打开命令行输入 cd ~/.ssh 如果没报错或者提示什么的说明就是以前生成过的，直接使用 cat ~/.ssh/id_rsa.pub 命令就是可以查看本机上的 SSH key 了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure></li><li><p>没有就创建</p><p>全局配置一下本地账户：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;用户名&quot;</span><br><span class="line">git config --global user.email &quot;邮箱地址&quot;</span><br></pre></td></tr></table></figure><p>生成密钥 SSH key</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &apos;上面的邮箱&apos;</span><br></pre></td></tr></table></figure><p>按照提示完成三次回车，即可生成 ssh key。通过查看 ~/.ssh/id_rsa.pub 文件内容，获取到你的 SSH key</p><p><img alt="生成 ssh key" data-src="//orangesching.github.io/2019/10/03/博客搭建/Github-Hexo搭建博客/3.png" class="lazyload"></p><p>首次使用还需要确认并添加主机到本机SSH可信列表。若返回 Hi xxx! You’ve successfully authenticated, but GitHub does not provide shell access. 内容，则证明添加成功。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure></li><li><p>登录 <a href="https://github.com/" target="_blank" rel="noopener">Github</a> 上Settings添加刚刚生成的SSH key</p><p><img alt="Github添加SSH key" data-src="//orangesching.github.io/2019/10/03/博客搭建/Github-Hexo搭建博客/4.png" class="lazyload"></p><p>创建一个新的 SSH key, 标题随便取，key 填刚才生成的，这样在你的 SSH keys 列表里就有刚刚添加的密钥。</p></li></ol><h2 id="部署到Github"><a href="#部署到Github" class="headerlink" title="部署到Github"></a>部署到Github</h2><p>将本地博客库和Github连接起来</p><p>打开项目根目录下的 _config.yml 配置文件。Deploymen部分按如下配置（也可同时部署到多个仓库）：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># &lt;span id = "4"&gt;Deployment&lt;/span&gt;</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">git</span></span><br><span class="line"><span class="attr">  repo:</span> </span><br><span class="line"><span class="attr">    github:</span> <span class="attr">https://github.com/&lt;github用户名&gt;/&lt;github用户名&gt;.github.io.git</span></span><br><span class="line"><span class="attr">  branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><p>安装部署插件 <a href="https://github.com/hexojs/hexo-deployer-git" target="_blank" rel="noopener">hexo-deployer-git</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>最后执行以下命令就可以部署上传啦，以下 g 是 generate 缩写，d 是 deploy 缩写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g -d</span><br></pre></td></tr></table></figure><p>稍等一会，在浏览器访问网址： <a href="https://用户名.github.io" target="_blank" rel="noopener">https://用户名.github.io</a>  成功！！！具体配置和使用教程参见下一博客</p><h1 id="备份原文件-多电脑写博客同步"><a href="#备份原文件-多电脑写博客同步" class="headerlink" title="备份原文件/多电脑写博客同步"></a>备份原文件/多电脑写博客同步</h1><p>由于<code>hexo d</code>上传部署到github的其实是hexo编译后的文件，是用来生成网页的，不包含源文件。也就是上传的是在本地目录里自动生成的<code>.deploy_git</code>里面。其他文件 ，包括我们写在source 里面的，和配置文件，主题文件，都没有上传到github。所以可以利用git的分支管理，将源文件上传到github的另一个分支即可备份</p><ol><li>首先，在github上新建一个hexo分支，如图：</li></ol><p><img alt="新建分支" data-src="//orangesching.github.io/2019/10/03/博客搭建/Github-Hexo搭建博客/新建分支.png" class="lazyload"></p><ol><li>在这个仓库的settings中，选择默认分支为hexo分支（这样每次同步的时候就不用指定分支，比较方便）。</li></ol><p><img alt="设置默认分支" data-src="//orangesching.github.io/2019/10/03/博客搭建/Github-Hexo搭建博客/设置默认分支.png" class="lazyload"></p><ol><li>在本地的任意目录下，打开git bash克隆代码，因为默认分支已经设成了hexo，所以clone时只clone了hexo。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@github.com:ZJUFangzh/ZJUFangzh.github.io.git</span><br></pre></td></tr></table></figure><ol><li><p>在克隆到本地的username.github.io中，把除了.git 文件夹外的所有文件都删掉（因为刚刚建立的分支代码和主分支一样，除了.git文件夹其他都没用）</p></li><li><p>把之前写的博客源文件全部复制过来，除了<code>.deploy_git</code>。这里应该说一句，复制过来的源文件应该有一个<code>.gitignore</code>，用来忽略一些不需要的文件，如果没有的话，自己新建一个，在里面写上如下，表示这些类型文件不需要git：</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.DS_Store</span><br><span class="line">Thumbs.db</span><br><span class="line">db.json</span><br><span class="line">*.<span class="built_in">log</span></span><br><span class="line">node_modules/</span><br><span class="line"><span class="keyword">public</span>/</span><br><span class="line">.deploy*/</span><br></pre></td></tr></table></figure><blockquote><p>注意，如果你之前克隆过theme中的主题文件，那么应该把主题文件中的<code>.git</code>文件夹删掉，因为git不能嵌套上传，最好是显示隐藏文件，检查一下有没有，否则上传的时候会出错，导致你的主题文件无法上传，这样你的配置在别的电脑上就用不了了。</p></blockquote><ol><li>提交源代码</li></ol><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">add</span> .</span><br><span class="line">git commit –m <span class="string">"add branch"</span></span><br><span class="line">git push</span><br></pre></td></tr></table></figure><p>这样就上传完了，可以去你的github看一看hexo分支有没有上传上去，其中<code>node_modules</code>、<code>public</code>、<code>db.json</code>已经被忽略掉了，这些文件在别的电脑上需要重新输入命令安装 。</p><p><img alt="完成图" data-src="//orangesching.github.io/2019/10/03/博客搭建/Github-Hexo搭建博客/上传完成图.png" class="lazyload"></p><ol><li>打开仓库的设置，向下找到GitHub Pages 确定展示使用的分支是master，不然页面会报404</li></ol><p><img alt="确认显示用的分支是master" data-src="//orangesching.github.io/2019/10/03/博客搭建/Github-Hexo搭建博客/确认显示用的分支是master.png" class="lazyload"></p><p>不要忘了，每次写完最好都把源文件上传一下</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">add</span> .</span><br><span class="line">git commit –m <span class="string">"描述xxxx"</span></span><br><span class="line">git push</span><br></pre></td></tr></table></figure><p>如果是在已经编辑过的电脑上，已经有clone文件夹了，那么，每次只要和远端同步一下就行了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure><p>&gt;</p><blockquote><p>总结：简单的说就是把仓库分为了两个分支：master和hexo(默认)</p><p>hexo分支使用git方式上传</p><p>master分支使用hexo g; hexo d上传 </p></blockquote><h1 id="迁移到新电脑"><a href="#迁移到新电脑" class="headerlink" title="迁移到新电脑"></a>迁移到新电脑</h1><ol><li><p><a href="#2">安装各种工具</a></p></li><li><p><a href="#4">部署到Github Page-配置SSH key</a></p></li><li><p>直接在任意文件夹下clone源文件</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@github.com:username/username.github.io.git</span><br></pre></td></tr></table></figure><ol><li>进入克隆到的文件夹安装</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">cd</span> <span class="selector-tag">xxx</span><span class="selector-class">.github</span><span class="selector-class">.io</span></span><br><span class="line"><span class="selector-tag">npm</span> <span class="selector-tag">install</span></span><br><span class="line"><span class="selector-tag">npm</span> <span class="selector-tag">install</span> <span class="selector-tag">hexo-deployer-git</span> <span class="selector-tag">--save</span></span><br></pre></td></tr></table></figure><ol><li>生成，部署：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><ol><li>就可以开始写你的新博客了</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo <span class="keyword">new</span> newpage</span><br></pre></td></tr></table></figure><p>参考：<a href="https://www.jianshu.com/p/153490a029a5" target="_blank" rel="noopener">https://www.jianshu.com/p/153490a029a5</a></p>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客搭建 </tag>
            
            <tag> Github Page </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
