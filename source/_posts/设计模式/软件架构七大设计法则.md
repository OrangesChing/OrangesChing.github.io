---
title: 软件架构七大设计法则
date: 2021-07-17 10:08:11
categories:
  - 设计模式
---

| 法则         | 简述                                                         |
| ------------ | ------------------------------------------------------------ |
| 单一职责法则 | 一个类（类、函数、模块等）只负责一项职责                     |
| 里氏代替法则 | 子类可以扩展父类的功能，但不能改变父类原有的功能             |
| 依赖倒置法则 | 要面向接口编程，细节应该依赖于抽象，抽象不应该依赖于细节     |
| 接口隔离法则 | 设计接口时要精简单一，使用多个专门功能的接口，而不是使用单一的总接口 |
| 迪米特法则   | 降低耦合，减少实体之间的通信                                 |
| 合成复用法则 | 尽量使用组合或者聚合关系实现代码复用，少使用继承             |
| 开放封闭法则 | **终极目标**，一个实体（类、函数、模块等）应该对外扩展开放，对内修改关闭 |

# 单一职责法则 (Single Responsibility Principle)

## 定义

一个类只有一个引起它变化的原因。即一个类只负责一项职责

<u>一个类（大到模块，小到方法）承担的职责越多，它被复用的可能性就越小</u>，而且一个类承担的职责过多，就相当于将这些职责耦合在一起，当其中一个职责变化时，可能会影响其他职责的运作，因此要将这些职责进行分离，将不同的职责封装在不同的类中，即将不同的变化原因封装在不同的类中，如果多个职责总是同时发生改变则可将它们封装在同一类中

单一职责法则是实现高内聚、低耦合的指导方针，它是最简单但又最难运用的法则

## 问题

类T负责两个不同的职责：职责P1，职责P2。当由于职责P1需求发生改变而需要修改类T时，有可能会导致原本运行正常的职责P2功能发生故障

如：

TransformClass有三个方法，按约定参数组装方法，加密方法，传输方法。此时违背了单一职责法则，因为TransformClass类有三个职责，组装报文，加密和传输

## 按法则解决

遵循单一职责法则。分别建立两个类T1、T2，使T1完成职责P1功能，T2完成职责P2功能。这样，当修改类T1时，不会使职责P2发生故障风险；同理，当修改T2时，也不会使职责P1发生故障风险

如：

按单一职责法则重构上述例子，则应分为三个类EncryUtil，PKGUtil，TransformClass，分别的职责为加密，组装，传输

## 实际应用

**实际应用难点：**存在职责扩散现象，也就是因为某种原因，职责P被分化为粒度更细的职责P1和P2。这时如果要使程序遵循单一职责法则，需要将类T也分解为两个类T1和T2，分别负责P1、P2两个职责。但是在程序已经写好的情况下，这时通常会违背单一职责法则直接修改类T

**应用要点：**只有逻辑足够简单，才可以在代码级别上违反单一职责法则；只有类中方法数量足够少，才可以在方法级别上违反单一职责法则

# 开放封闭法则(Open-Closed Principle)

## 定义

一个软件实体应当对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展

软件实体可以指一个软件模块、一个由多个类组成的局部结构或一个独立的类

## 问题

在软件迭代过程中，因为变化、升级和维护等原因需要对软件原有代码进行修改时，可能会给旧代码中引入错误，也可能会使我们不得不对整个功能进行重构，并且需要原有代码经过重新测试

如：

一开始只需要画柱状图和饼装图，若在ChartDisplay类的display()方法中存在如下代码片段：

```java
......
if (type.equals("pie")) {
PieChart chart = new PieChart();
chart.display();
}
else if (type.equals("bar")) {
BarChart chart = new BarChart();
chart.display();
}
......
```


在该代码中，如果需要支持画新的图表类型，如折线图LineChart，则需要修改ChartDisplay类的display()方法的源代码，增加新的判断逻辑，违反了开闭法则

## 按法则解决

当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。需要对系统进行抽象化设计，通过它们定义系统的抽象层，再通过具体类来进行扩展。如果需要修改系统的行为，无须对抽象层进行任何改动，只需要增加新的具体类来实现新的业务功能即可，实现在不修改已有代码的基础上扩展系统的功能，达到开闭法则的要求。**抽象化是开闭法则的关键：用抽象构建框架，用实现扩展细节**

如：

按单一职责法则重构上述例子，则应增加一个抽象图表类，各种具体图表类作为其子类，ChartDisplay类针对抽象图表类进行编程，由客户端来决定使用哪种具体图表

## 实际应用

**应用要点：**

用抽象构建框架，用实现扩展细节

# 里氏替换法则(Liskov Substitution Principle)

## 定义

所有引用基类（父类）的地方必须能透明地使用其子类的对象，在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常

里氏替换法则的主要作用就是规范继承时子类的一些书写规则。<u>其主要目的就是保持父类方法不被覆盖</u>通过。包含以下4层含义：

- 一个软件实体如果适用一个父类的话，那一定适用于其子类，所有引用父类的方法必须能透明地使用其子类的对象，子类对象能够替换父类对象，而程序逻辑不变
- 子类可以扩展父类的功能，但不能改变父类原有的功能。就是说，子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。子类中可以增加自己特有的方法
- 当子类的方法重载父类的方法时，方法的前置条件(即方法的输入/入参)要比父类方法的输入参数更加宽松
- 当子类的方法实现父类的方法时(重写/重载或实现抽象方法)，方法的后置条件(即方法的输出/返回值)要比父类更严格或相等

## 问题

有一功能P1，由类A完成。现需要将功能P1进行扩展，扩展后的功能为P，其中P由原有功能P1与新功能P2组成。新功能P由类A的子类B来完成，则子类B在完成新功能P2的同时，有可能会导致原有功能P1发生故障

如：几维鸟不是鸟的例子

鸟一般都会飞行，如燕子的飞行速度大概是每小时 120 千米。但是新西兰的几维鸟由于翅膀退化无法飞行。假如要设计一个实例，计算这两种鸟飞行 300 千米要花费的时间

```java
//鸟类
class Bird {
    double flySpeed;
    public void setSpeed(double speed) {
        flySpeed = speed;
    }
    public double getFlyTime(double distance) {
        return (distance / flySpeed);
    }
}
//燕子类
class Swallow extends Bird {
}
//几维鸟类
class BrownKiwi extends Bird {
    public void setSpeed(double speed) {
        flySpeed = 0;
    }
}
public class LSPtest {
    public static void main(String[] args) {
        Bird bird1 = new Swallow();
        Bird bird2 = new BrownKiwi();
        bird1.setSpeed(120);
        bird2.setSpeed(120);
        System.out.println("如果飞行300公里：");
        try {
            System.out.println("燕子将飞行" + bird1.getFlyTime(300) + "小时.");
            // 程序运行错误的原因是：几维鸟类重写了鸟类的 setSpeed(double speed) 方法，这违背了里氏替换法则
            System.out.println("几维鸟将飞行" + bird2.getFlyTime(300) + "小时。");
        } catch (Exception err) {
            System.out.println("发生错误了!");
        }
    }
}
```

## 按法则解决

当使用继承时，遵循里氏替换法则。类B继承类A时，除添加新的方法完成新增功能P2外，尽量不要重写父类A的方法，也尽量不要重载父类A的方法

```java
public class LspTest2 {
    public static void main(String[] args) {
        Animal bird_swallow = new Bird_Swallow();
        Animal notBird_brownKiwi = new NotBird_BrownKiwi();
        bird_swallow.setSpeed(120);
        notBird_brownKiwi.setSpeed(120);
        System.out.println("如果移动300公里：");
        try {
            System.out.println("燕子将花费" + bird_swallow.getFlyTime(300) + "小时。"); // 燕子将花费2.5小时。
            System.out.println("几维鸟将花费" + notBird_brownKiwi.getFlyTime(300) + "小时。"); // 几维鸟将花费2.5小时。
        } catch (Exception err) {
            System.out.println("发生错误了！");
        }
    }
}

// 动物类
class Animal {
    private double speed;

    public void setSpeed(double speed) {
        this.speed = speed;
    }
    
    public double getFlyTime(double distance) {
        return (distance / speed);
    }
}

// 燕子类
class Bird_Swallow extends Animal {
}

// 几维鸟类
class NotBird_BrownKiwi extends Animal {

}
```

## 实际应用

**应用要点：**

子类书写时需注意

- 一个软件实体如果适用一个父类的话，那一定适用于其子类，所有引用父类的方法必须能透明地使用其子类的对象，子类对象能够替换父类对象，而程序逻辑不变
- 子类可以扩展父类的功能，但不能改变父类原有的功能。就是说，子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。子类中可以增加自己特有的方法
- 当子类的方法重载父类的方法时，方法的前置条件(即方法的输入/入参)要比父类方法的输入参数更加宽松
- 当子类的方法实现父类的方法时(重写/重载或实现抽象方法)，方法的后置条件(即方法的输出/返回值)要比父类更严格或相等

# 依赖倒置法则(Dependence Inversion Principle)

## 定义

抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程

核心思想是**面向接口编程**

相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建起来的架构比以细节为基础搭建起来的架构要稳定的多。在java中，抽象指的是接口或者抽象类，细节就是具体的实现类，使用接口或者抽象类的目的是制定好规范和契约，而不去涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成

## 问题

类A直接依赖类B，假如要将类A改为依赖类C，则必须通过修改类A的代码来达成。这种场景下，类A一般是高层模块，负责复杂的业务逻辑；类B和类C是低层模块，负责基本的原子操作假如修改类A，会给程序带来不必要的风险

如：

以妈妈拿书将故事为例，实现代码如下，当某一天妈妈的故事来源不是书而是报纸，则无法做到

```java
public class Book{
	public String getContent(){
		return "很久很久以前有一个阿拉伯的故事……";
	}
}
 
public class Mother{
	public void narrate(Book book){
		System.out.println("妈妈开始讲故事");
		System.out.println(book.getContent());
	}
}
 
public class Client{
	public static void main(String[] args){
		Mother mother = new Mother();
		mother.narrate(new Book());
	}
}
```



## 按法则解决

将类A修改为依赖接口I，类B和类C各自实现接口I，类A通过接口I间接与类B或者类C发生联系，则会大大降低修改类A的几率

如：

将读物抽象为接口

```java
// 抽象接口
public interface IReader{
	public String getContent();
}

public class Newspaper implements IReader {
	public String getContent(){
		return "林书豪17+9助尼克斯击败老鹰……";
	}
}
public class Book implements IReader{
	public String getContent(){
		return "很久很久以前有一个阿拉伯的故事……";
	}
}

public class Mother{
	// 此处依赖的为抽象的读物
	public void narrate(IReader reader){
		System.out.println("妈妈开始讲故事");
		System.out.println(reader.getContent());
	}
}

public class Client{
	public static void main(String[] args){
		Mother mother = new Mother();
		mother.narrate(new Book());
		mother.narrate(new Newspaper());
	}
}
```

## 实际应用

**应用要点：**

传递依赖关系有三种方式，接口传递，构造方法传递和setter方法传递

- 每个类尽量提供接口或抽象类，或者两者都具备
- 变量的声明类型尽量是接口或者是抽象类
- 任何类都不应该从具体类派生
- 使用继承时尽量遵循里氏替换原则

# 接口隔离法则(Interface Segregation Principle)

## 定义

客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上

建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少。也就是说，我们要为各个类建立专用的接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用

> 与单一职责法则的不同
>
> - 单一职责法则原注重的是职责；而接口隔离法则注重对接口依赖的隔离
> - 单一职责法则主要是约束类，其次才是接口和方法，它针对的是程序中的实现和细节；而接口隔离法则主要约束接口，主要针对抽象，针对程序整体框架的构建

## 问题

类A通过接口I依赖类B，类C通过接口I依赖类D，如果接口I对于类A和类C来说不是最小接口，则类B和类D必须去实现他们不需要的方法

如：

![1338196802_3341](软件架构七大设计法则\1338196802_3341-1645171881242.jpg)

## 按法则解决

将臃肿的接口I拆分为独立的几个接口，类A和类C分别与他们需要的接口建立依赖关系

如：

![1338196830_7162](软件架构七大设计法则\1338196830_7162.jpg)

## 实际应用

**应用要点：**

- 接口尽量小，但是要有限度。一个接口只服务于一个子模块或业务逻辑。
- 为依赖接口的类定制服务。只提供调用者需要的方法，屏蔽不需要的方法。
- 了解环境，拒绝盲从。每个项目或产品都有选定的环境因素，环境不同，接口拆分的标准就不同深入了解业务逻辑。
- 提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情

# 迪米特法则(Law Of Demeter)

## 定义

迪米特法则又叫最少知道原则，通俗的来讲，就是一个类对自己依赖的类知道的越少越好，定义为只与你的**直接朋友**交谈，不跟陌生人说话

直接朋友是指：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系，耦合的方式很多，依赖、关联、组合、聚合等。其中，我们称出现成员变量、方法参数、方法返回值中的类为**直接的朋友**，而<u>出现在局部变量中的类则不是直接的朋友</u>。如：

-  当前对象本身(this)
- 以参数形式传入到当前对象方法中的对象
- 当前对象的成员对象
- 如果当前对象的成员对象是一个集合，那么集合中的元素也都是朋友
- 当前对象所创建的对象

含义：如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用

目的：降低类之间的耦合度，提高模块的相对独立性

迪米特法则是对软件实体之间通信的限制， 迪米特法则要求限制软件实体之间通信的宽度和深度。

## 问题

类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大

如：

某些界面控件之间存在复杂的交互关系，一个控件事件的触发将导致多个其他界面控件产生响应，例如，当一个按钮(Button)被单击时，对应的列表框(List)、组合框(ComboBox)、文本框(TextBox)、文本标签(Label)等都将发生改变

![1336930654_2743](软件架构七大设计法则\1336930654_2743.jpg)

## 按法则解决

尽量降低类与类之间的耦合

如：

上面的例子中可以通过引入一个专门用于控制界面控件交互的中间类(Mediator)来降低界面控件之间的耦合度。引入中间类之后，界面控件之间不再发生直接引用，而是将请求先转发给中间类，再由中间类来完成对其他控件的调用。当需要增加或删除新的控件时，只需修改中间类即可，无须修改新增控件或已有控件的源代码

![1336930673_6550](软件架构七大设计法则\1336930673_6550.jpg)

## 实际应用

**应用要点：**

- 在类的划分上，应该创建弱耦合的类。类与类之间的耦合越弱，就越有利于实现可复用的目标
- 在类的结构设计上，尽量降低类成员的访问权限
- 在类的设计上，优先考虑将一个类设置成不变类
- 在对其他类的引用上，将引用其他对象的次数降到最低
- 不暴露类的属性成员，而应该提供相应的访问器（set 和 get 方法）
- 谨慎使用序列化（Serializable）功能

# 合成复用法则(Composite/Aggregate Reuse Principle)

## 定义

合成复用原则又叫组合/聚合复用原则。它要求在软件复用时，要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现

## 问题

继承复用的方式会破坏类的封装性，增加子类与父类的耦合，降低复用的灵活性

如：

汽车按“动力源”划分可分为汽油汽车、电动汽车等；按“颜色”划分可分为白色汽车、黑色汽车和红色汽车等

![用继承关系实现的汽车分类的类图](软件架构七大设计法则\3-1Q113160133151.gif)

## 按法则解决

优先使用组合或者聚合等关联关系来实现复用

如：

上面的例子可以看出用继承关系实现会产生很多子类，而且增加新的“动力源”或者增加新的“颜色”都要修改源代码，这违背了开闭原则，显然不可取。但如果改用组合关系实现就能很好地解决以上问题

![用组合关系实现的汽车分类的类图](软件架构七大设计法则\3-1Q11316034X57.gif)

## 实际应用

**应用要点：**

通过将已有的对象纳入新对象中，作为新对象的成员对象来实现的，新对象可以调用已有对象的功能，从而达到复用



参考：

https://blog.csdn.net/zhengzhb/article/details/7278174

http://c.biancheng.net/design_pattern/