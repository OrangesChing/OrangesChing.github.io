---
title: 正则表达式
date: 2020-11-23 10:42:23
tags:
  - 正则表达式
categories:
  - 其他
---

# 正则表达式语法

## 匹配内容限定

### 常见字符匹配

| 语法             | 说明                             | 例子                       |
| ---------------- | -------------------------------- | -------------------------- |
| `.`              | 匹配除换行符 \n 之外的任何单字符 |                            |
| `\w`             | 匹配字母、数字、下划线           |                            |
| `\s`             | 匹配所有空白符，包括换行、空格、制表符、换页符等等 |                            |
|                  |                                                    |                            |
| `\d`             | 匹配数字                         | 匹配4位数字：`^\d\d\d\d$`  |
| `\b`             | 匹配单词的开始或结束             | 以abc开头的字符串：`\babc` |
| `^`              | 匹配字符串的开头                 | 以abc开头的字符串：`^abc`  |
| `$`              | 匹配字符串的结束                 |                            |
| `\u4e00-\u9fa5a` | 匹配中文                         |                            |
| `\f` | 匹配一个换页符                         ||
| `\n` | 匹配一个换行符                         ||
| `\r` | 匹配一个回车符                         ||
| `\t` | 匹配一个制表符                         ||
| `\v` | 匹配一个垂直制表符                     ||

### 转义

当正则表达式语法中的符号真实出现需匹配时 可转义成普通的字符，即在要转义的字符前面加个斜杠`\`
如：要匹配以`(ab)`开头的字符串：`^(\(ab\))*`

### 反义

前面说到元字符的都是要匹配什么什么，当然如果你想反着来，不想匹配某些字符，正则也提供了一些常用的反义元字符：

| 语法   | 说明                                   |                                           |
| ------ | -------------------------------------- | ----------------------------------------- |
| `\W`   | 匹配不是字母、数字、下划线、汉字的字符 |                                           |
| `\S`   | 匹配非空白符，包括换行                 |                                           |
| `\D`   | 匹配任意非数字的字符                   |                                           |
| `\B`   | 匹配不是单词开头或结束的位置           |                                           |
| `[^x]` | 匹配除x以外的任意字符                  | `[^aeiou]`匹配除aeiou几个字母外的任意字符 |



## 匹配内容位置限定

| 语法 | 说明                 | 例子                       |
| ---- | -------------------- | -------------------------- |
| `^`  | 匹配字符串的开头     | 以abc开头的字符串：`^abc`  |
| `$`  | 匹配字符串的结束     |                            |
| `\b` | 匹配单词的开始或结束 | 以abc开头的字符串：`\babc` |
| `\B` | 非单词边界匹配       |                            |


## 匹配内容重复次数限定——限定符

匹配重复次数加在内容限定的后面，限定符作用在与他左边最近的一个字符，默认是贪婪匹配（尽可能多的匹配文字），在后面加上一个`?`就可实现非贪婪匹配

| 语法    | 说明             | 例子                   |
| ------- | ---------------- | ---------------------- |
| `*`     | 重复零次或更多次 |                        |
| `+`     | 重复一次或更多次 |                        |
| `?`     | 重复零次或一次   |                        |
| `{n}`   | 重复n次          | 匹配4位数字：`^\d{4}$` |
| `{n,}`  | 重复n次或更多次  |                        |
| `{n,m}` | 重复n到m次       |                        |

> **贪婪匹配**
>
> 当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能多的字符，这匹配方式叫做贪婪匹配。
> 特性：一次性读入整个字符串进行匹配，每当不匹配就舍弃最右边一个字符，继续匹配，依次匹配和舍弃（这种匹配-舍弃的方式也叫做回溯），直到匹配成功或者把整个字符串舍弃完为止，因此它是一种最大化的数据返回，能多不会少。
>
> **懒惰匹配**
>
> 当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能少的字符，这匹配方式叫做懒惰匹配。
> 特性：从左到右，从字符串的最左边开始匹配，每次试图不读入字符匹配，匹配成功，则完成匹配，否则读入一个字符再匹配，依此循环（读入字符、匹配）直到匹配成功或者把字符串的字符匹配完为止。
>
> 如：`*?`、`+?`、`??`、`{n,m}?`

## 分组

正则表达式中用小括号`()`来做分组，也就是括号中的内容作为一个整体。

如：匹配字符串中包含0到多个ab开头：` ^(ab)*`

## 条件或

正则用符号` |` 来表示或，也叫做分支条件，当满足正则里的分支条件的任何一种条件时，都会当成是匹配成功

例如：匹配一个联通的号码（130/131/132/155/156/185/186/145/176等号段）
           可写为`^(130|131|132|155|156|185|186|145|176)\d{8}$`

## 区间

正则提供一个元字符中括号` [] `来表示区间条件。

例如：

- 限定0到9 可以写成`[0-9]`
- 限定A-Z 写成`[A-Z]`
- 限定某些数字` [165]`
- `^(130|131|132|155|156|185|186|145|176)\d{8}$`可写为`^((13[0-2])|(15[56])|(18[5-6])|145|176)\d{8}$`

# 正则进阶知识点

## 零宽断言

> 无论是零宽还是断言，听起来都古古怪怪的，
> 那先解释一下这两个词。

1. 断言：俗话的断言就是“我断定什么什么”，而正则中的断言，就是说正则可以指明在指定的内容的前面或后面会出现满足指定规则的内容，
   意思正则也可以像人类那样断定什么什么，比如"ss1aa2bb3",正则可以用断言找出aa2前面有bb3，也可以找出aa2后面有ss1.
2. 零宽：就是没有宽度，在正则中，断言只是匹配位置，不占字符，也就是说，匹配结果里是不会返回断言本身。

意思是讲明白了，那他有什么用呢？
我们来举个栗子：
假设我们要用爬虫抓取csdn里的文章阅读量。通过查看源代码可以看到文章阅读量这个内容是这样的结构

```text
1   "<span class="read-count">阅读数：641</span>"
```

其中也就‘641’这个是变量，也就是说不同文章不同的值，当我们拿到这个字符串时，需要获得这里边的‘641’有很多种办法，但如果正则应该怎么匹配呢？

下面先来讲几种类型的断言：

1. 正向先行断言（正前瞻）：

- 语法：（?=pattern）
- 作用：匹配pattern表达式的前面内容，不返回本身。

这样子说，还是一脸懵逼，好吧，回归刚才那个栗子，要取到阅读量，在正则表达式中就意味着要能匹配到‘</span>’前面的数字内容
按照上所说的正向先行断言可以匹配表达式前面的内容，那意思就是:(?=</span>) 就可以匹配到前面的内容了。
匹配什么内容呢？如果要所有内容那就是：

```java
 1   String reg=".+(?=</span>)";
 2
 3   String test = "<span class=\"read-count\">阅读数：641</span>";
 4   Pattern pattern = Pattern.compile(reg);
 5   Matcher mc=    pattern.matcher(test);
 6   while(mc.find()){
 7    System.out.println("匹配结果：")
 8    System.out.println(mc.group());
 9   }
10
11   //匹配结果：
12   //<span class="read-count">阅读数：641
```

可是老哥我们要的只是前面的数字呀，那也简单咯，匹配数字 \d,那可以改成：

```java
1   String reg="\\d+(?=</span>)";
2   String test = "<span class=\"read-count\">阅读数：641</span>";
3   Pattern pattern = Pattern.compile(reg);
4   Matcher mc=    pattern.matcher(test);
5   while(mc.find()){
6     System.out.println(mc.group());
7   }
8   //匹配结果：
9   //641
```

大功告成！

\2. 正向后行断言（正后顾）:

- 语法：（?<=pattern）
- 作用：匹配pattern表达式的后面的内容，不返回本身。

有先行就有后行，先行是匹配前面的内容，那后行就是匹配后面的内容啦。
上面的栗子，我们也可以用后行断言来处理.

```java
 1   //(?<=<span class="read-count">阅读数：)\d+
 2   String reg="(?<=<span class=\"read-count\">阅读数：)\\d+";
 3
 4   String test = "<span class=\"read-count\">阅读数：641</span>";
 5   Pattern pattern = Pattern.compile(reg);
 6   Matcher mc=    pattern.matcher(test);
 7        while(mc.find()){
 8          System.out.println(mc.group());
 9        }
10   //匹配结果：
11   //641
```

就这么简单。

\3. 负向先行断言（负前瞻）

- 语法：(?!pattern)
- 作用：匹配非pattern表达式的前面内容，不返回本身。

有正向也有负向，负向在这里其实就是非的意思。
举个栗子：比如有一句 “我爱祖国，我是祖国的花朵”
现在要找到不是'的花朵'前面的祖国
用正则就可以这样写：

```java
1   祖国(?!的花朵)
```

\4. 负向后行断言（负后顾）

- 语法：(?<!pattern)
- 作用：匹配非pattern表达式的后面内容，不返回本身。

## 捕获和非捕获

单纯说到捕获，他的意思是匹配表达式，但捕获通常和分组联系在一起，也就是“捕获组”

> 捕获组：匹配子表达式的内容，把匹配结果保存到内存中中数字编号或显示命名的组里，以深度优先进行编号，之后可以通过序号或名称来使用这些匹配结果。

而根据命名方式的不同，又可以分为两种组：

\1. 数字编号捕获组：
语法：(exp)
解释：从表达式左侧开始，每出现一个左括号和它对应的右括号之间的内容为一个分组，在分组中，第0组为整个表达式，第一组开始为分组。
比如固定电话的：020-85653333
他的正则表达式为：(0\d{2})-(\d{8})
按照左括号的顺序，这个表达式有如下分组：

![img](https://pic4.zhimg.com/50/v2-fcb6eb2d9b164a269dd938fcd0a3554b_hd.jpg?source=1940ef5c)![img](https://pic4.zhimg.com/80/v2-fcb6eb2d9b164a269dd938fcd0a3554b_720w.jpg?source=1940ef5c)

我们用Java来验证一下：

```java
 1   String test = "020-85653333";
 2        String reg="(0\\d{2})-(\\d{8})";
 3        Pattern pattern = Pattern.compile(reg);
 4        Matcher mc= pattern.matcher(test);
 5        if(mc.find()){
 6          System.out.println("分组的个数有："+mc.groupCount());
 7            for(int i=0;i<=mc.groupCount();i++){
 8                System.out.println("第"+i+"个分组为："+mc.group(i));
 9            }
10        }
```

输出结果：

```java
1   分组的个数有：2
2   第0个分组为：020-85653333
3   第1个分组为：020
4   第2个分组为：85653333
```

可见，分组个数是2，但是因为第0个为整个表达式本身，因此也一起输出了。

\2. 命名编号捕获组：
语法：(?<name>exp)
解释：分组的命名由表达式中的name指定
比如区号也可以这样写:(?<quhao>\0\d{2})-(?<haoma>\d{8})
按照左括号的顺序，这个表达式有如下分组：

![img](https://pic1.zhimg.com/50/v2-96796c22cd8306f6f0d7ad8204720166_hd.jpg?source=1940ef5c)![img](https://pic1.zhimg.com/80/v2-96796c22cd8306f6f0d7ad8204720166_720w.jpg?source=1940ef5c)

用代码来验证一下：

```java
1   String test = "020-85653333";
2        String reg="(?<quhao>0\\d{2})-(?<haoma>\\d{8})";
3        Pattern pattern = Pattern.compile(reg);
4        Matcher mc= pattern.matcher(test);
5        if(mc.find()){
6            System.out.println("分组的个数有："+mc.groupCount());
7            System.out.println(mc.group("quhao"));
8            System.out.println(mc.group("haoma"));
9        }
```

输出结果：

```java
1   分组的个数有：2
2   分组名称为:quhao,匹配内容为：020
3   分组名称为:haoma,匹配内容为：85653333
```

\3. 非捕获组：
语法：(?:exp)
解释：和捕获组刚好相反，它用来标识那些不需要捕获的分组，说的通俗一点，就是你可以根据需要去保存你的分组。

比如上面的正则表达式，程序不需要用到第一个分组，那就可以这样写：

```java
1   (?:\0\d{2})-(\d{8})
```

![img](https://pic1.zhimg.com/50/v2-a875e9e70cd3bfc4457fece7e947edb9_hd.jpg?source=1940ef5c)![img](https://pic1.zhimg.com/80/v2-a875e9e70cd3bfc4457fece7e947edb9_720w.jpg?source=1940ef5c)

验证一下：

```java
 1   String test = "020-85653333";
 2        String reg="(?:0\\d{2})-(\\d{8})";
 3        Pattern pattern = Pattern.compile(reg);
 4        Matcher mc= pattern.matcher(test);
 5        if(mc.find()){
 6                System.out.println("分组的个数有："+mc.groupCount());
 7                for(int i=0;i<=mc.groupCount();i++){
 8                    System.out.println("第"+i+"个分组为："+mc.group(i));
 9                }
10        }
```

输出结果：

```java
1   分组的个数有：1
2   第0个分组为：020-85653333
3   第1个分组为：85653333
```

## 反向引用

上面讲到捕获，我们知道：***捕获会返回一个捕获组，这个分组是保存在内存中，不仅可以在正则表达式外部通过程序进行引用，也可以在正则表达式内部进行引用，这种引用方式就是反向引用***。

根据捕获组的命名规则，反向引用可分为：

1. 数字编号组反向引用：\k
   或\number
2. 命名编号组反向引用：\k
   或者\'name'

好了 讲完了，懂吗？不懂！！！
可能连前面讲的捕获有什么用都还不懂吧？
其实只是看完捕获不懂不会用是很正常的！
因为捕获组通常是和反向引用一起使用的

上面说到捕获组是匹配子表达式的内容按序号或者命名保存起来以便使用
注意两个字眼：“内容” 和 “使用”
这里所说的“内容”，是匹配结果，而不是子表达式本身，强调这个有什么用？嗯，先记住
那这里所说的“使用”是怎样使用呢？

因为它的作用主要是用来查找一些重复的内容或者做替换指定字符。

还是举栗子吧：
比如要查找一串字母"aabbbbgbddesddfiid"里成对的字母
如果按照我们之前学到的正则，什么区间啊限定啊断言啊可能是办不到的，
现在我们先用程序思维理一下思路：

- 1）匹配到一个字母
- 2）匹配第下一个字母，检查是否和上一个字母是否一样
- 3）如果一样，则匹配成功，否则失败

这里的思路2中匹配下一个字母时，需要用到上一个字母，那怎么记住上一个字母呢？？？
这下子捕获就有用处啦，我们可以利用捕获把上一个匹配成功的内容用来作为本次匹配的条件
好了，有思路就要实践
首先匹配一个字母：\w
我们需要做成分组才能捕获，因此写成这样：(\w)

那这个表达式就有一个捕获组：（\w）
然后我们要用这个捕获组作为条件，那就可以：(\w)\1
这样就大功告成了
可能有人不明白了，\1是什么意思呢？
还记得捕获组有两种命名方式吗，**一种是是根据捕获分组顺序命名，一种是自定义命名来作为捕获组的命名**
***在默认情况下都是以数字来命名，而且数字命名的顺序是从1开始的\***
因此要引用第一个捕获组，根据反向引用的数字命名规则 就需要 \k<1>或者\1
当然，通常都是是后者。
我们来测试一下：

```java
1   String test = "aabbbbgbddesddfiid";
2        Pattern pattern = Pattern.compile("(\\w)\\1");
3        Matcher mc= pattern.matcher(test);
4        while(mc.find()){
5            System.out.println(mc.group());
6
7        }
```

输出结果：

```java
1   aa
2   bb
3   bb
4   dd
5   dd
6   ii
```

嗯，这就是我们想要的了。

在举个替换的例子，假如想要把字符串中abc换成a

```java
1   String test = "abcbbabcbcgbddesddfiid";
2   String reg="(a)(b)c";
3   System.out.println(test.replaceAll(reg, "$1"));;
```

输出结果：

```java
1   abbabcgbddesddfiid
```
