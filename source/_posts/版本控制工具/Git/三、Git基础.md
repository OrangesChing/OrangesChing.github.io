---
title: 三、Git基础
date: 2021-04-30 09:39:00
categories:
  - 版本控制工具
  - Git
---

# Git工作区域

git 模型可以抽象为  

- 本地三级仓库: 
  1. level1——working directory：工作区/工作目录，就是你平时存放项目代码的地方，需要git来管理的目录
  2. level2——stage(index)：暂存区，用于临时存放你的改动，它只是一个文件，保存即将提交到文件列表信息
  3. level3——repository(History) ：资源库，就是安全存放数据的位置，这里面有你提交到所有版本的数据。其中HEAD指向最新放入仓库的版本
- 远程仓库
  - Remote Directory：托管代码的服务器，可以简单的认为是你项目组中的一台电脑用于远程数据交换

git 的各个命令可以理解为在各个仓库间转移数据，各个命令对应对每个仓库输入输出。

文件在这四个区域之间的转换关系如下：

![img](三、Git基础/63651-20170905201017069-171460014.png)

本地的三个区域确切的说应该是git仓库中HEAD指向的版本

![img](三、Git基础/63651-20170906230652788-1835188684.png)

- Directory：使用Git管理的一个目录，也就是一个仓库，包含我们的工作空间和Git的管理空间。
- WorkSpace：需要通过Git进行版本控制的目录和文件，这些目录和文件组成了工作空间。
- .git：存放Git管理信息的目录，初始化仓库的时候自动创建。
- Index/Stage：暂存区，或者叫待提交更新区，在提交进入repo之前，我们可以把所有的更新放在暂存区。
- Local Repo：本地仓库，一个存放在本地的版本库；HEAD会只是当前的开发分支（branch）。
- Stash：隐藏，是一个工作状态保存栈，用于保存/恢复WorkSpace中的临时状态。

# Git文件4种状态

- **Untracked**: 未追踪，此文件在工作区文件夹中，但并没有加入到git库, <u>不参与版本控制</u>. 通过`git add` 状态变为`Staged`.
- **Unmodify**: 加入到git库，但未修改，即<u>版本库中的文件内容与文件夹中完全一致</u>. 这种类型的文件有两种去处, 如果它被修改, 而变为`Modified`. 如果使用`git rm`移出版本库, 则成为`Untracked`文件
- **Modified**: <u>文件已修改</u>, 仅仅是修改, 并没有进行其他的操作. 这个文件也有两个去处, 通过`git add`可进入暂存`staged`状态, 使用`git checkout` 则丢弃修改过, 返回到`unmodify`状态, 这个`git checkout`即从库中取出文件, 覆盖当前修改
- **Staged**: 暂存状态. <u>执行`git commit`则将修改同步到库</u>中, 这时库中的文件和本地文件又变为一致, 文件为`Unmodify`状态. 执行`git reset HEAD filename`取消暂存, 文件状态为`Modified`

![Git 下文件生命周期图。](三、Git基础/lifecycle.png)

![img](三、Git基础/63651-20170909091456335-1787774607.jpg)

# Git工作流程

git的工作流程一般是这样的：

１、在工作目录中添加、修改文件；

２、将需要进行版本管理的文件放入暂存区域；

３、将暂存区域的文件提交到git仓库。

因此，git管理的文件有三种状态：已修改（modified）,已暂存（staged）,已提交(committed)

![img](三、Git基础/63651-20170905201033647-1915833066.png)

个人认为Git的原理相比别的版本控制器还是复杂一些的，有一份图解教程比较直观：

[图解教程中文版](http://www.cnblogs.com/yaozhongxiao/p/3811130.html)

![img](三、Git基础/63651-20170914100820891-2098204183.png)

# Git分支

## 分支是什么

分支就是科幻电影里面的平行宇宙，当你正在电脑前努力学习Git的时候，另一个你正在另一个平行宇宙里努力学习SVN。

如果两个平行宇宙互不干扰，那对现在的你也没啥影响。不过，在某个时间点，两个平行宇宙合并了，结果，你既学会了Git又学会了SVN！

![learn-branches](三、Git基础/919021987875136)

分支在实际中有什么用呢？假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了50%的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。

现在有了分支，就不用怕了。你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。

## 分支原理

每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即`master`分支。`HEAD`严格来说不是指向提交，而是指向`master`，`master`才是指向提交的，所以，`HEAD`指向的就是当前分支。

一开始的时候，`master`分支是一条线，Git用`master`指向最新的提交，再用`HEAD`指向`master`，就能确定当前分支，以及当前分支的提交点：

![git-br-initial](三、Git基础/0)

每次提交，`master`分支都会向前移动一步，这样，随着你不断提交，`master`分支的线也越来越长。

当我们创建新的分支，例如`dev`时，Git新建了一个指针叫`dev`，指向`master`相同的提交，再把`HEAD`指向`dev`，就表示当前分支在`dev`上：

![git-br-create](三、Git基础/l)

所以，Git创建一个分支很快，因为除了增加一个`dev`指针，改改`HEAD`的指向，工作区的文件都没有任何变化！

不过，从现在开始，对工作区的修改和提交就是针对`dev`分支了，比如新提交一次后，`dev`指针往前移动一步，而`master`指针不变：

![git-br-dev-fd](三、Git基础/2)

假如我们在`dev`上的工作完成了，就可以把`dev`合并到`master`上。Git怎么合并呢？最简单的方法，就是直接把`master`指向`dev`的当前提交，就完成了合并：

![git-br-ff-merge](三、Git基础/3)

所以Git合并分支也很快！就改改指针，工作区内容也不变！

合并完分支后，甚至可以删除`dev`分支。删除`dev`分支就是把`dev`指针给删掉，删掉后，我们就剩下了一条`master`分支：

![git-br-rm](三、Git基础/4)

![img](三、Git基础/63651-20170905212648335-1801547172.gif)

参考整理自：

https://www.cnblogs.com/syp172654682/p/7689328.html

https://www.liaoxuefeng.com/wiki/896043488029600/900003767775424